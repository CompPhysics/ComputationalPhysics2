# Information about all exercises in the file hartreefocktheory.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.hartreefocktheory.exerinfo', 'r')
# exer = eval(f.read())
#
[{'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'sol_docend': '',
  'solution': '',
  'solution_file': None,
  'subex': [{'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Show that the new basis is orthonormal.'},
            {'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Show that the new Slater determinant constructed from '
                     'the new single-particle wave functions can be\n'
                     'written as the determinant based on the previous basis '
                     'and the determinant of the matrix $C$.'},
            {'aftertext': '\n\n\n',
             'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': ['Use the fact that $C$ is a unitary matrix.'],
             'sol_docend': '',
             'solution': '',
             'text': 'Show that the old and the new Slater determinants are '
                     'equal up to a complex constant with absolute value '
                     'unity.'}],
  'text': 'Consider a Slater determinant built up of single-particle orbitals '
          '$\\psi_{\\lambda}$, \n'
          'with $\\lambda = 1,2,\\dots,N$.\n'
          '\n'
          'The unitary transformation\n'
          '!bt\n'
          '\\[\n'
          '\\psi_a  = \\sum_{\\lambda} C_{a\\lambda}\\phi_{\\lambda},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'brings us into the new basis.  \n'
          'The new basis has quantum numbers $a=1,2,\\dots,N$.',
  'title': 'Derivation of Hartree-Fock equations',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 2,
  'sol_docend': '',
  'solution': '',
  'solution_file': None,
  'subex': [{'aftertext': '\n\n\n',
             'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Show that\n'
                     '!bt\n'
                     '\\[\n'
                     '\\langle '
                     '\\delta\\Phi_{0}|\\sum_{i=1}^{n}\\left\\{t(x_{i})+u(x_{i})\n'
                     '\\right\\}+\\frac{1}{2}\n'
                     '\\sum_{i\\neq '
                     'j=1}^{n}v(x_{i},x_{j})|\\Phi_{0}\\rangle=\\sum_{i=1}^{n}\\langle '
                     '\\delta\\psi_{\\alpha_{i}}|\\hat{t}+\\hat{u}\n'
                     '|\\phi_{\\alpha_{i}}\\rangle\n'
                     '+\\sum_{i\\neq '
                     'j=1}^{n}\\left\\{\\langle\\delta\\psi_{\\alpha_{i}}\n'
                     '\\psi_{\\alpha_{j}}|\\hat{v}|\\psi_{\\alpha_{i}}\\psi_{\\alpha_{j}}\\rangle-\n'
                     '\\langle\\delta\\psi_{\\alpha_{i}}\\psi_{\\alpha_{j}}|\\hat{v}\n'
                     '|\\psi_{\\alpha_{j}}\\psi_{\\alpha_{i}}\\rangle\\right\\}\n'
                     '\\]\n'
                     '\n'
                     '!et'}],
  'text': 'Consider the  Slater  determinant\n'
          '!bt\n'
          '\\[\n'
          '\\Phi_{0}=\\frac{1}{\\sqrt{n!}}\\sum_{p}(-)^{p}P\n'
          '\\prod_{i=1}^{n}\\psi_{\\alpha_{i}}(x_{i}).\n'
          '\\]\n'
          '\n'
          '!et\n'
          'A small variation in this function is given by\n'
          '!bt\n'
          '\\[\n'
          '\\delta\\Phi_{0}=\\frac{1}{\\sqrt{n!}}\\sum_{p}(-)^{p}P\n'
          '\\psi_{\\alpha_{1}}(x_{1})\\psi_{\\alpha_{2}}(x_{2})\\dots\n'
          '\\psi_{\\alpha_{i-1}}(x_{i-1})(\\delta\\psi_{\\alpha_{i}}(x_{i}))\n'
          '\\psi_{\\alpha_{i+1}}(x_{i+1})\\dots\\psi_{\\alpha_{n}}(x_{n}).\n'
          '\\]\n'
          '\n'
          '!et',
  'title': 'Derivation of Hartree-Fock equations',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 3,
  'sol_docend': '',
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Neutron drops are a powerful theoretical laboratory for testing,\n'
          'validating and improving nuclear structure models. Indeed, all\n'
          'approaches to nuclear structure, from ab initio theory to shell '
          'model\n'
          'to density functional theory are applicable in such systems. We '
          'will,\n'
          'therefore, use neutron drops as a test system for setting up a\n'
          'Hartree-Fock code.  This program can later be extended to studies '
          'of\n'
          'the binding energy of nuclei like $^{16}$O or $^{40}$Ca. The\n'
          'single-particle energies obtained by solving the Hartree-Fock\n'
          'equations can then be directly related to experimental separation\n'
          'energies. \n'
          'Since Hartree-Fock theory is the starting point for\n'
          'several many-body techniques (density functional theory, '
          'random-phase\n'
          'approximation, shell-model etc), the aim here is to develop a '
          'computer\n'
          'program to solve the Hartree-Fock equations in a given '
          'single-particle basis,\n'
          'here the harmonic oscillator.\n'
          '\n'
          'The Hamiltonian for a system of $N$ neutron drops confined in a\n'
          'harmonic potential reads\n'
          '!bt\n'
          '\\[\n'
          '\\hat{H} = \\sum_{i=1}^{N} '
          '\\frac{\\hat{p}_{i}^{2}}{2m}+\\sum_{i=1}^{N} \\frac{1}{2} m\\omega '
          '{r}_{i}^{2}+\\sum_{i<j} \\hat{V}_{ij},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'with $\\hbar^{2}/2m = 20.73$ fm$^{2}$, $mc^{2} = 938.90590$ MeV, '
          'and \n'
          '$\\hat{V}_{ij}$ is the two-body interaction potential whose \n'
          'matrix elements are precalculated\n'
          'and to be read in by you.\n'
          '\n'
          'The Hartree-Fock algorithm can be broken down as follows. We recall '
          'that  our Hartree-Fock matrix  is \n'
          '!bt\n'
          '\\[\n'
          '\\hat{h}_{\\alpha\\beta}^{HF}=\\langle \\alpha \\vert\\hat{h}_0 '
          '\\vert \\beta \\rangle+\n'
          '\\sum_{j=1}^N\\sum_{\\gamma\\delta} '
          'C^*_{j\\gamma}C_{j\\delta}\\langle '
          '\\alpha\\gamma|V|\\beta\\delta\\rangle_{AS}.\n'
          '\\]\n'
          '\n'
          '!et\n'
          'Normally we assume that the single-particle basis '
          '$\\vert\\beta\\rangle$\n'
          'forms an eigenbasis for the operator $\\hat{h}_0$ (this is our '
          'case), meaning that the\n'
          'Hartree-Fock matrix becomes\n'
          '!bt\n'
          '\\[\n'
          '\\hat{h}_{\\alpha\\beta}^{HF}=\\epsilon_{\\alpha}\\delta_{\\alpha,\\beta}+\n'
          '\\sum_{j=1}^N\\sum_{\\gamma\\delta} '
          'C^*_{j\\gamma}C_{j\\delta}\\langle '
          '\\alpha\\gamma|V|\\beta\\delta\\rangle_{AS}.\n'
          '\\]\n'
          '\n'
          '!et\n'
          'The Hartree-Fock eigenvalue problem\n'
          '!bt\n'
          '\\[\n'
          '\\sum_{\\beta}\\hat{h}_{\\alpha\\beta}^{HF}C_{i\\beta}=\\epsilon_i^{\\mathrm{HF}}C_{i\\alpha},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'can be written out in a more compact form as\n'
          '!bt\n'
          '\\[\n'
          '\\hat{h}^{HF}\\hat{C}=\\epsilon^{\\mathrm{HF}}\\hat{C}. \n'
          '\\]\n'
          '\n'
          '!et\n'
          '\n'
          '\n'
          'The equations are often rewritten in terms of a so-called density '
          'matrix,\n'
          'which is defined as \n'
          '!bt\n'
          '\\begin{equation}\n'
          '\\rho_{\\gamma\\delta}=\\sum_{i=1}^{N}\\langle\\gamma|i\\rangle\\langle '
          'i|\\delta\\rangle = \\sum_{i=1}^{N}C_{i\\gamma}C^*_{i\\delta}.\n'
          'label{_auto2}\n'
          '\\end{equation}\n'
          '\n'
          '!et\n'
          'It means that we can rewrite the Hartree-Fock Hamiltonian as\n'
          '!bt\n'
          '\\[\n'
          '\\hat{h}_{\\alpha\\beta}^{HF}=\\epsilon_{\\alpha}\\delta_{\\alpha,\\beta}+\n'
          '\\sum_{\\gamma\\delta} \\rho_{\\gamma\\delta}\\langle '
          '\\alpha\\gamma|V|\\beta\\delta\\rangle_{AS}.\n'
          '\\]\n'
          '\n'
          '!et\n'
          'It is convenient to use the density matrix since we can '
          'precalculate in every iteration the product of two eigenvector '
          'components $C$. \n'
          '\n'
          '\n'
          'Note that $\\langle \\alpha\\vert\\hat{h}_0\\vert\\beta \\rangle$ '
          'denotes the\n'
          'matrix elements of the one-body part of the starting hamiltonian. '
          'For\n'
          'self-bound nuclei $\\langle \\alpha\\vert\\hat{h}_0\\vert\\beta '
          '\\rangle$ is the\n'
          'kinetic energy, whereas for neutron drops, $\\langle \\alpha \\vert '
          '\\hat{h}_0 \\vert \\beta \\rangle$ represents the harmonic '
          'oscillator hamiltonian since\n'
          'the system is confined in a harmonic trap. If we are working in a\n'
          'harmonic oscillator basis with the same $\\omega$ as the trapping\n'
          'potential, then $\\langle \\alpha\\vert\\hat{h}_0 \\vert \\beta '
          '\\rangle$ is\n'
          'diagonal.\n'
          '\n'
          '\n'
          'The python\n'
          '"program":"https://github.com/CompPhysics/ManyBodyMethods/tree/master/doc/src/hfock/Code"\n'
          'shows how one can, in a brute force way read in matrix elements in\n'
          '$m$-scheme and compute the Hartree-Fock single-particle energies '
          'for\n'
          'four major shells. The interaction which has been used is the\n'
          'so-called N3LO interaction of "Machleidt and\n'
          'Entem":"http://journals.aps.org/prc/abstract/10.1103/PhysRevC.68.041001"\n'
          'using the "Similarity Renormalization\n'
          'Group":"http://journals.aps.org/prc/abstract/10.1103/PhysRevC.75.061001"\n'
          'approach method to renormalize the interaction, using an '
          'oscillator\n'
          'energy $\\hbar\\omega=10$ MeV.\n'
          '\n'
          'The nucleon-nucleon two-body matrix elements are in $m$-scheme and '
          'are fully anti-symmetrized. The Hartree-Fock programs uses the '
          'density matrix discussed above in order to compute the Hartree-Fock '
          'matrix.\n'
          'Here we display the Hartree-Fock part only, assuming that '
          'single-particle data and two-body matrix elements have already been '
          'read in. \n'
          '!bc pycod\n'
          'import numpy as np \n'
          'from decimal import Decimal\n'
          '# expectation value for the one body part, Harmonic oscillator in '
          'three dimensions\n'
          'def onebody(i, n, l):\n'
          '        homega = 10.0\n'
          '        return homega*(2*n[i] + l[i] + 1.5)\n'
          '\n'
          "if __name__ == '__main__':\n"
          '        \n'
          '    Nparticles = 16\n'
          '    """ Read quantum numbers from file """\n'
          '    index = []\n'
          '    n = []\n'
          '    l = []\n'
          '    j = []\n'
          '    mj = []\n'
          '    tz = []\n'
          '    spOrbitals = 0\n'
          '    with open("nucleispnumbers.dat", "r") as qnumfile:\n'
          '                for line in qnumfile:\n'
          '                        nums = line.split()\n'
          '                        if len(nums) != 0:\n'
          '                                index.append(int(nums[0]))\n'
          '                                n.append(int(nums[1]))\n'
          '                                l.append(int(nums[2]))\n'
          '                                j.append(int(nums[3]))\n'
          '                                mj.append(int(nums[4]))\n'
          '                                tz.append(int(nums[5]))\n'
          '                                spOrbitals += 1\n'
          '\n'
          '\n'
          '    """ Read two-nucleon interaction elements (integrals) from '
          'file, brute force 4-dim array """\n'
          '    nninteraction = np.zeros([spOrbitals, spOrbitals, spOrbitals, '
          'spOrbitals])\n'
          '    with open("nucleitwobody.dat", "r") as infile:\n'
          '        for line in infile:\n'
          '                number = line.split()\n'
          '                a = int(number[0]) - 1\n'
          '                b = int(number[1]) - 1\n'
          '                c = int(number[2]) - 1\n'
          '                d = int(number[3]) - 1\n'
          '                nninteraction[a][b][c][d] = Decimal(number[4])\n'
          '        """ Set up single-particle integral """\n'
          '        singleparticleH = np.zeros(spOrbitals)\n'
          '        for i in range(spOrbitals):\n'
          '                singleparticleH[i] = Decimal(onebody(i, n, l))\n'
          '        \n'
          '        """ Star HF-iterations, preparing variables and density '
          'matrix """\n'
          '\n'
          '        """ Coefficients for setting up density matrix, assuming '
          'only one along the diagonals """\n'
          '        C = np.eye(spOrbitals) # HF coefficients\n'
          '        DensityMatrix = np.zeros([spOrbitals,spOrbitals])\n'
          '        for gamma in range(spOrbitals):\n'
          '            for delta in range(spOrbitals):\n'
          '                sum = 0.0\n'
          '                for i in range(Nparticles):\n'
          '                    sum += C[gamma][i]*C[delta][i]\n'
          '                DensityMatrix[gamma][delta] = Decimal(sum)\n'
          '        maxHFiter = 100\n'
          '        epsilon =  1.0e-5 \n'
          '        difference = 1.0\n'
          '        hf_count = 0\n'
          '        oldenergies = np.zeros(spOrbitals)\n'
          '        newenergies = np.zeros(spOrbitals)\n'
          '        while hf_count < maxHFiter and difference > epsilon:\n'
          '                print("############### Iteration %i '
          '###############" % hf_count)\n'
          '                HFmatrix = '
          'np.zeros([spOrbitals,spOrbitals])            \n'
          '                for alpha in range(spOrbitals):\n'
          '                        for beta in range(spOrbitals):\n'
          '                            """  If tests for three-dimensional '
          'systems, including isospin conservation """\n'
          '                            if l[alpha] != l[beta] and j[alpha] != '
          'j[beta] and mj[alpha] != mj[beta] and tz[alpha] != tz[beta]: '
          'continue\n'
          '                            """  Setting up the Fock matrix using '
          'the density matrix and antisymmetrized NN interaction in m-scheme '
          '"""\n'
          '                            sumFockTerm = 0.0\n'
          '                            for gamma in range(spOrbitals):\n'
          '                                for delta in range(spOrbitals):\n'
          '                                    if (mj[alpha]+mj[gamma]) != '
          '(mj[beta]+mj[delta]) and (tz[alpha]+tz[gamma]) != '
          '(tz[beta]+tz[delta]): continue\n'
          '                                    sumFockTerm += '
          'DensityMatrix[gamma][delta]*nninteraction[alpha][gamma][beta][delta]\n'
          '                            HFmatrix[alpha][beta] = '
          'Decimal(sumFockTerm)\n'
          '                            """  Adding the one-body term, here '
          'plain harmonic oscillator """\n'
          '                            if beta == alpha:   '
          'HFmatrix[alpha][alpha] += singleparticleH[alpha]\n'
          '                spenergies, C = np.linalg.eigh(HFmatrix)\n'
          '                """ Setting up new density matrix in m-scheme """\n'
          '                DensityMatrix = np.zeros([spOrbitals,spOrbitals])\n'
          '                for gamma in range(spOrbitals):\n'
          '                    for delta in range(spOrbitals):\n'
          '                        sum = 0.0\n'
          '                        for i in range(Nparticles):\n'
          '                            sum += C[gamma][i]*C[delta][i]\n'
          '                        DensityMatrix[gamma][delta] = Decimal(sum)\n'
          '                newenergies = spenergies\n'
          '                """ Brute force computation of difference between '
          'previous and new sp HF energies """\n'
          '                sum =0.0\n'
          '                for i in range(spOrbitals):\n'
          '                    sum += '
          '(abs(newenergies[i]-oldenergies[i]))/spOrbitals\n'
          '                difference = sum\n'
          '                oldenergies = newenergies\n'
          '                print ("Single-particle energies, ordering may have '
          'changed ")\n'
          '                for i in range(spOrbitals):\n'
          "                    print('{0:4d}  {1:.4f}'.format(i, "
          'Decimal(oldenergies[i])))\n'
          '                hf_count += 1\n'
          '\n'
          '\n'
          '!ec\n'
          'Running the program, one finds that the lowest-lying states for a '
          'nucleus like $^{16}\\mbox{O}$, we see that the nucleon-nucleon '
          'force brings a natural spin-orbit splitting for the $0p$ states (or '
          'other states except the $s$-states).\n'
          'Since we are using the $m$-scheme for our calculations, we observe '
          'that there are several states with the same\n'
          'eigenvalues. The number of eigenvalues corresponds to the '
          'degeneracy $2j+1$ and is well respected in our calculations, as see '
          'from the table here.\n'
          '\n'
          'The values of the lowest-lying states are ($\\pi$ for protons and '
          '$\\nu$ for neutrons)\n'
          '|--------------------------------------------|\n'
          '|   Quantum numbers      |    Energy [MeV]   | \n'
          '|--------------------------------------------|\n'
          '|   $0s_{1/2}^{\\pi}$  | -40.4602                      |\n'
          '|   $0s_{1/2}^{\\pi}$  | -40.4602                      |\n'
          '|   $0s_{1/2}^{\\nu}$  | -40.6426                      |\n'
          '|   $0s_{1/2}^{\\nu}$  | -40.6426                      |\n'
          '|   $0p_{1/2}^{\\pi}$  | -6.7133                      |\n'
          '|   $0p_{1/2}^{\\pi}$  | -6.7133                      |\n'
          '|   $0p_{1/2}^{\\nu}$  |  -6.8403                       |\n'
          '|   $0p_{1/2}^{\\nu}$  |  -6.8403                     |\n'
          '|   $0p_{3/2}^{\\pi}$  |  -11.5886                       |\n'
          '|   $0p_{3/2}^{\\pi}$  |  -11.5886                     |\n'
          '|   $0p_{3/2}^{\\pi}$  |  -11.5886                     |\n'
          '|   $0p_{3/2}^{\\pi}$  |  -11.5886                     |\n'
          '|   $0p_{3/2}^{\\nu}$  | -11.7201                      |\n'
          '|   $0p_{3/2}^{\\nu}$  | -11.7201                      |\n'
          '|   $0p_{3/2}^{\\nu}$  | -11.7201                      |\n'
          '|   $0p_{3/2}^{\\nu}$  | -11.7201                      |\n'
          '|   $0d_{5/2}^{\\pi}$  | 18.7589                      |\n'
          '|   $0d_{5/2}^{\\nu}$  | 18.8082                      |\n'
          '|--------------------------------------------|\n'
          '\n'
          'We can use these results to attempt our first link with '
          'experimental data, namely to compute the shell gap or the '
          'separation energies. The shell gap for neutrons is given by\n'
          '!bt\n'
          '\\[\n'
          '\\Delta S_n= 2BE(N,Z)-BE(N-1,Z)-BE(N+1,Z).\n'
          '\\]\n'
          '\n'
          '!et\n'
          'For $^{16}\\mbox{O}$  we have an experimental value for the  shell '
          'gap of $11.51$ MeV for neutrons, while our Hartree-Fock '
          'calculations result in $25.65$ MeV. This means that correlations '
          'beyond a simple Hartree-Fock calculation with a two-body force play '
          'an important role in nuclear physics.\n'
          'The splitting between the $0p_{3/2}^{\\nu}$ and the '
          '$0p_{1/2}^{\\nu}$ state is 4.88 MeV, while the experimental value '
          'for the gap between the ground state $1/2^{-}$ and the first '
          'excited $3/2^{-}$ states is 6.08 MeV. The two-nucleon spin-orbit '
          'force plays a central role here. In our discussion of nuclear '
          'forces we will see how the spin-orbit force comes into play here.',
  'title': 'Developing a  Hartree-Fock program',
  'type': 'Exercise',
  'type_visible': True}]