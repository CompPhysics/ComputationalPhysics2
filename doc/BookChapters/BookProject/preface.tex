\preface
%  last update : 24/8/2013  mhj

\begin{quotation}
So, ultimately, in order to understand nature it may be necessary to
have a deeper understanding of mathematical relationships. But the
real reason is that the subject is enjoyable, and although we humans
cut nature up in different ways, and we have different courses in
different departments, such compartmentalization is really artificial,
and we should take our intellectual pleasures where we find them. 
{\em Richard Feynman, The Laws of Thermodynamics.}
\end{quotation}

Why a preface you may ask? Isn't that just a mere exposition of a
raison d'$\mathrm{\hat{e}}$tre of an author's choice of material,
preferences, biases, teaching philosophy etc.?  To a large extent I
can answer in the affirmative to that. A preface ought to be personal.
Indeed, what you will see in the various chapters of these notes
represents how I perceive computational physics should be taught.

 This set of lecture notes serves the scope of presenting to you and
train you in an algorithmic approach to problems in the sciences,
represented here by the unity of three disciplines, physics,
mathematics and informatics. This trinity outlines the emerging field
of computational physics.

Our insight in a physical system, combined with numerical mathematics
gives us the rules for setting up an algorithm, viz.~a set of rules
for solving a particular problem.  Our understanding of the physical
system under study is obviously gauged by the natural laws at play,
the initial conditions, boundary conditions and other external
constraints which influence the given system. Having spelled out the
physics, for example in the form of a set of coupled partial
differential equations, we need efficient numerical methods in order
to set up the final algorithm.  This algorithm is in turn coded into a
computer program and executed on available computing facilities.  To
develop such an algorithmic approach, you will be exposed to several
physics cases, spanning from the classical pendulum to quantum
mechanical systems. We will also present some of the most popular
algorithms from numerical mathematics used to solve a plethora of
problems in the sciences.  Finally we will codify these algorithms
using some of the most widely used programming languages, presently C,
C++ and Fortran and its most recent standard Fortran
2008\footnote{Throughout this text we refer to Fortran 2008 as
Fortran, implying the latest standard.}. However, a high-level and fully
object-oriented language like Python is now emerging as a good
alternative although C++ and Fortran still outperform Python when it
comes to computational speed.  In this text we offer an approach where
one can write all programs in C/C++ or Fortran.  We will also show you
how to develop large programs in Python interfacing C++ and/or Fortran
functions for those parts of the program which are CPU intensive.
Such an approach allows you to structure the flow of data in a
high-level language like Python while tasks of a mere repetitive and
CPU intensive nature are left to low-level languages like C++ or
Fortran. Python allows you also to smoothly interface your program
with other software, such as plotting programs or operating system
instructions. A typical Python program you may end up writing contains
everything from compiling and running your codes to preparing the body
of a file for writing up your report.



Computer simulations are nowadays an integral part of contemporary
basic and applied research in the sciences.  Computation is becoming
as important as theory and experiment. In physics, computational
physics, theoretical physics and experimental physics are all equally
important in our daily research and studies of physical
systems. Physics is the unity of theory, experiment and
computation\footnote{We mentioned previously the trinity of physics,
mathematics and informatics. Viewing physics as the trinity of theory,
experiment and simulations is yet another example. It is obviously
tempting to go beyond the sciences. History shows that triunes,
trinities and for example triple deities permeate the Indo-European
cultures (and probably all human cultures), from the ancient Celts and
Hindus to modern days.  The ancient Celts revered many such trinues,
their world was divided into earth, sea and air, nature was divided in
animal, vegetable and mineral and the cardinal colours were red,
yellow and blue, just to mention a few.  As a curious digression, it
was a Gaulish Celt, Hilary, philosopher and bishop of Poitiers (AD
315-367) in his work {\em De Trinitate} who formulated the Holy
Trinity concept of Christianity, perhaps in order to accomodate
millenia of human divination practice.}.  Moreover, the ability "to
compute" forms part of the essential repertoire of research
scientists. Several new fields within computational science have
emerged and strengthened their positions in the last years, such as
computational materials science, bioinformatics, computational
mathematics and mechanics, computational chemistry and physics and so
forth, just to mention a few.  These fields underscore the importance
of simulations as a means to gain novel insights into physical
systems, especially for those cases where no analytical solutions can
be found or an experiment is too complicated or expensive to carry
out.  To be able to simulate large quantal systems with many degrees
of freedom such as strongly interacting electrons in a quantum dot
will be of great importance for future directions in novel fields like
nano-techonology.  This ability often combines knowledge from many
different subjects, in our case essentially from the physical
sciences, numerical mathematics, computing languages, topics from
high-performace computing and some knowledge of computers.


In 1999, when I started this course at the department of physics in
Oslo, computational physics and computational science in general were
still perceived by the majority of physicists and scientists as topics
dealing with just mere tools and number crunching, and not as subjects
of their own.  The computational background of most students enlisting
for the course on computational physics could span from dedicated
hackers and computer freaks to people who basically had never used a
PC. The majority of undergraduate and graduate students had a very
rudimentary knowledge of computational techniques and methods.
Questions like 'do you know of better methods for numerical
integration than the trapezoidal rule' were not uncommon. I do happen
to know of colleagues who applied for time at a supercomputing centre
because they needed to invert matrices of the size of $10^4\times
10^4$ since they were using the trapezoidal rule to compute
integrals. With Gaussian quadrature this dimensionality was easily
reduced to matrix problems of the size of $10^2\times 10^2$, with much
better precision.

More than a decade later most students have now been exposed to a
fairly uniform introduction to computers, basic programming skills and
use of numerical exercises.  Practically every undergraduate student
in physics has now made a Matlab or Maple simulation of for example
the pendulum, with or without chaotic motion.  Nowadays most of you
are familiar, through various undergraduate courses in physics and
mathematics, with interpreted languages such as Maple, Matlab and/or
Mathematica. In addition, the interest in scripting languages such as
Python or Perl has increased considerably in recent years.  The modern
programmer would typically combine several tools, computing
environments and programming languages. A typical example is the
following. Suppose you are working on a project which demands
extensive visualizations of the results. To obtain these results, that
is to solve a physics problems like obtaining the density profile of a
Bose-Einstein condensate, you need however a program which is fairly
fast when computational speed matters.  In this case you would most
likely write a high-performance computing program using Monte Carlo
methods in languages which are tailored for that. These are
represented by programming languages like Fortran and C++.  However,
to visualize the results you would find interpreted languages like
Matlab or scripting languages like Python extremely suitable for your
tasks.  You will therefore end up writing for example a script in
Matlab which calls a Fortran or C++ program where the number crunching
is done and then visualize the results of say a wave equation solver
via Matlab's large library of visualization tools. Alternatively, you
could organize everything into a Python or Perl script which does
everything for you, calls the Fortran and/or C++ programs and performs
the visualization in Matlab or Python. Used correctly, these tools,
spanning from scripting languages to high-performance computing
languages and vizualization programs, speed up your capability to
solve complicated problems.  Being multilingual is thus an advantage
which not only applies to our globalized modern society but to
computing environments as well.  This text shows you how to use C++
and Fortran as programming languages.

There is however more to the picture than meets the eye.  Although
interpreted languages like Matlab, Mathematica and Maple allow you
nowadays to solve very complicated problems, and high-level languages
like Python can be used to solve computational problems, computational
speed and the capability to write an efficient code are topics which
still do matter. To this end, the majority of scientists still use
languages like C++ and Fortran to solve scientific problems.  When you
embark on a master or PhD thesis, you will most likely meet these
high-performance computing languages.  This course emphasizes thus the
use of programming languages like Fortran, Python and C++ instead of
interpreted ones like Matlab or Maple. You should however note that
there are still large differences in computer time between for example
numerical Python and a corresponding C++ program for many numerical
applications in the physical sciences, with a code in C++ or Fortran
being the fastest.

Computational speed is not the only reason for this choice of
programming languages. Another important reason is that we feel that
at a certain stage one needs to have some insights into the algorithm
used, its stability conditions, possible pitfalls like loss of
precision, ranges of applicability, the possibility to improve the
algorithm and taylor it to special purposes etc etc.  One of our major
aims here is to present to you what we would dub 'the algorithmic
approach', a set of rules for doing mathematics or a precise
description of how to solve a problem. To device an algorithm and
thereafter write a code for solving physics problems is a marvelous
way of gaining insight into complicated physical systems. The
algorithm you end up writing reflects in essentially all cases your
own understanding of the physics and the mathematics (the way you
express yourself) of the problem.  We do therefore devote quite some
space to the algorithms behind various functions presented in the
text. Especially, insight into how errors propagate and how to avoid
them is a topic we would like you to pay special attention to. Only
then can you avoid problems like underflow, overflow and loss of
precision. Such a control is not always achievable with interpreted
languages and canned functions where the underlying algorithm and/or
code is not easily accesible.  Although we will at various stages
recommend the use of library routines for say linear
algebra\footnote{Such library functions are often taylored to a given
machine's architecture and should accordingly run faster than user
provided ones.}, our belief is that one should understand what the
given function does, at least to have a mere idea.  With such a
starting point, we strongly believe that it can be easier to develope
more complicated programs on your own using Fortran, C++ or Python.

We have several other aims as well, namely:
\begin{itemize}
\item We would like to give you  an opportunity to gain a 
      deeper understanding of the physics you have learned in other
      courses. In most courses one is normally confronted with simple
      systems which provide exact solutions and mimic to a certain
      extent the realistic cases. Many are however the comments like
      'why can't we do something else than the particle in a box
      potential?'.  In several of the projects we hope to present some
      more 'realistic' cases to solve by various numerical
      methods. This also means that we wish to give examples of how
      physics can be applied in a much broader context than it is
      discussed in the traditional physics undergraduate curriculum.
\item To encourage you to "discover" physics in a way similar to how 
researchers learn in the context of research.
\item Hopefully also to introduce numerical methods and new areas of physics that 
      can be studied with the methods discussed.
\item To teach   structured programming in the context of doing science. 
\item The projects we propose are meant to mimic to a certain extent 
      the situation encountered during a thesis or project work. You
      will tipically have at your disposal 2-3 weeks to solve
      numerically a given project. In so doing you may need to do a
      literature study as well. Finally, we would like you to write a
      report for every project.
\end{itemize}
Our overall goal is to encourage you to learn about science through
experience and by asking questions. Our objective is always
understanding and the purpose of computing is further insight, not
mere numbers!  Simulations can often be considered as
experiments. Rerunning a simulation need not be as costly as rerunning
an experiment.


 
Needless to say, these lecture notes are upgraded continuously, from
typos to new input.  And we do always benefit from your comments,
suggestions and ideas for making these notes better.  It's through the
scientific discourse and critics we advance.  Moreover, I have
benefitted immensely from many discussions with fellow colleagues and
students. In particular I must mention Hans Petter Langtangen, Anders
Malthe-S\o renssen, Knut M\o rken and \O yvind Ryan, whose input
during the last fifteen years has considerably improved these lecture
notes.  Furthermore, the time we have spent and keep spending together
on the Computing in Science Education project at the University, is
just marvelous. Thanks so much. Concerning the Computing in Science
Education initiative, you can read more
at \url{http://www.mn.uio.no/english/about/collaboration/cse/}.


Finally, I would like to add a petit note on referencing. These notes
have evolved over many years and the idea is that they should end up
in the format of a web-based learning environment for doing
computational science. It will be fully free and hopefully represent a
much more efficient way of conveying teaching material than
traditional textbooks.  I have not yet settled on a specific format,
so any input is welcome. At present however, it is very easy for me to
upgrade and improve the material on say a yearly basis, from simple
typos to adding new material.  When accessing the web page of the
course, you will have noticed that you can obtain all source files for
the programs discussed in the text.  Many people have thus written to
me about how they should properly reference this material and whether
they can freely use it. My answer is rather simple.  You are
encouraged to use these codes, modify them, include them in
publications, thesis work, your lectures etc.  As long as your use is
part of the dialectics of science you can use this material freely.
However, since many weekends have elapsed in writing several of these
programs, testing them, sweating over bugs, swearing in front of a
f*@?\%g code which didn't compile properly ten minutes before monday
morning's eight o'clock lecture etc etc, I would dearly appreciate in
case you find these codes of any use, to reference them properly. That
can be done in a simple way, refer to M.~Hjorth-Jensen, {\em
Computational Physics}, University of Oslo (2013). The weblink to the
course should also be included. Hope it is not too much to ask
for. Enjoy!
