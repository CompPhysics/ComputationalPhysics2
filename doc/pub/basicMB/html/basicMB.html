<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computational Physics:  Hartree-Fock methods and introduction to Many-body Theory">

<title>Computational Physics:  Hartree-Fock methods and introduction to Many-body Theory</title>


<style type="text/css">
/* bloodish style */

body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em;  color: #8A0808; }
h2 { font-size: 1.6em;  color: #8A0808; }
h3 { font-size: 1.4em;  color: #8A0808; }
h4 { color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Why Hartree-Fock?', 2, None, '___sec0'),
              ('Why Hartree-Fock?', 2, None, '___sec1'),
              ('Quantum Many-particle Methods', 2, None, '___sec2'),
              ('Selected Texts and Many-body theory', 2, None, '___sec3'),
              ('Definitions', 2, None, '___sec4'),
              ('Definitions', 2, None, '___sec5'),
              ('Definitions', 2, None, '___sec6'),
              ('Definitions', 2, None, '___sec7'),
              ('Definitions', 2, None, '___sec8'),
              ('Definitions', 2, None, '___sec9'),
              ('Definitions and notations', 2, None, '___sec10'),
              ('Definitions and notations', 2, None, '___sec11'),
              ('Definitions and notations', 2, None, '___sec12'),
              ('Definitions and notations', 2, None, '___sec13'),
              ('Definitions and notations', 2, None, '___sec14'),
              ('Definitions and notations', 2, None, '___sec15'),
              ('Definitions and notations', 2, None, '___sec16'),
              ('Definitions and notations', 2, None, '___sec17'),
              ('Definitions and notations', 2, None, '___sec18'),
              ('Definitions and notations', 2, None, '___sec19'),
              ('Brief reminder on some linear algebra properties',
               2,
               None,
               '___sec20'),
              ('Basic Matrix Features', 2, None, '___sec21'),
              ('Basic Matrix Features', 2, None, '___sec22'),
              ('Basic Matrix Features, simple $2 \\times 2$ determinant',
               2,
               None,
               '___sec23'),
              ('Definitions and notations', 2, None, '___sec24'),
              ('Definitions and notations', 2, None, '___sec25'),
              ('Definitions and notations', 2, None, '___sec26'),
              ('Definitions and notations', 2, None, '___sec27'),
              ('Definitions and notations', 2, None, '___sec28'),
              ('Definitions and notations', 2, None, '___sec29'),
              ('Definitions and notations', 2, None, '___sec30'),
              ('Definitions and notations', 2, None, '___sec31'),
              ('Definitions and notations', 2, None, '___sec32'),
              ('Definitions and notations', 2, None, '___sec33'),
              ('Definitions and notations', 2, None, '___sec34'),
              ('Definitions and notations', 2, None, '___sec35'),
              ('Definitions and notations', 2, None, '___sec36'),
              ('Definitions and notations', 2, None, '___sec37'),
              ('Our system, quantum dots', 2, None, '___sec38'),
              ('First tasks', 2, None, '___sec39'),
              ('First tasks, single-particle basis', 2, None, '___sec40'),
              ('Project 1 a): getting started', 2, None, '___sec41'),
              ('Project 1 b): Setting up the single-particle basis',
               2,
               None,
               '___sec42'),
              ('Project 1 c): Computing the two-body matrix elements',
               2,
               None,
               '___sec43'),
              ('Two-body matrix elements', 2, None, '___sec44'),
              ('"Program example for numerical integration":"https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/ParallelizationOpenMP/Project1Integration.cpp"',
               2,
               None,
               '___sec45'),
              ('Gaussian Quadrature, main idea', 2, None, '___sec46'),
              ('Gaussian Quadrature', 2, None, '___sec47'),
              ('Gaussian Quadrature, weight function', 2, None, '___sec48'),
              ('Gaussian Quadrature weights and integration points',
               2,
               None,
               '___sec49'),
              ('Gaussian Quadrature', 2, None, '___sec50'),
              ('Error in Gaussian Quadrature', 2, None, '___sec51'),
              ('Important polynomials in Gaussian Quadrature',
               2,
               None,
               '___sec52'),
              ('Gaussian Quadrature, win-win situation', 2, None, '___sec53'),
              ('Gaussian Quadrature, determining mesh points and weights',
               2,
               None,
               '___sec54'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec55'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec56'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec57'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec58'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec59'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec60'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec61'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec62'),
              ('Orthogonal polynomials, simple code for Legendre polynomials',
               2,
               None,
               '___sec63'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec64'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec65'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec66'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec67'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec68'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec69'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec70'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec71'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec72'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec73'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec74'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec75'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec76'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec77'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec78'),
              ('Application to the case $N=2$', 2, None, '___sec79'),
              ('Application to the case $N=2$', 2, None, '___sec80'),
              ('Application to the case $N=2$', 2, None, '___sec81'),
              ('Application to the case $N=2$', 2, None, '___sec82'),
              ('Application to the case $N=2$', 2, None, '___sec83'),
              ('Back to Hermite polynomials and our type of integrals',
               2,
               None,
               '___sec84'),
              ('Our integrals', 2, None, '___sec85'),
              ('Our integrals', 2, None, '___sec86'),
              ('Single-particle functions in polar coordinates',
               2,
               None,
               '___sec87'),
              ('Eigenfunctions in two dimensions', 2, None, '___sec88'),
              ('Final expression for the eigenfunction', 2, None, '___sec89'),
              ('"Program for computing the Coulomb interaction in polar coordinates":"https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/QDCoulombPotential"',
               2,
               None,
               '___sec90'),
              ('Conserved quantum numbers', 2, None, '___sec91'),
              ('Reminder on Variational Calculus and Lagrangian Multipliers',
               2,
               None,
               '___sec92'),
              ('Variational Calculus and Lagrangian Multipliers, simple example',
               2,
               None,
               '___sec93'),
              ('Manipulating terms', 2, None, '___sec94'),
              ('Adding the Lagrangian multiplier', 2, None, '___sec95'),
              ('And with the Euler-Lagrange equations we get',
               2,
               None,
               '___sec96'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec97'),
              ('More on linear algebra', 2, None, '___sec98'),
              ('Coefficients of a wave function expansion',
               2,
               None,
               '___sec99'),
              ('More Basic Matrix Features, simple $2 \\times 2$ determinant, useful property of determinants',
               2,
               None,
               '___sec100'),
              ('More Basic Matrix Features, $n \\times n$ determinant',
               2,
               None,
               '___sec101'),
              ('More Basic Matrix Features, a general $n \\times n$ determinant',
               2,
               None,
               '___sec102'),
              ('A general Slater determinant', 2, None, '___sec103'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec104'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec105'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec106'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec107'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec108'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec109'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec110'),
              ('Hartree-Fock by varying the coefficients of a wave function expansion',
               2,
               None,
               '___sec111'),
              ('Hartree-Fock algorithm', 2, None, '___sec112'),
              ('Hartree-Fock algorithm', 2, None, '___sec113'),
              ('Hartree-Fock algorithm', 2, None, '___sec114'),
              ('Hartree-Fock algorithm', 2, None, '___sec115'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec116'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec117'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec118'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec119'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec120'),
              ("Analysis of Hartree-Fock equations and Koopman's theorem",
               2,
               None,
               '___sec121'),
              ('Exercise 1: Hartree-Fock Slater determinant',
               2,
               None,
               '___sec122'),
              ('Exercise 2: Matrix elements for the Hartree-Fock method and the nuclear shell model',
               2,
               None,
               '___sec123'),
              ('Developing a  Hartree-Fock program', 2, None, '___sec124'),
              ('"Program for computing the Coulomb interaction in polar coordinates":"https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/HFcode/python/hf.py"',
               2,
               None,
               '___sec125'),
              ('Practicalities with the Hartree-Fock code development, basis construction',
               2,
               None,
               '___sec126'),
              ('Practicalities with the Hartree-Fock code development, two-body basis construction, brute force',
               2,
               None,
               '___sec127'),
              ('Two-body interaction, brute force part I',
               2,
               None,
               '___sec128'),
              ('Two-body interaction, brute force part II',
               2,
               None,
               '___sec129'),
              ('Two-body interaction, brute force part III',
               2,
               None,
               '___sec130'),
              ('Two-body interaction, brute force part IV',
               2,
               None,
               '___sec131'),
              ('Two-body interaction, brute force part V',
               2,
               None,
               '___sec132'),
              ('Practicalities with the Hartree-Fock code development, two-body basis construction',
               2,
               None,
               '___sec133'),
              ('Two-body basis construction', 2, None, '___sec134'),
              ('Hartree-Fock code', 2, None, '___sec135'),
              ('Hartree-Fock code, setting up tables of matrix elements',
               2,
               None,
               '___sec136'),
              ('Example calculations, $N=6$ and $\\omega =1.0$ a.u.',
               2,
               None,
               '___sec137'),
              ('Example calculations, $N=6$ and $\\omega =0.1$ a.u.',
               2,
               None,
               '___sec138')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->



<center><h1>Computational Physics:  Hartree-Fock methods and introduction to Many-body Theory</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen -->

<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b><a href="http://www.nscl.msu.edu/" target="_blank">National Superconducting Cyclotron Laboratory</a> and <a href="https://www.pa.msu.edu/" target="_blank">Department of Physics and Astronomy</a>, <a href="http://www.msu.edu/" target="_blank">Michigan State University</a>, East Lansing, MI 48824, USA</b></center>
<center>[2] <b>Department of Physics, University of Oslo, Oslo, Norway</b></center>
<br>
<p>
<center><h4>Spring 2017</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec0">Why Hartree-Fock?  </h2>

<p>
Hartree-Fock (HF) theory is an algorithm for finding an approximative expression for the ground state of a given Hamiltonian. The basic ingredients are

<ul>
  <li> Define a single-particle basis \( \{\psi_{\alpha}\} \) so that</li>
</ul>

$$ 
\hat{h}^{\mathrm{HF}}\psi_{\alpha} = \varepsilon_{\alpha}\psi_{\alpha}
$$

with the Hartree-Fock Hamiltonian defined as
$$
\hat{h}^{\mathrm{HF}}=\hat{t}+\hat{u}_{\mathrm{ext}}+\hat{u}^{\mathrm{HF}}
$$


<ul>
  <li> The term  \( \hat{u}^{\mathrm{HF}} \) is a single-particle potential to be determined by the HF algorithm.</li>
  <li> The HF algorithm means to choose \( \hat{u}^{\mathrm{HF}} \) in order to have</li> 
</ul>

$$ \langle \hat{H} \rangle = E^{\mathrm{HF}}= \langle \Phi_0 | \hat{H}|\Phi_0 \rangle
$$

that is to find a local minimum with a Slater determinant \( \Phi_0 \) being the ansatz for the ground state. 

<ul>
  <li> The variational principle ensures that \( E^{\mathrm{HF}} \ge E_0 \), with \( E_0 \) the exact ground state energy.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Why Hartree-Fock?  </h2>

<p>
We will show that the Hartree-Fock Hamiltonian \( \hat{h}^{\mathrm{HF}} \) equals our definition of the operator \( \hat{f} \) discussed in connection with the new definition of the normal-ordered Hamiltonian (see later lectures), that is we have, for a specific matrix element
$$
\langle p |\hat{h}^{\mathrm{HF}}| q \rangle =\langle p |\hat{f}| q \rangle=\langle p|\hat{t}+\hat{u}_{\mathrm{ext}}|q \rangle +\sum_{i\le F} \langle pi | \hat{V} | qi\rangle_{AS},
$$

meaning that
$$
\langle p|\hat{u}^{\mathrm{HF}}|q\rangle = \sum_{i\le F} \langle pi | \hat{V} | qi\rangle_{AS}.
$$

The so-called Hartree-Fock potential \( \hat{u}^{\mathrm{HF}} \) brings an explicit medium dependence due to the summation over all single-particle states below the Fermi level \( F \). It brings also in an explicit dependence on the two-body interaction (in nuclear physics we can also have complicated three- or higher-body forces). The two-body interaction, with its contribution from the other bystanding fermions, creates an effective mean field in which a given fermion moves, in addition to the external potential \( \hat{u}_{\mathrm{ext}} \) which confines the motion of the fermion. For systems like nuclei, there is no external confining potential. Nuclei are examples of self-bound systems, where the binding arises due to the intrinsic nature of the strong force. For nuclear systems thus, there would be no external one-body potential in the Hartree-Fock Hamiltonian.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Quantum Many-particle Methods </h2>

<ul>
<li> Large-scale diagonalization (Iterative methods, Lanczo's method, dimensionalities \( 10^{10} \) states)</li>
<li> Coupled cluster theory, favoured method in quantum chemistry, molecular and atomic physics. Applications to ab initio calculations in nuclear physics as well for large nuclei</li>
<li> Perturbative many-body methods</li>
<li> Density functional theories/Mean-field theory and Hartree-Fock theory</li>
<li> Monte-Carlo methods (Only in FYS4411, Computational quantum mechanics)</li>
<li> Green's function theories</li>
<li> and other. The physics of the system hints at which many-body methods to use.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Selected Texts and Many-body theory </h2>

<ul>
<li> Blaizot and Ripka, <em>Quantum Theory of Finite systems</em>, MIT press 1986</li>
<li> Negele and Orland, <em>Quantum Many-Particle Systems</em>, Addison-Wesley, 1987.</li>
<li> Fetter and Walecka, <em>Quantum Theory of Many-Particle Systems</em>, McGraw-Hill, 1971.</li>
<li> Helgaker, Jorgensen and Olsen, <em>Molecular Electronic Structure Theory</em>, Wiley, 2001.</li>
<li> Mattuck, <em>Guide to Feynman Diagrams in the Many-Body Problem</em>, Dover, 1971.</li>
<li> Dickhoff and Van Neck, <em>Many-Body Theory Exposed</em>, World Scientific, 2006.</li>
</ul>

<!-- !split  -->

<h2 id="___sec4">Definitions </h2>

<p>
An operator is defined as \( \hat{O} \) throughout. Unless otherwise specified the number of particles is
always \( N \) and \( d \) is the dimension of the system.  In nuclear physics
we normally define the total number of particles to be \( A=N+Z \), where
\( N \) is total number of neutrons and \( Z \) the total number of
protons. In case of other baryons such isobars \( \Delta \) or various
hyperons such as \( \Lambda \) or \( \Sigma \), one needs to add their
definitions.  Hereafter, \( N \) is reserved for the total number of
particles, unless otherwise specificied.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec5">Definitions </h2>

<p>
The quantum numbers of a single-particle state in coordinate space are
defined by the variable 
$$
x=(\boldsymbol{r},\sigma), 
$$

where 
$$
\boldsymbol{r}\in {\mathbb{R}}^{d},
$$

with \( d=1,2,3 \) represents the spatial coordinates and \( \sigma \) is the eigenspin of the particle. For fermions with eigenspin \( 1/2 \) this means that
$$
 x\in {\mathbb{R}}^{d}\oplus (\frac{1}{2}),
$$

and the integral \( \int dx = \sum_{\sigma}\int d^dr = \sum_{\sigma}\int d\boldsymbol{r} \),
and
$$
\int d^Nx= \int dx_1\int dx_2\dots\int dx_N.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec6">Definitions </h2>

<p>
The quantum mechanical wave function of a given state with quantum numbers \( \lambda \) (encompassing all quantum numbers needed to specify the system), ignoring time, is
$$
\Psi_{\lambda}=\Psi_{\lambda}(x_1,x_2,\dots,x_N),
$$

with \( x_i=(\boldsymbol{r}_i,\sigma_i) \) and the projection of \( \sigma_i \) takes the values
\( \{-1/2,+1/2\} \) for particles with spin \( 1/2 \). 
We will hereafter always refer to \( \Psi_{\lambda} \) as the exact wave function, and if the ground state is not degenerate we label it as 
$$
\Psi_0=\Psi_0(x_1,x_2,\dots,x_N).
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Definitions </h2>

<p>
Since the solution \( \Psi_{\lambda} \) seldomly can be found in closed form, approximations are sought. Here we define an approximative wave function or an ansatz to the exact wave function as 
$$
\Phi_{\lambda}=\Phi_{\lambda}(x_1,x_2,\dots,x_N),
$$

with
$$
\Phi_0=\Phi_0(x_1,x_2,\dots,x_N),
$$

being the ansatz to the ground state.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Definitions </h2>

<p>
The wave function \( \Psi_{\lambda} \) is sought in the Hilbert space of either symmetric or anti-symmetric \( N \)-body functions, namely
$$
\Psi_{\lambda}\in {\cal H}_N:= {\cal H}_1\oplus{\cal H}_1\oplus\dots\oplus{\cal H}_1,
$$

where the single-particle Hilbert space \( \hat{H}_1 \) is the space of square integrable functions over
\( \in {\mathbb{R}}^{d}\oplus (\sigma) \)
resulting in
$$
{\cal H}_1:= L^2(\mathbb{R}^{d}\oplus (\sigma)).
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec9">Definitions </h2>

<p>
Our Hamiltonian is invariant under the permutation (interchange) of two particles.
Since we deal with fermions however, the total wave function is antisymmetric.
Let \( \hat{P} \) be an operator which interchanges two particles.
Due to the symmetries we have ascribed to our Hamiltonian, this operator commutes with the total Hamiltonian,
$$
[\hat{H},\hat{P}] = 0,
$$

meaning that \( \Psi_{\lambda}(x_1, x_2, \dots , x_N) \) is an eigenfunction of 
\( \hat{P} \) as well, that is
$$
\hat{P}_{ij}\Psi_{\lambda}(x_1, x_2, \dots,x_i,\dots,x_j,\dots,x_N)=
\beta\Psi_{\lambda}(x_1, x_2, \dots,x_j,\dots,x_i,\dots,x_N),
$$

where \( \beta \) is the eigenvalue of \( \hat{P} \). We have introduced the suffix \( ij \) in order to indicate that we permute particles \( i \) and \( j \).
The Pauli principle tells us that the total wave function for a system of fermions
has to be antisymmetric, resulting in the eigenvalue \( \beta = -1 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec10">Definitions and notations </h2>

<p>
The Schrodinger equation reads 
$$
\begin{equation}
\hat{H}(x_1, x_2, \dots , x_N) \Psi_{\lambda}(x_1, x_2, \dots , x_N) = 
E_\lambda  \Psi_\lambda(x_1, x_2, \dots , x_N), \label{eq:basicSE1}
\end{equation}
$$

where the vector \( x_i \) represents the coordinates (spatial and spin) of particle \( i \), \( \lambda \) stands  for all the quantum
numbers needed to classify a given \( N \)-particle state and \( \Psi_{\lambda} \) is the pertaining eigenfunction.  Throughout this course,
\( \Psi \) refers to the exact eigenfunction, unless otherwise stated.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Definitions and notations </h2>

<p>
We write the Hamilton operator, or Hamiltonian,  in a generic way 
$$
	\hat{H} = \hat{T} + \hat{V} 
$$

where \( \hat{T} \)  represents the kinetic energy of the system
$$
	\hat{T} = \sum_{i=1}^N \frac{\mathbf{p}_i^2}{2m_i} = \sum_{i=1}^N \left( -\frac{\hbar^2}{2m_i} \mathbf{\nabla_i}^2 \right) =
		\sum_{i=1}^N t(x_i)
$$

while the operator \( \hat{V} \) for the potential energy is given by
$$
\begin{equation}
	\hat{V} = \sum_{i=1}^N \hat{u}_{\mathrm{ext}}(x_i) + \sum_{j < i=1}^N v(x_i,x_j)+\sum_{i < j < k=1}^Nv(x_i,x_j,x_k)+\dots
\label{eq:firstv}
\end{equation}
$$

Hereafter we use natural units, viz.&nbsp;\( \hbar=c=e=1 \), with \( e \) the elementary charge and \( c \) the speed of light. This means that momenta and masses
have dimension energy.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec12">Definitions and notations </h2>

<p>
If one does quantum chemistry, after having introduced the  Born-Oppenheimer approximation which effectively freezes out the nucleonic degrees of freedom, the Hamiltonian for \( N=n_e \) electrons takes the following form 
$$
  \hat{H} = \sum_{i=1}^{n_e} t(x_i) - \sum_{i=1}^{n_e} k\frac{Z}{r_i} + \sum_{i < j}^{n_e} \frac{k}{r_{ij}},
$$

with \( k=1.44 \) eVnm

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Definitions and notations </h2>

<p>
We can rewrite this as
$$
\begin{equation}
    \hat{H} = \hat{H}_0 + \hat{H}_I 
    = \sum_{i=1}^{n_e}\hat{h}_0(x_i) + \sum_{i < j}^{n_e}\frac{1}{r_{ij}},
\label{H1H2}
\end{equation}
$$

where  we have defined 
$$
r_{ij}=| \boldsymbol{r}_i-\boldsymbol{r}_j|,
$$

 and
$$
\begin{equation}
  \hat{h}_0(x_i) =  \hat{t}(x_i) - \frac{Z}{x_i}.
\label{hi}
\end{equation}
$$

The first term of Eq.&nbsp;\eqref{H1H2}, \( H_0 \), is the sum of the \( N \)
<em>one-body</em> Hamiltonians \( \hat{h}_0 \). Each individual
Hamiltonian \( \hat{h}_0 \) contains the kinetic energy operator of an
electron and its potential energy due to the attraction of the
nucleus. The second term, \( H_I \), is the sum of the \( n_e(n_e-1)/2 \)
two-body interactions between each pair of electrons. Note that the double sum carries a restriction \( i < j \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Definitions and notations </h2>

<p>
The potential energy term due to the attraction of the nucleus defines the onebody field \( u_i=u_{\mathrm{ext}}(x_i) \) of Eq.&nbsp;\eqref{eq:firstv}.
We have moved this term into the \( \hat{H}_0 \) part of the Hamiltonian, instead of keeping  it in \( \hat{V} \) as in  Eq.&nbsp;\eqref{eq:firstv}.
The reason is that we will hereafter treat \( \hat{H}_0 \) as our non-interacting  Hamiltonian. For a many-body wavefunction \( \Phi_{\lambda} \) defined by an  
appropriate single-particle basis, we may solve exactly the non-interacting eigenvalue problem 
$$
\hat{H}_0\Phi_{\lambda}= w_{\lambda}\Phi_{\lambda},
$$

with \( w_{\lambda} \) being the non-interacting energy. This energy is defined by the sum over single-particle energies to be defined below.
For atoms the single-particle energies could be the hydrogen-like single-particle energies corrected for the charge \( Z \). For nuclei and quantum
dots, these energies could be given by the harmonic oscillator in three and two dimensions, respectively.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec15">Definitions and notations </h2>

<p>
We will assume that the interacting part of the Hamiltonian
can be approximated by a two-body interaction.
This means that our Hamiltonian is written as 
$$
\begin{equation}
    \hat{H} = \hat{H}_0 + \hat{H}_I 
    = \sum_{i=1}^N \hat{h}_0(x_i) + \sum_{i < j}^N V(r_{ij}),
\label{Hnuclei}
\end{equation}
$$

with 
$$
\begin{equation}
  H_0=\sum_{i=1}^N \hat{h}_0(x_i) =  \sum_{i=1}^N\left(\hat{t}(x_i) + \hat{u}_{\mathrm{ext}}(x_i)\right).
\label{hinuclei}
\end{equation}
$$

The onebody part \( u_{\mathrm{ext}}(x_i) \) is normally approximated by a harmonic oscillator potential or the Coulomb interaction an electron feels from the nucleus. However, other potentials are fully possible, such as 
one derived from the self-consistent solution of the Hartree-Fock equations.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec16">Definitions and notations </h2>

<p>
Our Hamiltonian is invariant under the permutation (interchange) of two particles. % (exercise here, prove it)
Since we deal with fermions however, the total wave function is antisymmetric.
Let \( \hat{P} \) be an operator which interchanges two particles.
Due to the symmetries we have ascribed to our Hamiltonian, this operator commutes with the total Hamiltonian,
$$
[\hat{H},\hat{P}] = 0,
 $$

meaning that \( \Psi_{\lambda}(x_1, x_2, \dots , x_N) \) is an eigenfunction of 
\( \hat{P} \) as well, that is
$$
\hat{P}_{ij}\Psi_{\lambda}(x_1, x_2, \dots,x_i,\dots,x_j,\dots,x_N)=
\beta\Psi_{\lambda}(x_1, x_2, \dots,x_i,\dots,x_j,\dots,x_N),
$$

where \( \beta \) is the eigenvalue of \( \hat{P} \). We have introduced the suffix \( ij \) in order to indicate that we permute particles \( i \) and \( j \).
The Pauli principle tells us that the total wave function for a system of fermions
has to be antisymmetric, resulting in the eigenvalue \( \beta = -1 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Definitions and notations </h2>

<p>
In our case we assume that  we can approximate the exact eigenfunction with a Slater determinant
$$
\begin{equation}
   \Phi(x_1, x_2,\dots ,x_N,\alpha,\beta,\dots, \sigma)=\frac{1}{\sqrt{N!}}
\left| \begin{array}{ccccc} \psi_{\alpha}(x_1)& \psi_{\alpha}(x_2)& \dots & \dots & \psi_{\alpha}(x_N)\\
                            \psi_{\beta}(x_1)&\psi_{\beta}(x_2)& \dots & \dots & \psi_{\beta}(x_N)\\  
                            \dots & \dots & \dots & \dots & \dots \\
                            \dots & \dots & \dots & \dots & \dots \\
                     \psi_{\sigma}(x_1)&\psi_{\sigma}(x_2)& \dots & \dots & \psi_{\sigma}(x_N)\end{array} \right|, \label{eq:HartreeFockDet}
\end{equation}
$$

where  \( x_i \)  stand for the coordinates and spin values of a particle \( i \) and \( \alpha,\beta,\dots, \gamma \) 
are quantum numbers needed to describe remaining quantum numbers.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec18">Definitions and notations </h2>

<p>
The single-particle function \( \psi_{\alpha}(x_i) \)  are eigenfunctions of the onebody
Hamiltonian \( h_i \), that is
$$
\hat{h}_0(x_i)=\hat{t}(x_i) + \hat{u}_{\mathrm{ext}}(x_i),
$$

with eigenvalues 
$$
\hat{h}_0(x_i) \psi_{\alpha}(x_i)=\left(\hat{t}(x_i) + \hat{u}_{\mathrm{ext}}(x_i)\right)\psi_{\alpha}(x_i)=\varepsilon_{\alpha}\psi_{\alpha}(x_i).
$$

The energies \( \varepsilon_{\alpha} \) are the so-called non-interacting single-particle energies, or unperturbed energies. 
The total energy is in this case the sum over all  single-particle energies, if no two-body or more complicated
many-body interactions are present.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec19">Definitions and notations </h2>

<p>
Let us denote the ground state energy by \( E_0 \). According to the
variational principle we have
$$
  E_0 \le E[\Phi] = \int \Phi^*\hat{H}\Phi d\mathbf{\tau}
$$

where \( \Phi \) is a trial function which we assume to be normalized
$$
  \int \Phi^*\Phi d\mathbf{\tau} = 1,
$$

where we have used the shorthand \( d\mathbf{\tau}=d\mathbf{r}_1d\mathbf{r}_2\dots d\mathbf{r}_N \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec20">Brief reminder on some linear algebra properties </h2>

<p>
Before we proceed with a more compact representation of a Slater determinant, we would like to repeat some linear algebra properties which will be useful for our derivations of the energy as function of a Slater determinant, Hartree-Fock theory and later the nuclear shell model.

<p>
The inverse of a matrix is defined by

$$
\mathbf{A}^{-1} \cdot \mathbf{A} = I
$$

A unitary matrix \( \mathbf{A} \) is one whose inverse is its adjoint
$$
\mathbf{A}^{-1}=\mathbf{A}^{\dagger}
$$

A real unitary matrix is called orthogonal and its inverse is equal to its transpose.
A hermitian matrix is its own self-adjoint, that  is
$$
\mathbf{A}=\mathbf{A}^{\dagger}. 
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec21">Basic Matrix Features </h2>

<p>
 Matrix Properties Reminder

<p>
<table border="1">
<thead>
<tr><th align="center">                Relations                 </th> <th align="center">      Name     </th> <th align="center">                              matrix elements                              </th> </tr>
</thead>
<tbody>
<tr><td align="center">   \( A = A^{T} \)                               </td> <td align="center">   symmetric          </td> <td align="center">   \( a_{ij} = a_{ji} \)                                                          </td> </tr>
<tr><td align="center">   \( A = \left (A^{T} \right )^{-1} \)          </td> <td align="center">   real orthogonal    </td> <td align="center">   \( \sum_k a_{ik} a_{jk} = \sum_k a_{ki} a_{kj} = \delta_{ij} \)                </td> </tr>
<tr><td align="center">   \( A = A^{ * } \)                             </td> <td align="center">   real matrix        </td> <td align="center">   \( a_{ij} = a_{ij}^{ * } \)                                                    </td> </tr>
<tr><td align="center">   \( A = A^{\dagger} \)                         </td> <td align="center">   hermitian          </td> <td align="center">   \( a_{ij} = a_{ji}^{ * } \)                                                    </td> </tr>
<tr><td align="center">   \( A = \left (A^{\dagger} \right )^{-1} \)    </td> <td align="center">   unitary            </td> <td align="center">   \( \sum_k a_{ik} a_{jk}^{ * } = \sum_k a_{ki}^{ * } a_{kj} = \delta_{ij} \)    </td> </tr>
</tbody>
</table>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Basic Matrix Features </h2>

<p>
Since we will deal with Fermions (identical and indistinguishable particles) we will 
form an ansatz for a given state in terms of so-called Slater determinants determined
by a chosen basis of single-particle functions.

<p>
For a given \( n\times n \) matrix \( \mathbf{A} \) we can write its determinant
$$
   det(\mathbf{A})=|\mathbf{A}|=
\left| \begin{array}{ccccc} a_{11}& a_{12}& \dots & \dots & a_{1n}\\
                            a_{21}&a_{22}& \dots & \dots & a_{2n}\\  
                            \dots & \dots & \dots & \dots & \dots \\
                            \dots & \dots & \dots & \dots & \dots \\
                            a_{n1}& a_{n2}& \dots & \dots & a_{nn}\end{array} \right|,
$$

in a more compact form as 
$$
|\mathbf{A}|= \sum_{i=1}^{n!}(-1)^{p_i}\hat{P}_i a_{11}a_{22}\dots a_{nn},
$$

where \( \hat{P}_i \) is a permutation operator which permutes the column indices \( 1,2,3,\dots,n \)
and the sum runs over all \( n! \) permutations.  The quantity \( p_i \) represents the number of transpositions of column indices that are needed in order to bring a given permutation back to its initial ordering, in our case given by \( a_{11}a_{22}\dots a_{nn} \) here.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec23">Basic Matrix Features, simple \( 2 \times 2 \) determinant  </h2>

<p>
A simple \( 2\times 2 \) determinant illustrates this. We have
$$
   det(\mathbf{A})=
\left| \begin{array}{cc} a_{11}& a_{12}\\
                            a_{21}&a_{22}\end{array} \right|= (-1)^0a_{11}a_{22}+(-1)^1a_{12}a_{21},
$$

where in the last term we have interchanged the column indices \( 1 \) and \( 2 \). The natural ordering we have chosen is \( a_{11}a_{22} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec24">Definitions and notations </h2>

<p>
With the above we can rewrite our Slater determinant in a more compact form.
In the Hartree-Fock method the trial function is the Slater
determinant of Eq.&nbsp;\eqref{eq:HartreeFockDet} which can be rewritten as 
$$
  \Phi(x_1,x_2,\dots,x_N,\alpha,\beta,\dots,\nu) = \frac{1}{\sqrt{N!}}\sum_{P} (-)^P\hat{P}\psi_{\alpha}(x_1)
    \psi_{\beta}(x_2)\dots\psi_{\nu}(x_N)=\sqrt{N!}\hat{A}\Phi_H,
$$

where we have introduced the antisymmetrization operator \( \hat{A} \) defined by the 
summation over all possible permutations of two particles.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec25">Definitions and notations </h2>

<p>
It is defined as
$$
\begin{equation}
  \hat{A} = \frac{1}{N!}\sum_{p} (-)^p\hat{P},
\label{antiSymmetryOperator}
\end{equation}
$$

with \( p \) standing for the number of permutations. We have introduced for later use the so-called
Hartree-function, defined by the simple product of all possible single-particle functions
$$
  \Phi_H(x_1,x_2,\dots,x_N,\alpha,\beta,\dots,\nu) =
  \psi_{\alpha}(x_1)
    \psi_{\beta}(x_2)\dots\psi_{\nu}(x_N).
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec26">Definitions and notations </h2>

<p>
Both \( \hat{H}_0 \) and \( \hat{H}_I \) are invariant under all possible permutations of any two particles
and hence commute with \( \hat{A} \)
$$
\begin{equation}
  [H_0,\hat{A}] = [H_I,\hat{A}] = 0. \label{commutionAntiSym}
\end{equation}
$$

Furthermore, \( \hat{A} \) satisfies
$$
\begin{equation}
  \hat{A}^2 = \hat{A},  \label{AntiSymSquared}
\end{equation}
$$

since every permutation of the Slater
determinant reproduces it.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Definitions and notations </h2>

<p>
The expectation value of \( \hat{H}_0 \) 
$$
  \int \Phi^*\hat{H}_0\Phi d\mathbf{\tau} 
  = N! \int \Phi_H^*\hat{A}\hat{H}_0\hat{A}\Phi_H d\mathbf{\tau}
$$

is readily reduced to
$$
  \int \Phi^*\hat{H}_0\Phi d\mathbf{\tau} 
  = N! \int \Phi_H^*\hat{H}_0\hat{A}\Phi_H d\mathbf{\tau},
$$

where we have used Eqs.&nbsp;\eqref{commutionAntiSym} and
\eqref{AntiSymSquared}. The next step is to replace the antisymmetrization
operator by its definition and to
replace \( \hat{H}_0 \) with the sum of one-body operators
$$
  \int \Phi^*\hat{H}_0\Phi  d\mathbf{\tau}
  = \sum_{i=1}^N \sum_{p} (-)^p\int 
  \Phi_H^*\hat{h}_0\hat{P}\Phi_H d\mathbf{\tau}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Definitions and notations </h2>

<p>
The integral vanishes if two or more particles are permuted in only one
of the Hartree-functions \( \Phi_H \) because the individual single-particle wave functions are
orthogonal. We obtain then
$$
  \int \Phi^*\hat{H}_0\Phi  d\mathbf{\tau}= \sum_{i=1}^N \int \Phi_H^*\hat{h}_0\Phi_H  d\mathbf{\tau}.
$$

Orthogonality of the single-particle functions allows us to further simplify the integral, and we
arrive at the following expression for the expectation values of the
sum of one-body Hamiltonians 
$$
\begin{equation}
  \int \Phi^*\hat{H}_0\Phi  d\mathbf{\tau}
  = \sum_{\mu=1}^N \int \psi_{\mu}^*(\mathbf{r})\hat{h}_0\psi_{\mu}(\mathbf{r})
  d\mathbf{r}.
\label{H1Expectation}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec29">Definitions and notations </h2>

<p>
We introduce the following shorthand for the above integral
$$
\langle \mu | \hat{h}_0 | \mu \rangle = \int \psi_{\mu}^*(\mathbf{r})\hat{h}_0\psi_{\mu}(\mathbf{r})  d\mathbf{r},
$$

and rewrite Eq.&nbsp;\eqref{H1Expectation} as
$$
\begin{equation}
  \int \Phi^*\hat{H}_0\Phi  d\mathbf{\tau}
  = \sum_{\mu=1}^N \langle \mu | \hat{h}_0 | \mu \rangle.
\label{H1Expectation1}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Definitions and notations </h2>

<p>
The expectation value of the two-body part of the Hamiltonian is obtained in a
similar manner. We have
$$
  \int \Phi^*\hat{H}_I\Phi d\mathbf{\tau} 
  = N! \int \Phi_H^*\hat{A}\hat{H}_I\hat{A}\Phi_H d\mathbf{\tau},
$$

which reduces to
$$
 \int \Phi^*\hat{H}_I\Phi d\mathbf{\tau} 
  = \sum_{i\le j=1}^N \sum_{p} (-)^p\int 
  \Phi_H^*V(r_{ij})\hat{P}\Phi_H d\mathbf{\tau},
$$

by following the same arguments as for the one-body
Hamiltonian.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec31">Definitions and notations </h2>

<p>
Because of the dependence on the inter-particle distance \( r_{ij} \),  permutations of
any two particles no longer vanish, and we get
$$
  \int \Phi^*\hat{H}_I\Phi d\mathbf{\tau} 
  = \sum_{i < j=1}^N \int  
  \Phi_H^*V(r_{ij})(1-P_{ij})\Phi_H d\mathbf{\tau}.
$$

where \( P_{ij} \) is the permutation operator that interchanges
particle \( i \) and particle \( j \). Again we use the assumption that the single-particle wave functions
are orthogonal.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec32">Definitions and notations </h2>

<p>
We obtain
$$
\begin{align}
  \int \Phi^*\hat{H}_I\Phi d\mathbf{\tau} 
  = \frac{1}{2}\sum_{\mu=1}^N\sum_{\nu=1}^N
    &\left[ \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)V(r_{ij})\psi_{\mu}(x_i)\psi_{\nu}(x_j)
    dx_idx_j \right.
\label{_auto1}\\
  &\left.
  - \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)
  V(r_{ij})\psi_{\nu}(x_i)\psi_{\mu}(x_j)
  dx_idx_j
  \right]. \label{H2Expectation}
\end{align}
$$

The first term is the so-called direct term. It is frequently also called the  Hartree term, 
while the second is due to the Pauli principle and is called
the exchange term or just the Fock term.
The factor  \( 1/2 \) is introduced because we now run over
all pairs twice.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec33">Definitions and notations </h2>

<p>
The last equation allows us to  introduce some further definitions.  
The single-particle wave functions \( \psi_{\mu}(x) \), defined by the quantum numbers \( \mu \) and \( x \)
are defined as the overlap 
$$
   \psi_{\alpha}(x)  = \langle x | \alpha \rangle .
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec34">Definitions and notations </h2>

<p>
We introduce the following shorthands for the above two integrals
$$
\langle \mu\nu|\hat{v}|\mu\nu\rangle =  \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)V(r_{ij})\psi_{\mu}(x_i)\psi_{\nu}(x_j)
    dx_idx_j,
$$

and
$$
\langle \mu\nu|\hat{v}|\nu\mu\rangle = \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)
  V(r_{ij})\psi_{\nu}(x_i)\psi_{\mu}(x_j)
  dx_idx_j.  
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec35">Definitions and notations </h2>

<p>
The direct and exchange matrix elements can be  brought together if we define the antisymmetrized matrix element
$$
\langle \mu\nu|\hat{v}|\mu\nu\rangle_{\mathrm{AS}}= \langle \mu\nu|\hat{v}|\mu\nu\rangle-\langle \mu\nu|\hat{v}|\nu\mu\rangle,
$$

or for a general matrix element  
$$
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{\mathrm{AS}}= \langle \mu\nu|\hat{v}|\sigma\tau\rangle-\langle \mu\nu|\hat{v}|\tau\sigma\rangle.
$$

It has the symmetry property
$$
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{\mathrm{AS}}= -\langle \mu\nu|\hat{v}|\tau\sigma\rangle_{\mathrm{AS}}=-\langle \nu\mu|\hat{v}|\sigma\tau\rangle_{\mathrm{AS}}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Definitions and notations </h2>

<p>
The antisymmetric matrix element is also hermitian, implying 
$$
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{\mathrm{AS}}= \langle \sigma\tau|\hat{v}|\mu\nu\rangle_{\mathrm{AS}}.
$$

With these notations we rewrite Eq.&nbsp;\eqref{H2Expectation} as 
$$
\begin{equation}
  \int \Phi^*\hat{H}_I\Phi d\mathbf{\tau} 
  = \frac{1}{2}\sum_{\mu=1}^N\sum_{\nu=1}^N \langle \mu\nu|\hat{v}|\mu\nu\rangle_{\mathrm{AS}}.
\label{H2Expectation2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec37">Definitions and notations </h2>

<p>
Combining Eqs.&nbsp;\eqref{H1Expectation1} and
\eqref{H2Expectation2} we obtain the energy functional 
$$
\begin{equation}
  E[\Phi] 
  = \sum_{\mu=1}^N \langle \mu | \hat{h}_0 | \mu \rangle +
  \frac{1}{2}\sum_{{\mu}=1}^N\sum_{{\nu}=1}^N \langle \mu\nu|\hat{v}|\mu\nu\rangle_{\mathrm{AS}}.
\label{FunctionalEPhi}
\end{equation}
$$

which we will use as our starting point for the Hartree-Fock calculations.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec38">Our system, quantum dots </h2>

<p>
We will deal only with systems where all possible single-particle states below a certain level are filled up. Such systems are called closed shell systems, a naming inspired from atomic and nuclear physics. These closed shell systems define what is frequently named <b>magic numbers</b>. Quantum dots exhibit also magic numbers, meaning that the addition or removal of one eletron requires more energy than systems where the lowest-lying shells are not filled. Using the harmonic oscillator in two dimensions as basis functions (with degenerate single-particle energies) the magic numbers are \( N=2 \), \( N=6 \), \( N=12 \), \( N=20 \) etc, where \( N \) is the number of electrons. See the table below for more details.

<p>
We write our Hamiltonian as a one-body part 
$$
\hat{H}_0=\sum_{i=1}^{N_e}\left(-{\frac{1}{2}}\nabla^2_{i}+\frac{ \omega^2}{2}r^2_{i} \right),
$$

and an interacting part
$$
\hat{V}=\sum_{i < j}^{N_e}\frac{1}{|\boldsymbol{r}_i-\boldsymbol{r}_j|}.
$$

The unperturbed part of the Hamiltonian yields the  single-particle energies
$$
\epsilon_i = \omega\left(2n+|m| + 1\right),
$$

where \( n = 0,1,2,3,.. \) and \( m = 0, \pm 1, \pm 2,.. \). The index \( i \) runs from \( 0,1,2,\dots \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec39">First tasks </h2>

<p>
The first project deals with setting up a Hartree-Fock program that is flexible enough to handle different magic numbers. Hartree-Fock is the simplest possible many-body method. We will use the harmonic oscillator functions as basis functions and via the Hartree-Fock method modify the potential which confines the motion of the electrons by accounting for the Coulomb repulsion between electrons. The Hartree-Fock method leads to a set of coupled single-particle equations. If properly written, the system can easily be extended to three-dimensional electronic systems or other fermionic many-body systems.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec40">First tasks, single-particle basis </h2>

<p>
If only the harmonic oscillator part of the Hamiltonian,
the so-called unperturbed part is given by

$$
\begin{equation*} \hat{H}_0=\sum_{i=1}^{N} \left(  -\frac{1}{2} \nabla_i^2 + \frac{1}{2} \omega^2r_i^2  \right).
\end{equation*}
$$

The wave function for one electron in an oscillator potential in two dimensions is

$$
\begin{equation*}
\phi_{n_x,n_y}(x,y) = A H_{n_x}(\sqrt{\omega}x)H_{n_y}(\sqrt{\omega}y)\exp{(-\omega(x^2+y^2)/2}.
\end{equation*}
$$

The functions \( H_{n_x}(\sqrt{\omega}x) \) are so-called Hermite polynomials, discussed in the appendix while \( A \) is a normalization constant. 
For the lowest-lying state we have \( n_x=n_y=0 \) and an energy \( \epsilon_{n_x,n_y}=\omega(n_x+n_y+1) = \omega \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec41">Project 1 a): getting started </h2>

<p>
Make a program that sets up all the quantum numbers for the single-particle basis using a harmonic oscillator in two dimensions. The list should contain the quantum numbers \( n_x \) and \( n_y \), spin and its projection and the single particle energies in atomic units. Define a cutoff in the list according to the harmonic oscillator excitation energy. 
The table here lists the first four harmonic oscillator shells, with its pertinent degeneracies, and the total number of electrons which can be accomodated up to a given energy. These numbers are the so-called <em>magic numbers</em> for a two-dimensional quantum dot. The degeneracies take into account the two spin values an electron can take. Convince yourself about the correctness of this table and use it to check that your code is running correctly.

<p>
<table border="1">
<thead>
<tr><th align="center">Shell number</th> <td align="center">                 \( (n_x, n_y) \)                 </td> <th align="center">      Energy      </th> <th align="center">Degeneracy</th> <td align="center">\( N \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1               </td> <td align="center">   \( (0,0) \)                                           </td> <td align="center">   \( \hbar\omega \)     </td> <td align="center">   2             </td> <td align="center">   2          </td> </tr>
<tr><td align="center">   2               </td> <td align="center">   \( (1,0) \), \( (0,1) \)                              </td> <td align="center">   \( 2\hbar\omega \)    </td> <td align="center">   4             </td> <td align="center">   6          </td> </tr>
<tr><td align="center">   3               </td> <td align="center">   \( (2,0) \), \( (0,2) \), \( (1,1) \)                 </td> <td align="center">   \( 3\hbar\omega \)    </td> <td align="center">   6             </td> <td align="center">   12         </td> </tr>
<tr><td align="center">   3               </td> <td align="center">   \( (3,0) \), \( (0,3) \), \( (2,1) \), \( (1,2) \)    </td> <td align="center">   \( 4\hbar\omega \)    </td> <td align="center">   8             </td> <td align="center">   20         </td> </tr>
</tbody>
</table>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec42">Project 1 b): Setting up the single-particle basis </h2>

<p>
With the single-particle basis from the previous step, you should now write a class which encodes the information about the harmonic oscillator single-particle basis. This should include the single-particle energies, spin and its projections as well as the harmonic oscillator  functions that depend on \( n_x \) and \( n_y \). This class can then used for both the Monte Carlo and the Hartree-Fock calculations.

<p>
<!-- !split  -->

<h2 id="___sec43">Project 1 c): Computing the two-body matrix elements </h2>

<p>
In the Hartree-Fock project we need to be able to compute the two-electron matrix elements of the two-body Coulomb interaction. 
In order to set up the two-body matrix elements, we need to define the so-called direct and exchange matrix elements. This leads to what we call an anti-symmetrized matrix element.

<p>
We introduce the following shorthands for the  integrals
$$
\langle pq|\hat{v}|rs\rangle =  \int \psi_{p}^*(x_i)\psi_{q}^*(x_j)V(r_{ij})\psi_{r}(x_i)\psi_{s}(x_j)
    dx_idx_j,
$$

which defines the so-called direct matrix element 
and
$$
\langle pq|\hat{v}|sr\rangle = \int \psi_{p}^*(x_i)\psi_{q}^*(x_j)
  V(r_{ij})\psi_{s}(x_i)\psi_{r}(x_j)
  dx_idx_j,  
$$

which defines the exchange element. The variables \( pqrs \) define all the single-particle quantum numbers. In our case these are \( n_x \), \( n_y \) and spin and its projections.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec44">Two-body matrix elements </h2>

<p>
These matrix elements are defined in terms of two-body quantum numbers. Which quantum numbers are conserved?
Which are  the possible values the total spin of a two-body state can have?

<p>
The direct and exchange matrix elements can be  brought together if we define the anti-symmetrized matrix element
$$
\langle pq|\hat{v}|rs\rangle_{\mathrm{AS}}= \langle pq|\hat{v}|rs\rangle-\langle pq|\hat{v}|sr\rangle.
$$

It has the symmetry property
$$
\langle pq|\hat{v}|rs\rangle_{\mathrm{AS}}= -\langle pq|\hat{v}|sr\rangle_{\mathrm{AS}}=-\langle qp|\hat{v}|rs\rangle_{\mathrm{AS}},
$$

and
$$
\langle pq|\hat{v}|rs\rangle_{\mathrm{AS}}= \langle qp|\hat{v}|sr\rangle_{\mathrm{AS}}.
$$

Your task is to write a function which calculates the integral 
$$
\langle pq|\hat{v}|rs\rangle =  \int \psi_{p}^*(x_i)\psi_{q}^*(x_j)V(r_{ij})\psi_{r}(x_i)\psi_{s}(x_j)
    dx_idx_j,
$$

and then assemble the direct and exchange terms in order to construct the anti-symmetrized matrix elements to be used in the Hartree-Fock calculations. The integral is four-dimensional but can eventually be simplified. Your task is to figure out how. You should also consider whether it is appropriate to store the matrix elements for the Hartree-Fock calculations.  <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/Literature/lectures2015.pdf" target="_blank">Chapter five</a> of the lecture notes discusses Gaussian quadrature. You may find it convenient to use Hermite   polynomials in order to set up the integration points ad weights as well parallelizing the calculations of the integrals.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec45"><a href="https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/ParallelizationOpenMP/Project1Integration.cpp" target="_blank">Program example for numerical integration</a> </h2>
The following program shows the integration of a first-order Hermite polynomial for
the four-dimensional case. The Hermite polynomials have the following norm
$$
\begin{equation*}
  \int_{-\infty}^{\infty}e^{-x^2}H_n(x)^2dx=2^nn!\sqrt{\pi}.
\end{equation*}
$$

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// OpenMP code for numerical integration with Gauss-Hermite quadrature</span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstdlib&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iomanip&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span>  <span style="color: #408080; font-style: italic">&lt;omp.h&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std; 

<span style="color: #408080; font-style: italic">// The integrand in Cartesian coordinates</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">Integrand</span>(<span style="color: #B00040">double</span>, <span style="color: #B00040">double</span>,<span style="color: #B00040">double</span>, <span style="color: #B00040">double</span>);
<span style="color: #408080; font-style: italic">// The Gauss Hermite integration function</span>
<span style="color: #B00040">double</span>  <span style="color: #0000FF">GaussHermiteIntegration</span>(<span style="color: #B00040">int</span>);
<span style="color: #408080; font-style: italic">// Getting the Gaussian quadrature weights and integration points</span>
<span style="color: #B00040">void</span> <span style="color: #0000FF">GaussHermiteQuadrature</span>(<span style="color: #B00040">double</span> <span style="color: #666666">*</span>, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>, <span style="color: #B00040">int</span>);
<span style="color: #408080; font-style: italic">// Start main program</span>
<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span> (<span style="color: #B00040">int</span> argc, <span style="color: #B00040">char</span><span style="color: #666666">*</span> argv[])
{
  <span style="color: #408080; font-style: italic">// read from terminal the number of integration points</span>
  <span style="color: #B00040">int</span> n <span style="color: #666666">=</span> atoi(argv[<span style="color: #666666">1</span>]);
  <span style="color: #B00040">int</span> thread_num;

  <span style="color: #B00040">double</span> wtime;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;  Compute 4d-integral using Gaussian quadrature with Hermite quadrature.&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  omp_set_num_threads(<span style="color: #666666">4</span>);
  thread_num <span style="color: #666666">=</span> omp_get_max_threads ();
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;  The number of processors available = &quot;</span> <span style="color: #666666">&lt;&lt;</span> omp_get_num_procs () <span style="color: #666666">&lt;&lt;</span> endl ;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;  The number of threads available    = &quot;</span> <span style="color: #666666">&lt;&lt;</span> thread_num <span style="color: #666666">&lt;&lt;</span>  endl;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;  The number of integration points                 = &quot;</span> <span style="color: #666666">&lt;&lt;</span> n <span style="color: #666666">&lt;&lt;</span> endl;
  wtime <span style="color: #666666">=</span> omp_get_wtime ( );
  <span style="color: #B00040">double</span> Integral <span style="color: #666666">=</span> GaussHermiteIntegration(n);
  wtime <span style="color: #666666">=</span> omp_get_wtime ( ) <span style="color: #666666">-</span> wtime;
  cout <span style="color: #666666">&lt;&lt;</span> setiosflags(ios<span style="color: #666666">::</span>showpoint <span style="color: #666666">|</span> ios<span style="color: #666666">::</span>uppercase);
  cout <span style="color: #666666">&lt;&lt;</span> setprecision(<span style="color: #666666">15</span>) <span style="color: #666666">&lt;&lt;</span> setw(<span style="color: #666666">20</span>) <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Time used  integration=&quot;</span> <span style="color: #666666">&lt;&lt;</span> wtime  <span style="color: #666666">&lt;&lt;</span> endl;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Final Integral    = &quot;</span> <span style="color: #666666">&lt;&lt;</span> Integral <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
} <span style="color: #408080; font-style: italic">// end main function</span>

<span style="color: #408080; font-style: italic">// The integrand, here a first order Hermite polynomial for x1 only</span>
<span style="color: #408080; font-style: italic">// The other variables are given by zeroth-order Hermite polynomials.</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">Integrand</span>(<span style="color: #B00040">double</span> x1, <span style="color: #B00040">double</span> y1, <span style="color: #B00040">double</span> x2, <span style="color: #B00040">double</span> y2)
{
  <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">2*</span>x1)<span style="color: #666666">*</span>(<span style="color: #666666">2*</span>x1);
}

<span style="color: #408080; font-style: italic">//Plain Gauss-Hermite integration with cartesian variables, brute force</span>
<span style="color: #B00040">double</span>  <span style="color: #0000FF">GaussHermiteIntegration</span>(<span style="color: #B00040">int</span> n)
{
  <span style="color: #B00040">double</span> <span style="color: #666666">*</span>x <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n<span style="color: #666666">+1</span>];
  <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n];
  GaussHermiteQuadrature(x, w, n);
  <span style="color: #B00040">double</span> Integral <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  <span style="color: #B00040">int</span> i, j, k, l;
<span style="color: #BC7A00"># pragma omp parallel default(shared) private (i, j, k, l) reduction(+:Integral)</span>
  {
<span style="color: #BC7A00"># pragma omp for</span>
    <span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
      <span style="color: #008000; font-weight: bold">for</span> (j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>){
	<span style="color: #008000; font-weight: bold">for</span> (k <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  k <span style="color: #666666">&lt;</span> n; k<span style="color: #666666">++</span>){
	  <span style="color: #008000; font-weight: bold">for</span> (l <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  l <span style="color: #666666">&lt;</span> n; l<span style="color: #666666">++</span>){
	    Integral <span style="color: #666666">+=</span> w[i]<span style="color: #666666">*</span>w[j]<span style="color: #666666">*</span>w[k]<span style="color: #666666">*</span>w[l]<span style="color: #666666">*</span>Integrand(x[i],x[j],x[k],x[l]);
	  }
	}
      }
    }
  } <span style="color: #408080; font-style: italic">// end parallel region</span>
  <span style="color: #008000; font-weight: bold">delete</span> [] x;
  <span style="color: #008000; font-weight: bold">delete</span> [] w;
  <span style="color: #008000; font-weight: bold">return</span> Integral;
}


<span style="color: #408080; font-style: italic">// Setting Gaussian quadrature weights and integration points</span>
<span style="color: #B00040">void</span> <span style="color: #0000FF">GaussHermiteQuadrature</span>(<span style="color: #B00040">double</span> <span style="color: #666666">*</span>x, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w, <span style="color: #B00040">int</span> n)
{
  <span style="color: #B00040">int</span> i,its,j,m;
  <span style="color: #B00040">double</span> p1,p2,p3,pp,z,z1;
  <span style="color: #B00040">double</span> Epsilon <span style="color: #666666">=</span> <span style="color: #666666">3.0e-14</span>, PIM4 <span style="color: #666666">=</span> <span style="color: #666666">0.7511255444649425</span>;
  <span style="color: #B00040">int</span> MaxIterations <span style="color: #666666">=</span> <span style="color: #666666">10</span>;
  m<span style="color: #666666">=</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
  <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=1</span>;i<span style="color: #666666">&lt;=</span>m;i<span style="color: #666666">++</span>) {
    <span style="color: #008000; font-weight: bold">if</span> (i <span style="color: #666666">==</span> <span style="color: #666666">1</span>) {
      z<span style="color: #666666">=</span>sqrt((<span style="color: #B00040">double</span>)(<span style="color: #666666">2*</span>n<span style="color: #666666">+1</span>))<span style="color: #666666">-1.85575*</span>pow((<span style="color: #B00040">double</span>)(<span style="color: #666666">2*</span>n<span style="color: #666666">+1</span>),<span style="color: #666666">-0.16667</span>);
    } <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">if</span> (i <span style="color: #666666">==</span> <span style="color: #666666">2</span>) {
      z <span style="color: #666666">-=</span> <span style="color: #666666">1.14*</span>pow((<span style="color: #B00040">double</span>)n,<span style="color: #666666">0.426</span>)<span style="color: #666666">/</span>z;
    } <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">if</span> (i <span style="color: #666666">==</span> <span style="color: #666666">3</span>) {
      z<span style="color: #666666">=1.86*</span>z<span style="color: #666666">-0.86*</span>x[<span style="color: #666666">0</span>];
    } <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">if</span> (i <span style="color: #666666">==</span> <span style="color: #666666">4</span>) {
      z<span style="color: #666666">=1.91*</span>z<span style="color: #666666">-0.91*</span>x[<span style="color: #666666">1</span>];
    } <span style="color: #008000; font-weight: bold">else</span> {
      z<span style="color: #666666">=2.0*</span>z<span style="color: #666666">-</span>x[i<span style="color: #666666">-3</span>];
    }
    <span style="color: #008000; font-weight: bold">for</span> (its<span style="color: #666666">=1</span>;its<span style="color: #666666">&lt;=</span>MaxIterations;its<span style="color: #666666">++</span>) {
      p1<span style="color: #666666">=</span>PIM4;
      p2<span style="color: #666666">=0.0</span>;
      <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=1</span>;j<span style="color: #666666">&lt;=</span>n;j<span style="color: #666666">++</span>) {
	p3<span style="color: #666666">=</span>p2;
	p2<span style="color: #666666">=</span>p1;
	p1<span style="color: #666666">=</span>z<span style="color: #666666">*</span>sqrt(<span style="color: #666666">2.0/</span>j)<span style="color: #666666">*</span>p2<span style="color: #666666">-</span>sqrt(((<span style="color: #B00040">double</span>)(j<span style="color: #666666">-1</span>))<span style="color: #666666">/</span>j)<span style="color: #666666">*</span>p3;
      }
      pp<span style="color: #666666">=</span>sqrt((<span style="color: #B00040">double</span>)<span style="color: #666666">2*</span>n)<span style="color: #666666">*</span>p2;
      z1<span style="color: #666666">=</span>z;
      z<span style="color: #666666">=</span>z1<span style="color: #666666">-</span>p1<span style="color: #666666">/</span>pp;
      <span style="color: #008000; font-weight: bold">if</span> (fabs(z<span style="color: #666666">-</span>z1) <span style="color: #666666">&lt;=</span> Epsilon) <span style="color: #008000; font-weight: bold">break</span>;
    }
    <span style="color: #008000; font-weight: bold">if</span> (its <span style="color: #666666">&gt;</span> MaxIterations) cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;too many iterations in Hermite quadrature&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
    x[i<span style="color: #666666">-1</span>]<span style="color: #666666">=</span>z;
    x[n<span style="color: #666666">-</span>i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>z;
    w[i<span style="color: #666666">-1</span>]<span style="color: #666666">=2.0/</span>(pp<span style="color: #666666">*</span>pp);
    w[n<span style="color: #666666">-</span>i]<span style="color: #666666">=</span>w[i<span style="color: #666666">-1</span>];
  }
} <span style="color: #408080; font-style: italic">// Gaussian quadrature weights and integration points</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec46">Gaussian Quadrature, main idea </h2>

<p>
In general, an integration formula which is based on a Taylor series using \( N \) points,
will integrate exactly a polynomial \( P \) of degree \( N-1 \). That is, the \( N \) weights
\( \omega_n \) can be chosen to satisfy \( N \) linear equations, see chapter 3 of Ref.\ [3]. 
A greater precision for a given amount of numerical work can  be achieved
if we are willing to give up the requirement of equally spaced integration points.  
In Gaussian quadrature (hereafter GQ), both the mesh points and the weights are to
be determined. The points will not be equally spaced.

<p>
The theory behind GQ is to obtain an arbitrary weight \( \omega \) through the use of
so-called orthogonal polynomials. These polynomials are orthogonal in some
interval say e.g., [-1,1]. Our points \( x_i \) are chosen in some optimal sense subject
only to the constraint that they should lie in this interval. Together with the weights
we have then \( 2N \) (\( N \) the number of points) parameters at our disposal.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Gaussian Quadrature </h2>

<p>
Even though the integrand is not smooth, we could render it smooth by extracting
from it the weight function of an orthogonal polynomial, i.e.,
we are rewriting
$$
\begin{equation}
   I= \int_a^b f(x)dx =\int_a^b W(x)g(x)dx \approx \sum_{i=1}^N\omega_ig(x_i),  
\label{eq:generalint}
\end{equation}
$$

where \( g \) is smooth and \( W \) is the weight function, which is to  be associated with a given 
orthogonal polynomial. Note that with a given weight function we end up evaluating the integrand
for the function \( g(x_i) \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Gaussian Quadrature, weight function </h2>

<p>
The weight function \( W \) is non-negative in the integration interval 
\( x\in [a,b] \) such that
for any \( n \ge 0 \), the integral \( \int_a^b |x|^n W(x) dx \) is integrable. The naming
weight function arises from the fact that it may be used to give more emphasis
to one part of the interval than another. 
A quadrature formula 
$$
\begin{equation} 
   \int_a^b W(x)f(x)dx \approx \sum_{i=1}^N\omega_if(x_i), 
\label{_auto2}
\end{equation} 
$$

with \( N \) distinct quadrature points (mesh points) is a called a Gaussian quadrature 
formula if it integrates all polynomials \( p\in P_{2N-1} \) exactly, that is
$$
\begin{equation} 
\int_a^bW(x)p(x)dx =\sum_{i=1}^N\omega_ip(x_i), 
\label{_auto3}
\end{equation}
$$

It is assumed that \( W(x) \) is continuous and positive and that the integral
$$
\begin{equation*} 
\int_a^bW(x)dx
\end{equation*}
$$

exists. Note that the replacement of \( f\rightarrow Wg \) is normally a better approximation
due to the fact that we may isolate possible singularities of \( W \) and its 
derivatives at the endpoints of the interval.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec49">Gaussian Quadrature weights and integration points </h2>

<p>
The quadrature weights or just weights (not to be confused with the weight function) 
are positive and the sequence of Gaussian quadrature formulae is convergent 
if the sequence \( Q_N \) of quadrature formulae
$$
\begin{equation*}
   Q_N(f)\rightarrow Q(f)=\int_a^bf(x)dx,
\end{equation*}
$$

in the limit \( N\rightarrow \infty \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec50">Gaussian Quadrature </h2>

<p>
Then  we say that the sequence
$$
\begin{equation*} 
Q_N(f) = \sum_{i=1}^N\omega_i^{(N)}f(x_i^{(N)}), 
\end{equation*}
$$

is convergent for all polynomials \( p \), that is
$$
\begin{equation*}
Q_N(p) = Q(p) 
\end{equation*}
$$

if there exits a constant \( C \) such that
$$
\begin{equation*}
 \sum_{i=1}^N|\omega_i^{(N)}| \le C,
\end{equation*}
$$

for all \( N \) which are natural numbers.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec51">Error in Gaussian Quadrature </h2>

<p>
The error for the Gaussian quadrature formulae of order \( N \) is given
by

$$
\begin{equation*}
  \int_a^bW(x)f(x)dx-\sum_{k=1}^Nw_kf(x_k)=\frac{f^{2N}(\xi)}{(2N)!}\int_a^bW(x)[q_{N}(x)]^2dx
\end{equation*}
$$

where \( q_{N} \) is the chosen orthogonal polynomial and \( \xi \) is a number in the interval \( [a,b] \).
We have assumed that \( f\in C^{2N}[a,b] \), viz. the space of all real or complex  \( 2N \) times continuously
differentiable functions.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec52">Important polynomials in Gaussian Quadrature </h2>

<p>
In science there are several important orthogonal polynomials which arise
from the solution of differential equations. Well-known examples are the  
Legendre, Hermite, Laguerre and Chebyshev polynomials. They have the following weight functions

<p>
<table border="1">
<thead>
<tr><th align="center">      Weight function      </th> <th align="center">           Interval           </th> <th align="center">Polynomial</th> </tr>
</thead>
<tbody>
<tr><td align="right">   \( W(x)=1 \)                   </td> <td align="right">   \( x\in [-1,1] \)                 </td> <td align="right">   Legendre      </td> </tr>
<tr><td align="right">   \( W(x)=e^{-x^2} \)            </td> <td align="right">   \( -\infty \le x \le \infty \)    </td> <td align="right">   Hermite       </td> </tr>
<tr><td align="right">   \( W(x)=x^{\alpha}e^{-x} \)    </td> <td align="right">   \( 0 \le x \le \infty \)          </td> <td align="right">   Laguerre      </td> </tr>
<tr><td align="right">   \( W(x)=1/(\sqrt{1-x^2}) \)    </td> <td align="right">   \( -1 \le x \le 1 \)              </td> <td align="right">   Chebyshev     </td> </tr>
</tbody>
</table>
<p>
The importance of the use of orthogonal polynomials in the evaluation
of integrals can be summarized as follows.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec53">Gaussian Quadrature, win-win situation </h2>

<p>
Methods based on Taylor series using \( N \) points will  integrate exactly a polynomial \( P \) of degree \( N-1 \). If a function \( f(x) \) can be approximated with a polynomial of degree \( N-1 \)          
$$
\begin{equation*}            
f(x)\approx P_{N-1}(x),
\end{equation*}
$$

with \( N \) mesh points we should be able to integrate exactly the polynomial \( P_{N-1} \).

<p>
Gaussian quadrature methods promise more than this. We can get a better          polynomial approximation with order greater than \( N \)  to \( f(x) \) and still          get away with only \( N \) mesh points. More precisely, we approximate           
$$
\begin{equation*}             
f(x) \approx P_{2N-1}(x),
\end{equation*}
$$

and with only \( N \) mesh points these methods promise that
$$
\begin{equation*}
            \int f(x)dx \approx \int P_{2N-1}(x)dx=\sum_{i=0}^{N-1} P_{2N-1}(x_i)\omega_i,
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Gaussian Quadrature, determining mesh points and weights </h2>

<p>
The reason why we can represent a function \( f(x) \) with a polynomial of degree
\( 2N-1 \) is due to the fact that we have \( 2N \) equations, \( N \) for the mesh points and \( N \)
for the weights.

<p>
<em>The mesh points are the zeros  of the chosen  orthogonal polynomial</em> of
order \( N \), and the weights are determined from the inverse of a matrix.
An orthogonal polynomials of degree \( N \) defined in an interval \( [a,b] \)
has precisely \( N \) distinct zeros on the open interval \( (a,b) \).

<p>
Before we detail how to obtain mesh points and weights with orthogonal 
polynomials, let us revisit some features of orthogonal polynomials
by specializing to Legendre polynomials. In the text below, we reserve 
hereafter the labelling
\( L_N \) for a Legendre polynomial of order \( N \), while \( P_N \) is an arbitrary polynomial
of order \( N \). 
These polynomials form then the basis for the Gauss-Legendre method.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec55">Orthogonal polynomials, Legendre </h2>

<p>
The Legendre polynomials are the solutions of an important
differential equation in Science, namely

$$
\begin{equation*}
C(1-x^2)P-m_l^2P+(1-x^2)\frac{d}{dx}\left((1-x^2)\frac{dP}{dx}\right)=0.
\end{equation*}
$$

Here \( C \) is a constant. For \( m_l=0 \) we obtain the Legendre polynomials
as solutions, whereas \( m_l \ne 0 \) yields the so-called associated Legendre
polynomials. This differential equation arises in for example the solution
of the angular dependence of Schroedinger's 
equation with spherically symmetric potentials such as
the Coulomb potential.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec56">Orthogonal polynomials, Legendre </h2>
The corresponding polynomials \( P \) are
$$
\begin{equation*}
   L_k(x)=\frac{1}{2^kk!}\frac{d^k}{dx^k}(x^2-1)^k \hspace{1cm} k=0,1,2,\dots,
\end{equation*}
$$

which, up to a factor, are the Legendre polynomials \( L_k \). 
The latter fulfil the orthogonality relation
$$
\begin{equation} 
  \int_{-1}^1L_i(x)L_j(x)dx=\frac{2}{2i+1}\delta_{ij},
\label{eq:ortholeg}
\end{equation} 
$$

and the recursion relation
$$
\begin{equation} 
  (j+1)L_{j+1}(x)+jL_{j-1}(x)-(2j+1)xL_j(x)=0.
\label{eq:legrecur}
\end{equation} 
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec57">Orthogonal polynomials, Legendre </h2>
It is common to choose the normalization condition
$$
\begin{equation*}
    L_N(1)=1.
\end{equation*}
$$

With these equations we can determine a Legendre polynomial of arbitrary order
with input polynomials of order \( N-1 \) and \( N-2 \).

<p>
As an example, consider the determination of \( L_0 \), \( L_1 \) and \( L_2 \). 
We have that
$$
\begin{equation*}
   L_0(x) = c,
\end{equation*}
$$

with \( c \) a constant. Using the normalization equation \( L_0(1)=1 \)
we get that

$$
\begin{equation*}
   L_0(x) = 1.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Orthogonal polynomials, Legendre </h2>
For \( L_1(x) \) we have the general expression
$$
\begin{equation*}
   L_1(x) = a+bx,
\end{equation*}
$$

and using the orthogonality relation
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_1(x)dx=0,
\end{equation*}
$$

we obtain \( a=0 \) and with the condition \( L_1(1)=1 \), we obtain \( b=1 \), yielding
$$
\begin{equation*}
   L_1(x) = x.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec59">Orthogonal polynomials, Legendre </h2>
We can proceed in a similar fashion in order to determine
the coefficients of \( L_2 \)
$$
\begin{equation*}
   L_2(x) = a+bx+cx^2,
\end{equation*}
$$

using the orthogonality relations
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_2(x)dx=0,
\end{equation*}
$$

and
$$
\begin{equation*}
  \int_{-1}^1L_1(x)L_2(x)dx=0,
\end{equation*}
$$

and the condition
\( L_2(1)=1 \) we would get 
$$
\begin{equation}
   L_2(x) = \frac{1}{2}\left(3x^2-1\right).
\label{eq:l2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec60">Orthogonal polynomials, Legendre </h2>
We note that we have three equations to determine the three coefficients
\( a \), \( b \) and \( c \).

<p>
Alternatively, we could have 
employed the recursion relation of Eq. \eqref{eq:legrecur}, resulting in

$$
\begin{equation*}
   2L_2(x)=3xL_1(x)-L_0,
\end{equation*}
$$

which leads to Eq. \eqref{eq:l2}.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec61">Orthogonal polynomials, Legendre </h2>
The orthogonality relation above is important in our discussion
on how to obtain the weights and mesh points. Suppose we have an arbitrary
polynomial \( Q_{N-1} \) of order \( N-1 \) and a Legendre polynomial \( L_N(x) \) of
order \( N \). We could represent \( Q_{N-1} \) 
by the Legendre polynomials through 
$$
\begin{equation}
   Q_{N-1}(x)=\sum_{k=0}^{N-1}\alpha_kL_{k}(x),
\label{eq:legexpansion}
\end{equation}
$$

where \( \alpha_k \)'s are constants.

<p>
Using the orthogonality relation of Eq. \eqref{eq:ortholeg} we see that
$$
\begin{equation}
  \int_{-1}^1L_N(x)Q_{N-1}(x)dx=\sum_{k=0}^{N-1} \int_{-1}^1L_N(x) \alpha_kL_{k}(x)dx=0.
\label{eq:ortholeg2}
\end{equation}
$$

We will use this result in our construction of mesh points and weights 
in the next subsection.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec62">Orthogonal polynomials, Legendre </h2>
In summary, the first few Legendre polynomials are
$$
\begin{equation*}
   L_0(x) =1,
\end{equation*}
$$

$$
\begin{equation*}
  L_1(x) = x,
\end{equation*}
$$

$$
\begin{equation*}
  L_2(x) = (3x^2-1)/2,
\end{equation*}
$$

$$
\begin{equation*}
   L_3(x) = (5x^3-3x)/2,
\end{equation*}
$$

and
$$
\begin{equation*}
   L_4(x) = (35x^4-30x^2+3)/8.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec63">Orthogonal polynomials, simple code for Legendre polynomials </h2>
The following simple function implements the above recursion relation
of Eq. \eqref{eq:legrecur}.
for computing Legendre polynomials of order \( N \).
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">//  This function computes the Legendre polynomial of degree N</span>

<span style="color: #B00040">double</span> <span style="color: #0000FF">Legendre</span>( <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> x) 
{
       <span style="color: #B00040">double</span> r, s, t;
       <span style="color: #B00040">int</span> m;
       r <span style="color: #666666">=</span> <span style="color: #666666">0</span>; s <span style="color: #666666">=</span> <span style="color: #666666">1.</span>;
       <span style="color: #408080; font-style: italic">//  Use recursion relation to generate p1 and p2</span>
       <span style="color: #008000; font-weight: bold">for</span> (m<span style="color: #666666">=0</span>; m <span style="color: #666666">&lt;</span> n; m<span style="color: #666666">++</span> )  
       {
          t <span style="color: #666666">=</span> r; r <span style="color: #666666">=</span> s; 
          s <span style="color: #666666">=</span> (<span style="color: #666666">2*</span>m<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x<span style="color: #666666">*</span>r <span style="color: #666666">-</span> m<span style="color: #666666">*</span>t;
          s <span style="color: #666666">/=</span> (m<span style="color: #666666">+1</span>);
	} <span style="color: #408080; font-style: italic">// end of do loop </span>
        <span style="color: #008000; font-weight: bold">return</span> s;
}   <span style="color: #408080; font-style: italic">// end of function Legendre</span>
</pre></div>
<p>
The variable \( s \) represents \( L_{j+1}(x) \), while \( r \) holds
\( L_j(x) \) and \( t \) the value \( L_{j-1}(x) \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec64">Other orthogonal polynomials, Laguerre polynomials </h2>

<p>
If we are able to rewrite our integral of Eq.  \eqref{eq:generalint} with a
weight function \( W(x)=x^{\alpha}e^{-x} \) with integration limits 
\( [0,\infty) \), we could then use the Laguerre polynomials.
The polynomials form then the basis for the Gauss-Laguerre method which can be applied
to integrals of the form

$$
\begin{equation*} 
   I=\int_0^{\infty}f(x)dx =\int_0^{\infty}x^{\alpha}e^{-x}g(x)dx.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec65">Other orthogonal polynomials, Laguerre polynomials </h2>
These polynomials arise from the solution of the differential
equation

$$
\begin{equation*}
\left(\frac{d^2 }{dx^2}-\frac{d }{dx}+\frac{\lambda}{x}-\frac{l(l+1)}{x^2}\right){\cal L}(x)=0,
\end{equation*}
$$

where \( l \) is an integer \( l\ge 0 \) and \( \lambda \) a constant. This equation
arises for example from the solution of the radial Schr\"odinger equation with 
a centrally symmetric potential such as the Coulomb potential.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec66">Other orthogonal polynomials, Laguerre polynomials </h2>
The first few polynomials are
$$
\begin{equation*}
   {\cal L}_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_1(x)=1-x,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_2(x)=2-4x+x^2,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_3(x)=6-18x+9x^2-x^3,
\end{equation*}
$$

and
$$
\begin{equation*}
    {\cal L}_4(x)=x^4-16x^3+72x^2-96x+24.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec67">Other orthogonal polynomials, Laguerre polynomials </h2>
They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{0}^{\infty}e^{-x}{\cal L}_n(x)^2dx=1,
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  (n+1){\cal L}_{n+1}(x)=(2n+1-x){\cal L}_{n}(x)-n{\cal L}_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec68">Other orthogonal polynomials, Hermite polynomials </h2>

<p>
In a similar way, for an integral which goes like
$$
\begin{equation*} 
   I=\int_{-\infty}^{\infty}f(x)dx =\int_{-\infty}^{\infty}e^{-x^2}g(x)dx.
\end{equation*}
$$

we could use the Hermite polynomials in order to extract weights and mesh points.
The Hermite polynomials are the solutions of the following differential
equation

$$
\begin{equation}
   \frac{d^2H(x)}{dx^2}-2x\frac{dH(x)}{dx}+
       (\lambda-1)H(x)=0.
\label{eq:hermite}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec69">Other orthogonal polynomials, Hermite polynomials </h2>
A typical example is again the solution of Schrodinger's
equation, but this time with a harmonic oscillator potential.
The first few polynomials are
$$
\begin{equation*}
   H_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    H_1(x)=2x,
\end{equation*}
$$

$$
\begin{equation*}
    H_2(x)=4x^2-2,
\end{equation*}
$$

$$
\begin{equation*}
    H_3(x)=8x^3-12,
\end{equation*}
$$

and
$$
\begin{equation*}
    H_4(x)=16x^4-48x^2+12.
\end{equation*}
$$

They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{-\infty}^{\infty}e^{-x^2}H_n(x)^2dx=2^nn!\sqrt{\pi},
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  H_{n+1}(x)=2xH_{n}(x)-2nH_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec70">Integration points and weights with orthogonal polynomials </h2>

<p>
To understand how the weights and the mesh points are generated, we define first
a polynomial of degree \( 2N-1 \) (since we have \( 2N \) variables at hand, the mesh points
and weights for \( N \) points). This polynomial can be represented through polynomial
division by

$$
\begin{equation*}
   P_{2N-1}(x)=L_N(x)P_{N-1}(x)+Q_{N-1}(x),
\end{equation*}
$$

where \( P_{N-1}(x) \) and \( Q_{N-1}(x) \) are some polynomials of degree \( N-1 \) or less.
The function \( L_N(x) \) is a Legendre polynomial of order \( N \).

<p>
Recall that we wanted to approximate  an arbitrary function \( f(x) \) with a
polynomial \( P_{2N-1} \) in order to evaluate

$$
\begin{equation*}
   \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec71">Integration points and weights with orthogonal polynomials </h2>
We can use Eq. \eqref{eq:ortholeg2}
to rewrite the above integral as
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1(L_N(x)P_{N-1}(x)+Q_{N-1}(x))dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

due to the orthogonality properties of the Legendre polynomials. We see that it suffices
to evaluate the integral over \( \int_{-1}^1Q_{N-1}(x)dx \) in order to evaluate 
\( \int_{-1}^1P_{2N-1}(x)dx \). In addition, at the points \( x_k \) where \( L_N \) is zero, we have

$$
\begin{equation*}
    P_{2N-1}(x_k)=Q_{N-1}(x_k)\hspace{1cm} k=0,1,\dots, N-1,
\end{equation*}
$$

and we see that through these \( N \) points we can fully define \( Q_{N-1}(x) \)  and thereby the 
integral. Note that we have chosen to let the numbering of the points run from \( 0 \) to \( N-1 \).
The reason for this choice is that we wish to have the same numbering as the order of a 
polynomial of degree \( N-1 \).  This numbering will be useful below when  we introduce the matrix
elements  which define the integration weights \( w_i \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec72">Integration points and weights with orthogonal polynomials </h2>
We develope then \( Q_{N-1}(x) \) in terms of Legendre polynomials,
as done in Eq. \eqref{eq:legexpansion}, 
$$
\begin{equation} 
  Q_{N-1}(x)=\sum_{i=0}^{N-1}\alpha_iL_i(x).
\label{eq:lsum1}
\end{equation}
$$

Using the orthogonality property of the Legendre polynomials we have
$$
\begin{equation*} 
  \int_{-1}^1Q_{N-1}(x)dx=\sum_{i=0}^{N-1}\alpha_i\int_{-1}^1L_0(x)L_i(x)dx=2\alpha_0,
\end{equation*}
$$

where we have just inserted \( L_0(x)=1 \)!

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec73">Integration points and weights with orthogonal polynomials </h2>
Instead of an integration problem we need now to define the coefficient \( \alpha_0 \).
Since we know the values of \( Q_{N-1} \) at the zeros of \( L_N \), we may rewrite  
Eq.  \eqref{eq:lsum1} as
$$
\begin{equation} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k)=\sum_{i=0}^{N-1}\alpha_iL_{ik} \hspace{1cm} k=0,1,\dots, N-1.
\label{eq:lsum2}
\end{equation}
$$

Since the Legendre polynomials are linearly independent of each other, none 
of the columns in the matrix \( L_{ik} \) are linear combinations of the others.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec74">Integration points and weights with orthogonal polynomials </h2>
This means that the matrix \( L_{ik} \) has an inverse with the properties
$$
\begin{equation*}
   \hat{L}^{-1}\hat{L} = \hat{I}.
\end{equation*}
$$

Multiplying both sides of Eq. \eqref{eq:lsum2} with \( \sum_{j=0}^{N-1}L_{ji}^{-1} \) results in 
$$
\begin{equation}
  \sum_{i=0}^{N-1}(L^{-1})_{ki}Q_{N-1}(x_i)=\alpha_k.
\label{eq:lsum3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec75">Integration points and weights with orthogonal polynomials </h2>
We can derive this result in an alternative way by defining the vectors
$$
\begin{equation*}
\hat{x}_k=\left(\begin{array} {c} x_0\\
                                x_1\\
                                .\\
                                .\\
                                x_{N-1}\end{array}\right) \hspace{0.5cm}
\hat{\alpha}=\left(\begin{array} {c} \alpha_0\\
                                \alpha_1\\
                                .\\
                                .\\
                                \alpha_{N-1}\end{array}\right),
\end{equation*}
$$

and the matrix
$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cccc} L_0(x_0)  & L_1(x_0) &\dots &L_{N-1}(x_0)\\
                                   L_0(x_1)  & L_1(x_1) &\dots &L_{N-1}(x_1)\\
                                   \dots  & \dots &\dots &\dots\\
L_0(x_{N-1})  & L_1(x_{N-1}) &\dots &L_{N-1}(x_{N-1})
\end{array}\right).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec76">Integration points and weights with orthogonal polynomials </h2>
We have then
$$
\begin{equation*}
Q_{N-1}(\hat{x}_k) = \hat{L}\hat{\alpha},
\end{equation*}
$$

yielding (if \( \hat{L} \) has an inverse)
$$
\begin{equation*}
\hat{L}^{-1}Q_{N-1}(\hat{x}_k) = \hat{\alpha},
\end{equation*}
$$

which is Eq. \eqref{eq:lsum3}.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec77">Integration points and weights with orthogonal polynomials </h2>
Using the above results and the fact that
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

we get
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx=2\alpha_0=
   2\sum_{i=0}^{N-1}(L^{-1})_{0i}P_{2N-1}(x_i).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec78">Integration points and weights with orthogonal polynomials </h2>
If we identify the weights with \( 2(L^{-1})_{0i} \), where the points \( x_i \) are
the zeros of \( L_N \), we have an integration formula of the type
$$
\begin{equation*}
   \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  
\end{equation*}
$$

and if our function \( f(x) \)  can be approximated by a polynomial \( P \) of degree
\( 2N-1 \), we have finally that
$$
\begin{equation*}
    \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  .
\end{equation*}
$$

In summary, the mesh points \( x_i \) are defined by the zeros of an orthogonal polynomial of degree \( N \), that is 
\( L_N \), while the weights are
given by \( 2(L^{-1})_{0i} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec79">Application to the case \( N=2 \) </h2>

<p>
Let us apply the above formal results to the case \( N=2 \). 
This means that we can approximate a function \( f(x) \) with a
polynomial \( P_3(x) \) of order \( 2N-1=3 \).

<p>
The mesh points are the zeros of \( L_2(x)=1/2(3x^2-1) \). 
These points are \( x_0=-1/\sqrt{3} \) and \( x_1=1/\sqrt{3} \).

<p>
Specializing Eq. \eqref{eq:lsum2}

$$
\begin{equation*} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k) \hspace{1cm} k=0,1,\dots, N-1.
\end{equation*}
$$

to \( N=2 \) yields

$$
\begin{equation*}
   Q_1(x_0)=\alpha_0-\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

and

$$
\begin{equation*}
   Q_1(x_1)=\alpha_0+\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

since \( L_0(x=\pm 1/\sqrt{3})=1 \) and \( L_1(x=\pm 1/\sqrt{3})=\pm 1/\sqrt{3} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec80">Application to the case \( N=2 \) </h2>
The matrix \( L_{ik} \) defined in Eq. \eqref{eq:lsum2} is then

$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cc} 1  & -\frac{1}{\sqrt{3}}\\
                                   1  & \frac{1}{\sqrt{3}}\end{array}\right),
\end{equation*}
$$

with an inverse given by

$$
\begin{equation*}
   \hat{L}^{-1}=\frac{\sqrt{3}}{2}\left(\begin{array} {cc} \frac{1}{\sqrt{3}}  & \frac{1}{\sqrt{3}}\\
                                   -1  & 1\end{array}\right).
\end{equation*}
$$

The weights are given by the matrix elements \( 2(L_{0k})^{-1} \). We have thence
\( \omega_0=1 \) and \( \omega_1=1 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec81">Application to the case \( N=2 \) </h2>
Obviously, there is no problem in changing the numbering of the matrix elements \( i,k=0,1,2,\dots,N-1 \) to
\( i,k=1,2,\dots,N \).  We have chosen to start from zero, since we deal with polynomials of degree \( N-1 \).

<p>
Summarizing, for Legendre polynomials with \( N=2 \) we have
weights
$$
\begin{equation*}
   \omega : \left\{1,1\right\},
\end{equation*}
$$

and mesh points

$$
\begin{equation*}
   x : \left\{-\frac{1}{\sqrt{3}},\frac{1}{\sqrt{3}}\right\}.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec82">Application to the case \( N=2 \) </h2>
If we wish to integrate
$$
\begin{equation*}
   \int_{-1}^1f(x)dx,
\end{equation*}
$$

with \( f(x)=x^2 \), we approximate
$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx \approx \sum_{i=0}^{N-1}\omega_ix_i^2.  
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec83">Application to the case \( N=2 \) </h2>
The exact answer is \( 2/3 \). Using \( N=2 \) with the above two weights 
and mesh points we get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\sum_{i=0}^{1}\omega_ix_i^2=\frac{1}{3}+\frac{1}{3}=\frac{2}{3},  
\end{equation*}
$$

the exact answer!

<p>
If we were to emply the trapezoidal rule we would get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\frac{b-a}{2}\left((a)^2+(b)^2\right)/2=
                       \frac{1-(-1)}{2}\left((-1)^2+(1)^2\right)/2=1!
\end{equation*}
$$

With just two points we can calculate exactly the integral for a second-order
polynomial since our methods approximates the exact function with higher
order polynomial. 
How many points do you need with the trapezoidal rule in order to achieve a
similar accuracy?

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec84">Back to Hermite polynomials and our type of integrals  </h2>

<p>
Our type of integrals will involve expressions on the form (in one dimension as an example)
$$
I = \int_{-\infty}^{\infty}\exp{(-x^2/2)}f(x)dx.
$$

When we use Gauss-Hermite quadrature, the exponential function is absorbed into the weight points. We need however to keep in mind that the basic form is given by
$$
I = \int_{-\infty}^{\infty}\exp{(-x^2)}g(x)dx\approx \sum_{i=1}^nw_ig(x_i).
$$

This means that we need to make a change of variables \( u^2=x^2/2 \) in the first equation so that we end up with 
$$
I = \int_{-\infty}^{\infty}\exp{(-x^2/2)}f(x)dx=\sqrt{2}\int_{-\infty}^{\infty}\exp{(-u^2)}f(\sqrt{2}u)du\approx \sqrt{2}\sum_{i=1}^nw_if(\sqrt{2}u_i).
$$

For Gauss-Hermite quadrature, the weights have a simple analytic expression in terms of Hermite polynomials
$$
w_i = \frac{2^{n1}n!\sqrt{\pi}}{n^2[H_{n-1}(x_i)]^2}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec85">Our integrals  </h2>

<p>
We will need to deal with following type of four dimensional integrals
$$
\langle pq \vert \hat{v} \vert rs \rangle = A\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} \exp{[-(x_1^2+x_2^2+y_1^2+y_2^2)/2]}f(x_1,y_1,x_2,y_2)dx_1dy_1dx_2dy_2,
$$

where \( A \) is a normalization constant and 
$$
f(x_1,y_1,x_2,y_2) = H_{n_{x_p}}(x_1)H_{n_{y_p}}(y_1)H_{n_{x_q}}(x_2)H_{n_{y_r}}(y_2)H_{n_{x_r}}(x_1)H_{n_{y_r}}(y_1)H_{n_{x_s}}(x_2)H_{n_{y_s}}(y_2)\frac{1}{\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}},
$$

where \( H_n \) are the various Hermite polynomials. 
For the case where all \( n_{x,y}=0 \) the above integral simplifies to
$$
\langle pq \vert \hat{v} \vert rs \rangle = A\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} \frac{\exp{[-(x_1^2+x_2^2+y_1^2+y_2^2)/2]} }{\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}}dx_1dy_1dx_2dy_2.
$$

Changing from the laboratory frame to the relative and center of mass frame, with 
$$
\boldsymbol{R} = \frac{\bf{r}_1+\boldsymbol{r}_2}{2} \hspace{1cm} \boldsymbol{r} = \bf{r}_1-\boldsymbol{r}_2 
$$

and introducing polar coordinates the above integral can be written as 
$$
I = 4\pi^2 A\int_{0}^{\infty}\exp{(-R^2)}RdR \int_{0}^{\infty} \exp{(-r^2)}rdr\frac{1}{r}=2A\pi^{5/2}. 
$$

This provides a useful check of our program.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec86">Our integrals  </h2>

<p>
The integral
$$
\langle pq \vert \hat{v} \vert rs \rangle = A\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} \exp{[-(x_1^2+x_2^2+y_1^2+y_2^2)/2]}f(x_1,y_1,x_2,y_2)dx_1dy_1dx_2dy_2,
$$

can be calculate in analytical form if we switch to polar coordinates.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec87">Single-particle functions in polar coordinates  </h2>

<p>
Instead of Hermite polynomials which we will need for the Variational Monte Carlo, it is more convenient for the Hartree-Fock calculations to use polar coordinates.

<p>
Using polar coordinates
$$
\begin{align}
x &= r \cos \theta 
\label{_auto4}\\
y &= r \sin \theta 
\label{_auto5}\\
r &= \sqrt{x^2 + y^2},
\label{_auto6}
\end{align}
$$

the normalized solution for the angular part in two dimensions is
$$
Y(\theta) = \frac{1}{\sqrt{2\pi}} e^{im\theta}
  \label{normalized angular part}
$$

<p>
The total wavefunction must satisfy the physical condition that \( \psi(r,\theta) = \psi(r,\theta+2\pi) \) This makes a restriction on the quantum number \( m \) which can take integral values
$$
m = 0, \pm 1, \pm 2, ...
$$

<p>
<!-- !split  -->

<h2 id="___sec88">Eigenfunctions in two dimensions </h2>

<p>
The time-independent part of the wave function  is separated in an angular and a radial part
$$
\psi(r,\theta) = R(r) \frac{1}{\sqrt{2\pi}} e^{im\theta}, \qquad m=0,\pm 1, \pm 2,... 
$$

<p>
The solution of the radial equation is
$$
R_{nm}(r) = \sqrt{\frac{2n!}{(n+|m|)!}}\beta^{\frac{1}{2}(|m|+1)}r^{|m|}e^{-\frac{1}{2}\beta r^2} L_n^{|m|} (\beta r^2)
$$

Here the subscript \( n \) denote the principal quantum number, and \( m \) is the angular momentum number
$$
\begin{align}
  n &= 0, 1, 2, 3, .... 
\label{_auto7}\\
  m &= 0, \pm 1, \pm, 2, \pm 3,...
\label{_auto8}
\end{align}
$$

\( L_n^{|m|} \) is the associated Laguerre polynomials discussed above, and \( \beta \) is defined as
$$
\beta = \frac{m\omega}{\hbar}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec89">Final expression for the eigenfunction </h2>

<p>
The final eigenfunction for an electron moving in a two-dimensional harmonic oscillator is then
$$
 \psi(r,\theta) = \sqrt{\frac{n!}{\pi(n+|m|)!}}\beta^{\frac{1}{2}(|m|+1)}r^{|m|}e^{-\frac{1}{2}\beta r^2} L_n^{|m|} (\beta r^2) e^{im\theta},
$$

with the  eigenvalue
$$
E = \hbar \omega(2n+|m|+1)
$$

which is the same as the energy with cartesian coordinates but now in terms of \( n_x \) and \( n_y \), that is
$$
E = \hbar \omega(n_x+n_y+1).
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec90"><a href="https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/QDCoulombPotential" target="_blank">Program for computing the Coulomb interaction in polar coordinates</a> </h2>

<p>
The program is based on the analytical expression given by <a href="http://iopscience.iop.org/article/10.1088/0953-8984/10/3/013/pdf" target="_blank">Anisimova and Matulis</a>. It returns the value of the integral (without checking for spin values, you need to add this test) using as input the quantum numbers
\( n_i \) and \( m_i \), that is 
$$
\langle pq \vert \hat{v} \vert rs \rangle =\langle (n_pm_p)(n_qm_q) \vert \hat{v} \vert (n_rm_r)(n_sm_s) \rangle, 
$$

and the main code is (click on the above link for the full code)
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;Coulomb_Functions.hpp&quot;</span><span style="color: #BC7A00"></span>

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>(<span style="color: #B00040">int</span> argc, <span style="color: #B00040">char</span> <span style="color: #666666">*</span> argv[])
{
  <span style="color: #008000; font-weight: bold">if</span>(argc <span style="color: #666666">!=</span> <span style="color: #666666">10</span>){ std<span style="color: #666666">::</span>cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Wrong Input: should be ./QD_Coulomb  hw  n1  ml1  n2  ml2  n3  ml3  n4  ml4&quot;</span> <span style="color: #666666">&lt;&lt;</span> std<span style="color: #666666">::</span>endl; exit(<span style="color: #666666">1</span>); }
  <span style="color: #B00040">double</span> hw <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atof(argv[<span style="color: #666666">1</span>]);
  <span style="color: #B00040">int</span> n1 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">2</span>]);
  <span style="color: #B00040">int</span> ml1 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">3</span>]);
  <span style="color: #B00040">int</span> n2 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">4</span>]);
  <span style="color: #B00040">int</span> ml2 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">5</span>]);
  <span style="color: #B00040">int</span> n3 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">6</span>]);
  <span style="color: #B00040">int</span> ml3 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">7</span>]);
  <span style="color: #B00040">int</span> n4 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">8</span>]);
  <span style="color: #B00040">int</span> ml4 <span style="color: #666666">=</span> std<span style="color: #666666">::</span>atoi(argv[<span style="color: #666666">9</span>]);

  <span style="color: #B00040">double</span> TBME <span style="color: #666666">=</span> Coulomb_HO(hw, n1, ml1, n2, ml2, n3, ml3, n4, ml4);
  std<span style="color: #666666">::</span>cout <span style="color: #666666">&lt;&lt;</span> std<span style="color: #666666">::</span>setprecision(<span style="color: #666666">12</span>);
  std<span style="color: #666666">::</span>cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;&lt; &quot;</span> <span style="color: #666666">&lt;&lt;</span> n1 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> ml1 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; ; &quot;</span> <span style="color: #666666">&lt;&lt;</span> n2 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> ml2 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; || V || &quot;</span> <span style="color: #666666">&lt;&lt;</span> n3 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> ml3 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; ; &quot;</span> <span style="color: #666666">&lt;&lt;</span> n4 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> ml4 <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; &gt; = &quot;</span> <span style="color: #666666">&lt;&lt;</span> TBME <span style="color: #666666">&lt;&lt;</span> std<span style="color: #666666">::</span>endl;
  
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec91">Conserved quantum numbers </h2>

<p>
When setting up the matrix elements 
$$
\langle pq \vert \hat{v} \vert rs \rangle =\langle (n_pm_p)(n_qm_q) \vert \hat{v} \vert (n_rm_r)(n_sm_s) \rangle, 
$$

you need to take into account that there are conserved two-electron quantum numbers since the Hamiltonian is invariant under rotations, namely
$$
m_p+m_q = M = m_r+m_s,
$$

and the total spin projection which is not included in the above code. You need to add this as a test, that is check that
$$
\sigma_p+\sigma_q = S_z = \sigma_r+\sigma_s.
$$

Finally, you need to ensure that the single-particle spinors satisfy  \( \sigma_p=\sigma_r \) 
and \( \sigma_q=\sigma_s \). Pay in particular attention to this when you compute the exchange matrix elements.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec92">Reminder on Variational Calculus and Lagrangian Multipliers  </h2>

<p>
The calculus of variations involves 
problems where the quantity to be minimized or maximized is an integral.

<p>
In the general case we have an integral of the type
$$ 
E[\Phi]= \int_a^b f(\Phi(x),\frac{\partial \Phi}{\partial x},x)dx,
$$

where \( E \) is the quantity which is sought minimized or maximized.
The problem is that although \( f \) is a function of the variables \( \Phi \), \( \partial \Phi/\partial x \) and \( x \), the exact dependence of
\( \Phi \) on \( x \) is not known.  This means again that even though the integral has fixed limits \( a \) and \( b \), the path of integration is
not known. In our case the unknown quantities are the single-particle wave functions and we wish to choose an integration path which makes
the functional \( E[\Phi] \) stationary. This means that we want to find minima, or maxima or saddle points. In physics we search normally for minima.
Our task is therefore to find the minimum of \( E[\Phi] \) so that its variation \( \delta E \) is zero  subject to specific
constraints. In our case the constraints appear as the integral which expresses the orthogonality of the  single-particle wave functions.
The constraints can be treated via the technique of Lagrangian multipliers

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec93">Variational Calculus and Lagrangian Multipliers, simple example  </h2>

<p>
Let us specialize to the expectation value of the energy for one particle in three-dimensions.
This expectation value reads
$$
  E=\int dxdydz \psi^*(x,y,z) \hat{H} \psi(x,y,z),
$$

with the constraint
$$
 \int dxdydz \psi^*(x,y,z) \psi(x,y,z)=1,
$$

and a Hamiltonian
$$
\hat{H}=-\frac{1}{2}\nabla^2+V(x,y,z).
$$

We will, for the sake of notational convenience,  skip the variables \( x,y,z \) below, and write for example \( V(x,y,z)=V \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec94">Manipulating terms  </h2>

<p>
The integral involving the kinetic energy can be written as, with the function \( \psi \) vanishing
strongly for large values of \( x,y,z \) (given here by the limits \( a \) and \( b \)), 
$$
  \int_a^b dxdydz \psi^* \left(-\frac{1}{2}\nabla^2\right) \psi dxdydz = \psi^*\nabla\psi|_a^b+\int_a^b dxdydz\frac{1}{2}\nabla\psi^*\nabla\psi.
$$

We will drop the limits \( a \) and \( b \) in the remaining discussion. 
Inserting this expression into the expectation value for the energy and taking the variational minimum  we obtain
$$
\delta E = \delta \left\{\int dxdydz\left( \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi\right)\right\} = 0.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec95">Adding the Lagrangian multiplier  </h2>

<p>
The constraint appears in integral form as 
$$
 \int dxdydz \psi^* \psi=\mathrm{constant},
$$

and multiplying with a Lagrangian multiplier \( \lambda \) and taking the variational minimum we obtain the final variational equation
$$
\delta \left\{\int dxdydz\left( \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi-\lambda\psi^*\psi\right)\right\} = 0.
$$

We introduce the function  \( f \)
$$
  f =  \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi-\lambda\psi^*\psi=
\frac{1}{2}(\psi^*_x\psi_x+\psi^*_y\psi_y+\psi^*_z\psi_z)+V\psi^*\psi-\lambda\psi^*\psi,
$$

where we have skipped the dependence on \( x,y,z \) and introduced the shorthand \( \psi_x \), \( \psi_y \) and \( \psi_z \)  for the various derivatives.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec96">And with the Euler-Lagrange equations we get  </h2>

<p>
For \( \psi^* \) the Euler-Lagrange  equations yield
$$
\frac{\partial f}{\partial \psi^*}- \frac{\partial }{\partial x}\frac{\partial f}{\partial \psi^*_x}-\frac{\partial }{\partial y}\frac{\partial f}{\partial \psi^*_y}-\frac{\partial }{\partial z}\frac{\partial f}{\partial \psi^*_z}=0,
$$

which results in 
$$
    -\frac{1}{2}(\psi_{xx}+\psi_{yy}+\psi_{zz})+V\psi=\lambda \psi.
$$

We can then identify the  Lagrangian multiplier as the energy of the system. The last equation is 
nothing but the standard 
Schroedinger equation and the variational  approach discussed here provides 
a powerful method for obtaining approximate solutions of the wave function.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec97">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
In deriving the Hartree-Fock equations, we  will expand the single-particle functions in a known basis  and vary the coefficients, 
that is, the new single-particle wave function is written as a linear expansion
in terms of a fixed chosen orthogonal basis (for example the well-known harmonic oscillator functions or the hydrogen-like functions etc).
We define our new Hartree-Fock single-particle basis by performing a unitary transformation 
on our previous basis (labelled with greek indices) as
$$
\begin{equation}
\psi_p^{HF}  = \sum_{\lambda} C_{p\lambda}\phi_{\lambda}. \label{eq:newbasis}
\end{equation}
$$

In this case we vary the coefficients \( C_{p\lambda} \). If the basis has infinitely many solutions, we need
to truncate the above sum.  We assume that the basis \( \phi_{\lambda} \) is orthogonal. A unitary transformation keeps the orthogonality, as discussed in exercise 1 below.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec98">More on linear algebra  </h2>

<p>
In the previous slide we stated that a unitary transformation keeps the orthogonality, as discussed in exercise 1 below.  To see this consider first a basis of vectors \( \mathbf{v}_i \),
$$
\mathbf{v}_i = \begin{bmatrix} v_{i1} \\ \dots \\ \dots \\v_{in} \end{bmatrix}
$$

We assume that the basis is orthogonal, that is 
$$
\mathbf{v}_j^T\mathbf{v}_i = \delta_{ij}.
$$

An orthogonal or unitary transformation
$$
\mathbf{w}_i=\mathbf{U}\mathbf{v}_i,
$$

preserves the dot product and orthogonality since
$$
\mathbf{w}_j^T\mathbf{w}_i=(\mathbf{U}\mathbf{v}_j)^T\mathbf{U}\mathbf{v}_i=\mathbf{v}_j^T\mathbf{U}^T\mathbf{U}\mathbf{v}_i= \mathbf{v}_j^T\mathbf{v}_i = \delta_{ij}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec99">Coefficients of a wave function expansion </h2>

<p>
This means that if the coefficients \( C_{p\lambda} \) belong to a unitary or orthogonal trasformation (using the Dirac bra-ket notation)
$$
\vert p\rangle  = \sum_{\lambda} C_{p\lambda}\vert\lambda\rangle,
$$

orthogonality is preserved, that is \( \langle \alpha \vert \beta\rangle = \delta_{\alpha\beta} \)
and \( \langle p \vert q\rangle = \delta_{pq} \).

<p>
This propertry is extremely useful when we build up a basis of many-body Stater determinant based states.

<p>
<b>Note also that although a basis \( \vert \alpha\rangle \) contains an infinity of states, for practical calculations we have always to make some truncations.</b>

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec100">More Basic Matrix Features, simple \( 2 \times 2 \) determinant, useful property of determinants  </h2>

<p>
Before we develop the Hartree-Fock equations, there is another very useful property of determinants that we will use both in connection with Hartree-Fock calculations and later shell-model calculations.

<p>
Consider the following determinant
$$
\left| \begin{array}{cc} \alpha_1b_{11}+\alpha_2sb_{12}& a_{12}\\
                         \alpha_1b_{21}+\alpha_2b_{22}&a_{22}\end{array} \right|=\alpha_1\left|\begin{array}{cc} b_{11}& a_{12}\\
                         b_{21}&a_{22}\end{array} \right|+\alpha_2\left| \begin{array}{cc} b_{12}& a_{12}\\b_{22}&a_{22}\end{array} \right|
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec101">More Basic Matrix Features, \( n \times n \) determinant </h2>

<p>
We can generalize this to  an \( n\times n \) matrix and have 
$$
\left| \begin{array}{cccccc} a_{11}& a_{12} & \dots & \sum_{k=1}^n c_k b_{1k} &\dots & a_{1n}\\
a_{21}& a_{22} & \dots & \sum_{k=1}^n c_k b_{2k} &\dots & a_{2n}\\
\dots & \dots & \dots & \dots & \dots & \dots \\
\dots & \dots & \dots & \dots & \dots & \dots \\
a_{n1}& a_{n2} & \dots & \sum_{k=1}^n c_k b_{nk} &\dots & a_{nn}\end{array} \right|=
\sum_{k=1}^n c_k\left| \begin{array}{cccccc} a_{11}& a_{12} & \dots &  b_{1k} &\dots & a_{1n}\\
a_{21}& a_{22} & \dots &  b_{2k} &\dots & a_{2n}\\
\dots & \dots & \dots & \dots & \dots & \dots\\
\dots & \dots & \dots & \dots & \dots & \dots\\
a_{n1}& a_{n2} & \dots &  b_{nk} &\dots & a_{nn}\end{array} \right| .
$$

This is a property we will use in our Hartree-Fock discussions.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec102">More Basic Matrix Features, a general \( n \times n \) determinant </h2>

<p>
We can generalize the previous results, now 
with all elements \( a_{ij} \)  being given as functions of 
linear combinations  of various coefficients \( c \) and elements \( b_{ij} \),
$$
\left| \begin{array}{cccccc} \sum_{k=1}^n b_{1k}c_{k1}& \sum_{k=1}^n b_{1k}c_{k2} & \dots & \sum_{k=1}^n b_{1k}c_{kj}  &\dots & \sum_{k=1}^n b_{1k}c_{kn}\\
\sum_{k=1}^n b_{2k}c_{k1}& \sum_{k=1}^n b_{2k}c_{k2} & \dots & \sum_{k=1}^n b_{2k}c_{kj} &\dots & \sum_{k=1}^n b_{2k}c_{kn}\\
\dots & \dots & \dots & \dots & \dots & \dots \\
\dots & \dots & \dots & \dots & \dots &\dots \\
\sum_{k=1}^n b_{nk}c_{k1}& \sum_{k=1}^n b_{nk}c_{k2} & \dots & \sum_{k=1}^n b_{nk}c_{kj} &\dots & \sum_{k=1}^n b_{nk}c_{kn}\end{array} \right|=det(\mathbf{C})det(\mathbf{B}),
$$

where \( det(\mathbf{C}) \) and \( det(\mathbf{B}) \) are the determinants of \( n\times n \) matrices
with elements \( c_{ij} \) and \( b_{ij} \) respectively.  
This is a property we will use in our Hartree-Fock discussions. Convince yourself about the correctness of the above expression by setting \( n=2 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec103">A general Slater determinant </h2>

<p>
With our definition of the new basis in terms of an orthogonal basis we have
$$
\psi_p(x)  = \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x).
$$

If the coefficients \( C_{p\lambda} \) belong to an orthogonal or unitary matrix, the new basis
is also orthogonal. 
Our Slater determinant in the new basis \( \psi_p(x) \) is written as
$$
\frac{1}{\sqrt{A!}}
\left| \begin{array}{ccccc} \psi_{p}(x_1)& \psi_{p}(x_2)& \dots & \dots & \psi_{p}(x_A)\\
                            \psi_{q}(x_1)&\psi_{q}(x_2)& \dots & \dots & \psi_{q}(x_A)\\  
                            \dots & \dots & \dots & \dots & \dots \\
                            \dots & \dots & \dots & \dots & \dots \\
                     \psi_{t}(x_1)&\psi_{t}(x_2)& \dots & \dots & \psi_{t}(x_A)\end{array} \right|=\frac{1}{\sqrt{A!}}
\left| \begin{array}{ccccc} \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_1)& \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_2)& \dots & \dots & \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_A)\\
                            \sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_1)&\sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_2)& \dots & \dots & \sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_A)\\  
                            \dots & \dots & \dots & \dots & \dots \\
                            \dots & \dots & \dots & \dots & \dots \\
                     \sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_1)&\sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_2)& \dots & \dots & \sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_A)\end{array} \right|,
$$

which is nothing but \( det(\mathbf{C})det(\Phi) \), with \( det(\Phi) \) being the determinant given by the basis functions \( \phi_{\lambda}(x) \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec104">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
It is normal to choose a single-particle basis defined as the eigenfunctions
of parts of the full Hamiltonian. The typical situation consists of the solutions of the one-body part of the Hamiltonian, that is we have
$$
\hat{h}_0\phi_{\lambda}=\epsilon_{\lambda}\phi_{\lambda}.
$$

The single-particle wave functions \( \phi_{\lambda}(\boldsymbol{r}) \), defined by the quantum numbers \( \lambda \) and \( \boldsymbol{r} \)
are defined as the overlap 
$$
   \phi_{\lambda}(\boldsymbol{r})  = \langle \boldsymbol{r} | \lambda \rangle .
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec105">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
In our discussions hereafter we will use our definitions of single-particle states above and below the Fermi (\( F \)) level given by the labels
\( ijkl\dots \le F \) for so-called single-hole states and \( abcd\dots > F \) for so-called particle states.
For general single-particle states we employ the labels \( pqrs\dots \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec106">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
In Eq.&nbsp;\eqref{FunctionalEPhi}, restated here
$$
  E[\Phi] 
  = \sum_{\mu=1}^A \langle \mu | h | \mu \rangle +
  \frac{1}{2}\sum_{{\mu}=1}^A\sum_{{\nu}=1}^A \langle \mu\nu|\hat{v}|\mu\nu\rangle_{AS},
$$

we found the expression for the energy functional in terms of the basis function \( \phi_{\lambda}(\boldsymbol{r}) \). We then  varied the above energy functional with respect to the basis functions \( |\mu \rangle \). 
Now we are interested in defining a new basis defined in terms of
a chosen basis as defined in Eq.&nbsp;\eqref{eq:newbasis}. We can then rewrite the energy functional as
$$
\begin{equation}
  E[\Phi^{HF}] 
  = \sum_{i=1}^A \langle i | h | i \rangle +
  \frac{1}{2}\sum_{ij=1}^A\langle ij|\hat{v}|ij\rangle_{AS}, \label{FunctionalEPhi2}
\end{equation}
$$

where \( \Phi^{HF} \) is the new Slater determinant defined by the new basis of Eq.&nbsp;\eqref{eq:newbasis}.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec107">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
Using Eq.&nbsp;\eqref{eq:newbasis} we can rewrite Eq.&nbsp;\eqref{FunctionalEPhi2} as 
$$
\begin{equation}
  E[\Psi] 
  = \sum_{i=1}^A \sum_{\alpha\beta} C^*_{i\alpha}C_{i\beta}\langle \alpha | h | \beta \rangle +
  \frac{1}{2}\sum_{ij=1}^A\sum_{{\alpha\beta\gamma\delta}} C^*_{i\alpha}C^*_{j\beta}C_{i\gamma}C_{j\delta}\langle \alpha\beta|\hat{v}|\gamma\delta\rangle_{AS}. \label{FunctionalEPhi3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec108">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
We wish now to minimize the above functional. We introduce again a set of Lagrange multipliers, noting that
since \( \langle i | j \rangle = \delta_{i,j} \) and \( \langle \alpha | \beta \rangle = \delta_{\alpha,\beta} \), 
the coefficients \( C_{i\gamma} \) obey the relation
$$
 \langle i | j \rangle=\delta_{i,j}=\sum_{\alpha\beta} C^*_{i\alpha}C_{i\beta}\langle \alpha | \beta \rangle=
\sum_{\alpha} C^*_{i\alpha}C_{i\alpha},
$$

which allows us to define a functional to be minimized that reads
$$
\begin{equation}
  F[\Phi^{HF}]=E[\Phi^{HF}] - \sum_{i=1}^A\epsilon_i\sum_{\alpha} C^*_{i\alpha}C_{i\alpha}.
\label{_auto9}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec109">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
Minimizing with respect to \( C^*_{i\alpha} \), remembering that the equations for \( C^*_{i\alpha} \) and \( C_{i\alpha} \)
can be written as two  independent equations, we obtain
$$
\frac{d}{dC^*_{i\alpha}}\left[  E[\Phi^{HF}] - \sum_{j}\epsilon_j\sum_{\alpha} C^*_{j\alpha}C_{j\alpha}\right]=0,
$$

which yields for every single-particle state \( i \) and index \( \alpha \) (recalling that the coefficients \( C_{i\alpha} \) are matrix elements of a unitary (or orthogonal for a real symmetric matrix) matrix)
the following Hartree-Fock equations
$$
\sum_{\beta} C_{i\beta}\langle \alpha | h | \beta \rangle+
\sum_{j=1}^A\sum_{\beta\gamma\delta} C^*_{j\beta}C_{j\delta}C_{i\gamma}\langle \alpha\beta|\hat{v}|\gamma\delta\rangle_{AS}=\epsilon_i^{HF}C_{i\alpha}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec110">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
We can rewrite this equation as (changing dummy variables)
$$
\sum_{\beta} \left\{\langle \alpha | h | \beta \rangle+
\sum_{j}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}\right\}C_{i\beta}=\epsilon_i^{HF}C_{i\alpha}.
$$

Note that the sums over greek indices run over the number of basis set functions (in principle an infinite number).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec111">Hartree-Fock by varying the coefficients of a wave function expansion </h2>

<p>
Defining 
$$
h_{\alpha\beta}^{HF}=\langle \alpha | h | \beta \rangle+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS},
$$

we can rewrite the new equations as 
$$
\begin{equation}
\sum_{\gamma}h_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{HF}C_{i\alpha}. \label{eq:newhf}
\end{equation}
$$

The latter is nothing but a standard eigenvalue problem.

<p>
It suffices to tabulate the matrix elements \( \langle \alpha | h | \beta \rangle \) and \( \langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS} \) once and for all. Successive iterations require thus only a look-up in tables over one-body and two-body matrix elements. These details will be discussed below when we solve the Hartree-Fock equations numerically.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec112">Hartree-Fock algorithm </h2>

<p>
Our Hartree-Fock matrix  is thus
$$
\hat{h}_{\alpha\beta}^{HF}=\langle \alpha | \hat{h}_0 | \beta \rangle+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
$$

The Hartree-Fock equations are solved in an iterative waym starting with a guess for the coefficients \( C_{j\gamma}=\delta_{j,\gamma} \) and solving the equations by diagonalization till the new single-particle energies
\( \epsilon_i^{\mathrm{HF}} \) do not change anymore by a prefixed quantity.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec113">Hartree-Fock algorithm </h2>

<p>
Normally we assume that the single-particle basis \( |\beta\rangle \) forms an eigenbasis for the operator
\( \hat{h}_0 \), meaning that the Hartree-Fock matrix becomes  
$$
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
$$

The Hartree-Fock eigenvalue problem
$$
\sum_{\beta}\hat{h}_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{\mathrm{HF}}C_{i\alpha},
$$

can be written out in a more compact form as
$$
\hat{h}^{HF}\hat{C}=\epsilon^{\mathrm{HF}}\hat{C}. 
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec114">Hartree-Fock algorithm </h2>

<p>
The Hartree-Fock equations are, in their simplest form, solved in an iterative way, starting with a guess for the
coefficients \( C_{i\alpha} \). We label the coefficients as \( C_{i\alpha}^{(n)} \), where the subscript \( n \) stands for iteration \( n \).
To set up the algorithm we can proceed as follows:

<ul>
 <li> We start with a guess \( C_{i\alpha}^{(0)}=\delta_{i,\alpha} \). Alternatively, we could have used random starting values as long as the vectors are normalized. Another possibility is to give states below the Fermi level a larger weight.</li>
 <li> The Hartree-Fock matrix simplifies then to (assuming that the coefficients \( C_{i\alpha}  \)  are real)</li>
</ul>

$$
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j = 1}^A\sum_{\gamma\delta} C_{j\gamma}^{(0)}C_{j\delta}^{(0)}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec115">Hartree-Fock algorithm </h2>

<p>
Solving the Hartree-Fock eigenvalue problem yields then new eigenvectors \( C_{i\alpha}^{(1)} \) and eigenvalues
\( \epsilon_i^{HF(1)} \). 

<ul>
 <li> With the new eigenvalues we can set up a new Hartree-Fock potential</li> 
</ul>

$$
\sum_{j = 1}^A\sum_{\gamma\delta} C_{j\gamma}^{(1)}C_{j\delta}^{(1)}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
$$

The diagonalization with the new Hartree-Fock potential yields new eigenvectors and eigenvalues.
This process is continued till for example
$$
\frac{\sum_{p} |\epsilon_i^{(n)}-\epsilon_i^{(n-1)}|}{m} \le \lambda,  
$$

where \( \lambda \) is a user prefixed quantity (\( \lambda \sim 10^{-8} \) or smaller) and \( p \) runs over all calculated single-particle
energies and \( m \) is the number of single-particle states.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec116">Analysis of Hartree-Fock equations and Koopman's theorem </h2>

<p>
We can rewrite the ground state energy by adding and subtracting \( \hat{u}^{HF}(x_i) \) 
$$
  E_0^{HF} =\langle \Phi_0 | \hat{H} | \Phi_0\rangle = 
\sum_{i\le F}^A \langle i | \hat{h}_0 +\hat{u}^{HF}| j\rangle+ \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right]-\sum_{i\le F}^A \langle i |\hat{u}^{HF}| i\rangle,
$$

which results in
$$
  E_0^{HF}
  = \sum_{i\le F}^A \varepsilon_i^{HF} + \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right]-\sum_{i\le F}^A \langle i |\hat{u}^{HF}| i\rangle.
$$

Our single-particle states \( ijk\dots \) are now single-particle states obtained from the solution of the Hartree-Fock equations.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec117">Analysis of Hartree-Fock equations and Koopman's theorem </h2>

<p>
Using our definition of the Hartree-Fock single-particle energies we obtain then the following expression for the total ground-state energy
$$
  E_0^{HF}
  = \sum_{i\le F}^A \varepsilon_i - \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right].
$$

This form will be used in our discussion of Koopman's theorem.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec118">Analysis of Hartree-Fock equations and Koopman's theorem </h2>
  Atomic physics case
We have 
$$
  E[\Phi^{\mathrm{HF}}(N)] 
  = \sum_{i=1}^H \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1}^N\langle ij|\hat{v}|ij\rangle_{AS},
$$

where \( \Phi^{\mathrm{HF}}(N) \) is the new Slater determinant defined by the new basis of Eq.&nbsp;\eqref{eq:newbasis}
for \( N \) electrons (same \( Z \)).  If we assume that the single-particle wave functions in the new basis do not change 
when we remove one electron or add one electron, we can then define the corresponding energy for the \( N-1 \) systems as 
$$
  E[\Phi^{\mathrm{HF}}(N-1)] 
  = \sum_{i=1; i\ne k}^N \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1;i,j\ne k}^N\langle ij|\hat{v}|ij\rangle_{AS},
$$

where we have removed a single-particle state \( k\le F \), that is a state below the Fermi level.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec119">Analysis of Hartree-Fock equations and Koopman's theorem </h2>

<p>
Calculating the difference 
$$
  E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \langle k | \hat{h}_0 | k \rangle +
  \frac{1}{2}\sum_{i=1;i\ne k}^N\langle ik|\hat{v}|ik\rangle_{AS}  \frac{1}{2}\sum_{j=1;j\ne k}^N\langle kj|\hat{v}|kj\rangle_{AS},
$$

we obtain
$$
  E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \langle k | \hat{h}_0 | k \rangle +
  \frac{1}{2}\sum_{j=1}^N\langle kj|\hat{v}|kj\rangle_{AS}
$$

which is just our definition of the Hartree-Fock single-particle energy
$$
  E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \epsilon_k^{\mathrm{HF}} 
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec120">Analysis of Hartree-Fock equations and Koopman's theorem </h2>

<p>
Similarly, we can now compute the difference (we label the single-particle states above the Fermi level as \( abcd > F \))
$$
  E[\Phi^{\mathrm{HF}}(N+1)]-   E[\Phi^{\mathrm{HF}}(N)]= \epsilon_a^{\mathrm{HF}}. 
$$

These two equations can thus be used to the electron affinity or ionization energies, respectively. 
Koopman's theorem states that for example the ionization energy of a closed-shell system is given by the energy of the highest occupied single-particle state.  If we assume that changing the number of electrons from \( N \) to \( N+1 \) does not change the Hartree-Fock single-particle energies and eigenfunctions, then Koopman's theorem simply states that the ionization energy of an atom is given by the single-particle energy of the last bound state. In a similar way, we can also define the electron affinities.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec121">Analysis of Hartree-Fock equations and Koopman's theorem </h2>

<p>
As an example, consider a simple model for atomic sodium, Na. Neutral sodium has eleven electrons, 
with the weakest bound one being confined the \( 3s \) single-particle quantum numbers. The energy needed to remove an electron from neutral sodium is rather small, 5.1391 eV, a feature which pertains to all alkali metals.
Having performed a  Hartree-Fock calculation for neutral sodium would then allows us to compute the
ionization energy by using the single-particle energy for the \( 3s \) states, namely \( \epsilon_{3s}^{\mathrm{HF}} \).

<p>
From these considerations, we see that Hartree-Fock theory allows us to make a connection between experimental 
observables (here ionization and affinity energies) and the underlying interactions between particles.  
In this sense, we are now linking the dynamics and structure of a many-body system with the laws of motion which govern the system. Our approach is a reductionistic one, meaning that we want to understand the laws of motion 
in terms of the particles or degrees of freedom which we believe are the fundamental ones. Our Slater determinant, being constructed as the product of various single-particle functions, follows this philosophy.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec122">Exercise 1: Hartree-Fock Slater determinant </h2>

<p>
Consider a Slater determinant built up of orthogonal single-particle orbitals \( \psi_{\lambda} \), 
with \( \lambda = 1,2,\dots,A \).

<p>
The unitary transformation
$$
\psi_a  = \sum_{\lambda} C_{a\lambda}\phi_{\lambda},
$$

brings us into the new basis.  
The new basis has quantum numbers \( a=1,2,\dots,A \).

<p>
<b>a)</b>
Show that the new basis is orthogonal.

<p>
<b>b)</b>
Show that the new Slater determinant constructed from the new single-particle wave functions can be
written as the determinant based on the previous basis and the determinant of the matrix \( C \).

<p>
<b>c)</b>
Show that the old and the new Slater determinants are equal up to a complex constant with absolute value unity.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Hint: \( C \) is a unitary matrix.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec123">Exercise 2: Matrix elements for the Hartree-Fock method and the nuclear shell model </h2>

<p>
We will assume that we can build various Slater determinants using an orthogonal  single-particle basis \( \psi_{\lambda} \), 
with \( \lambda = 1,2,\dots,A \).

<p>
The aim of this exercise is to set up specific matrix elements that will turn useful when we start our discussions of the nuclear shell model. In particular you will notice, depending on the character of the operator, that many matrix elements will actually be zero.

<p>
Consider three \( A \)-particle  Slater determinants  \( |\Phi_0 \), \( |\Phi_i^a\rangle \) and \( |\Phi_{ij}^{ab}\rangle \), where the notation means that 
Slater determinant \( |\Phi_i^a\rangle \) differs from \( |\Phi_0\rangle \) by one single-particle state, that is a single-particle
state \( \psi_i \) is replaced by a single-particle state \( \psi_a \). 
It will later be interpreted as a so-called one-particle-one-hole excitation.
Similarly, the Slater determinant \( |\Phi_{ij}^{ab}\rangle \)
differs by two single-particle states from \( |\Phi_0\rangle \) and is normally thought of as a two-particle-two-hole excitation.

<p>
Define a general onebody operator \( \hat{F} = \sum_{i}^A\hat{f}(x_{i}) \) and a general  twobody operator \( \hat{G}=\sum_{i>j}^A\hat{g}(x_{i},x_{j}) \) with \( g \) being invariant under the interchange of the coordinates of particles \( i \) and \( j \). You can use here the results from the second exercise set, exercise 3.

<p>
<b>a)</b>
Calculate
$$
\langle \Phi_0 \vert\hat{F}\vert\Phi_0\rangle,
$$

and
$$
\langle \Phi_0\vert\hat{G}|\Phi_0\rangle.
$$

<p>
<b>b)</b>
Find thereafter 
$$
\langle \Phi_0 |\hat{F}|\Phi_i^a\rangle,
$$

and
$$
\langle \Phi_0|\hat{G}|\Phi_i^a\rangle,
$$

<p>
<b>c)</b>
Finally, find
$$
\langle \Phi_0 |\hat{F}|\Phi_{ij}^{ab}\rangle,
$$

and
$$
\langle \Phi_0|\hat{G}|\Phi_{ij}^{ab}\rangle.
$$

What happens with the two-body operator if we have a transition probability  of the type
$$
\langle \Phi_0|\hat{G}|\Phi_{ijk}^{abc}\rangle,
$$

where the Slater determinant to the right of the operator differs by more than two single-particle states?

<p>
<b>d)</b>
With an orthogonal basis of Slater determinants \( \Phi_{\lambda} \), we can now construct an exact many-body state as a linear expansion of Slater determinants, that is, a given exact state
$$
\Psi_i = \sum_{\lambda =0}^{\infty}C_{i\lambda}\Phi_{\lambda}.
$$

In all practical calculations the infinity is replaced by a given truncation in the sum.

<p>
If you are to compute the expectation value of (at most) a two-body Hamiltonian for the above
exact state
$$
\langle \Psi_i \vert \hat{H} \vert \Psi_i\rangle,
$$

based on the calculations above, which are the only elements which will contribute?  (there is no need to perform any calculation here, use your results from exercises a), b), and c)).

<p>
These results simplify to a large extent shell-model calculations.

<p>
<!-- --- end exercise --- -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec124">Developing a  Hartree-Fock program  </h2>

<p>
The Hamiltonian for a system of \( N \) electrons confined in a
harmonic potential reads
$$
\hat{H} = \sum_{i=1}^{N} \frac{\hat{p}_{i}^{2}}{2m}+\sum_{i=1}^{N} \frac{1}{2} m\omega {r}_{i}^{2}+\sum_{i < j} \hat{V}_{ij},
$$

with  \( \hat{V}_{ij} \) is the two-body potential whose 
matrix elements are calculated on fly in your program. See expression below.

<p>
The Hartree-Fock algorithm can be broken down as follows. We recall that  our Hartree-Fock matrix  is 
$$
\hat{h}_{\alpha\beta}^{HF}=\langle \alpha \vert\hat{h}_0 \vert \beta \rangle+
\sum_{j=1}^N\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
$$

Normally we assume that the single-particle basis \( \vert\beta\rangle \)
forms an eigenbasis for the operator \( \hat{h}_0 \) (this is our case), meaning that the
Hartree-Fock matrix becomes
$$
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j=1}^N\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
$$

The Hartree-Fock eigenvalue problem
$$
\sum_{\beta}\hat{h}_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{\mathrm{HF}}C_{i\alpha},
$$

can be written out in a more compact form as
$$
\hat{h}^{HF}\hat{C}=\epsilon^{\mathrm{HF}}\hat{C}. 
$$

<p>
The equations are often rewritten in terms of a so-called density matrix,
which is defined as 
$$
\begin{equation}
\rho_{\gamma\delta}=\sum_{i=1}^{N}\langle\gamma|i\rangle\langle i|\delta\rangle = \sum_{i=1}^{N}C_{i\gamma}C^*_{i\delta}.
\label{_auto10}
\end{equation}
$$

It means that we can rewrite the Hartree-Fock Hamiltonian as
$$
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{\gamma\delta} \rho_{\gamma\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
$$

It is convenient to use the density matrix since we can precalculate in every iteration the product of two eigenvector components \( C \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec125"><a href="https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/HFcode/python/hf.py" target="_blank">Program for computing the Coulomb interaction in polar coordinates</a> </h2>

<p>
Here we show a simple code in python for a Hartree-Fock calculation using precalculated matrix elements.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span> 
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decimal</span> <span style="color: #008000; font-weight: bold">import</span> Decimal
<span style="color: #408080; font-style: italic"># expectation value for the one body part, Harmonic oscillator in three dimensions</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">onebody</span>(i, n, l):
	homega <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>
	<span style="color: #008000; font-weight: bold">return</span> homega<span style="color: #666666">*</span>(<span style="color: #666666">2*</span>n[i] <span style="color: #666666">+</span> l[i] <span style="color: #666666">+</span> <span style="color: #666666">1.5</span>)

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
	
        Nparticles <span style="color: #666666">=</span> <span style="color: #666666">16</span>
	<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Read quantum numbers from file &quot;&quot;&quot;</span>
        index <span style="color: #666666">=</span> []
	n <span style="color: #666666">=</span> []
        l <span style="color: #666666">=</span> []
        j <span style="color: #666666">=</span> []	
        mj <span style="color: #666666">=</span> []
        tz <span style="color: #666666">=</span> []
	spOrbitals <span style="color: #666666">=</span> <span style="color: #666666">0</span>
	<span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;nucleispnumbers.dat&quot;</span>, <span style="color: #BA2121">&quot;r&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> qnumfile:
		<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> qnumfile:
			nums <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
			<span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(nums) <span style="color: #666666">!=</span> <span style="color: #666666">0</span>:
				index<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">0</span>]))
				n<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">1</span>]))
				l<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">2</span>]))
				j<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">3</span>]))
				mj<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">4</span>]))
				tz<span style="color: #666666">.</span>append(<span style="color: #008000">int</span>(nums[<span style="color: #666666">5</span>]))
				spOrbitals <span style="color: #666666">+=</span> <span style="color: #666666">1</span>


	<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Read two-nucleon interaction elements (integrals) from file, brute force 4-dim array &quot;&quot;&quot;</span>
	nninteraction <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros([spOrbitals, spOrbitals, spOrbitals, spOrbitals])
	<span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;nucleitwobody.dat&quot;</span>, <span style="color: #BA2121">&quot;r&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> infile:
		<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
			number <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
			a <span style="color: #666666">=</span> <span style="color: #008000">int</span>(number[<span style="color: #666666">0</span>]) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
			b <span style="color: #666666">=</span> <span style="color: #008000">int</span>(number[<span style="color: #666666">1</span>]) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
			c <span style="color: #666666">=</span> <span style="color: #008000">int</span>(number[<span style="color: #666666">2</span>]) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
			d <span style="color: #666666">=</span> <span style="color: #008000">int</span>(number[<span style="color: #666666">3</span>]) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
			<span style="color: #408080; font-style: italic">#print a, b, c, d, float(l[4])</span>
			nninteraction[a][b][c][d] <span style="color: #666666">=</span> Decimal(number[<span style="color: #666666">4</span>])
	<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Set up single-particle integral &quot;&quot;&quot;</span>
	singleparticleH <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(spOrbitals)
	<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
		singleparticleH[i] <span style="color: #666666">=</span> Decimal(onebody(i, n, l))
	
	<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Star HF-iterations, preparing variables and density matrix &quot;&quot;&quot;</span>

        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Coefficients for setting up density matrix, assuming only one along the diagonals &quot;&quot;&quot;</span>
	C <span style="color: #666666">=</span> np<span style="color: #666666">.</span>eye(spOrbitals) <span style="color: #408080; font-style: italic"># HF coefficients</span>
        DensityMatrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros([spOrbitals,spOrbitals])
        <span style="color: #008000; font-weight: bold">for</span> gamma <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
            <span style="color: #008000; font-weight: bold">for</span> delta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                <span style="color: #008000">sum</span> <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nparticles):
                    <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> C[gamma][i]<span style="color: #666666">*</span>C[delta][i]
                DensityMatrix[gamma][delta] <span style="color: #666666">=</span> Decimal(<span style="color: #008000">sum</span>)
        maxHFiter <span style="color: #666666">=</span> <span style="color: #666666">100</span>
        epsilon <span style="color: #666666">=</span>  <span style="color: #666666">1.0e-5</span> 
        difference <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
	hf_count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
	oldenergies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(spOrbitals)
	newenergies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(spOrbitals)
	<span style="color: #008000; font-weight: bold">while</span> hf_count <span style="color: #666666">&lt;</span> maxHFiter <span style="color: #AA22FF; font-weight: bold">and</span> difference <span style="color: #666666">&gt;</span> epsilon:
		<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;############### Iteration </span><span style="color: #BB6688; font-weight: bold">%i</span><span style="color: #BA2121"> ###############&quot;</span> <span style="color: #666666">%</span> hf_count
   	        HFmatrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros([spOrbitals,spOrbitals])		
		<span style="color: #008000; font-weight: bold">for</span> alpha <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
			<span style="color: #008000; font-weight: bold">for</span> beta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;  If tests for three-dimensional systems, including isospin conservation &quot;&quot;&quot;</span>
                            <span style="color: #008000; font-weight: bold">if</span> l[alpha] <span style="color: #666666">!=</span> l[beta] <span style="color: #AA22FF; font-weight: bold">and</span> j[alpha] <span style="color: #666666">!=</span> j[beta] <span style="color: #AA22FF; font-weight: bold">and</span> mj[alpha] <span style="color: #666666">!=</span> mj[beta] <span style="color: #AA22FF; font-weight: bold">and</span> tz[alpha] <span style="color: #666666">!=</span> tz[beta]: <span style="color: #008000; font-weight: bold">continue</span>
                            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;  Setting up the Fock matrix using the density matrix and antisymmetrized NN interaction in m-scheme &quot;&quot;&quot;</span>
     		            sumFockTerm <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
                            <span style="color: #008000; font-weight: bold">for</span> gamma <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                                <span style="color: #008000; font-weight: bold">for</span> delta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                                    <span style="color: #008000; font-weight: bold">if</span> (mj[alpha]<span style="color: #666666">+</span>mj[gamma]) <span style="color: #666666">!=</span> (mj[beta]<span style="color: #666666">+</span>mj[delta]) <span style="color: #AA22FF; font-weight: bold">and</span> (tz[alpha]<span style="color: #666666">+</span>tz[gamma]) <span style="color: #666666">!=</span> (tz[beta]<span style="color: #666666">+</span>tz[delta]): <span style="color: #008000; font-weight: bold">continue</span>
                                    sumFockTerm <span style="color: #666666">+=</span> DensityMatrix[gamma][delta]<span style="color: #666666">*</span>nninteraction[alpha][gamma][beta][delta]
                            HFmatrix[alpha][beta] <span style="color: #666666">=</span> Decimal(sumFockTerm)
                            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;  Adding the one-body term, here plain harmonic oscillator &quot;&quot;&quot;</span>
                            <span style="color: #008000; font-weight: bold">if</span> beta <span style="color: #666666">==</span> alpha:   HFmatrix[alpha][alpha] <span style="color: #666666">+=</span> singleparticleH[alpha]
		spenergies, C <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eigh(HFmatrix)
                <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Setting up new density matrix in m-scheme &quot;&quot;&quot;</span>
                DensityMatrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros([spOrbitals,spOrbitals])
                <span style="color: #008000; font-weight: bold">for</span> gamma <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                    <span style="color: #008000; font-weight: bold">for</span> delta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                        <span style="color: #008000">sum</span> <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
                        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nparticles):
                            <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> C[gamma][i]<span style="color: #666666">*</span>C[delta][i]
                        DensityMatrix[gamma][delta] <span style="color: #666666">=</span> Decimal(<span style="color: #008000">sum</span>)
		newenergies <span style="color: #666666">=</span> spenergies
                <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Brute force computation of difference between previous and new sp HF energies &quot;&quot;&quot;</span>
                <span style="color: #008000">sum</span> <span style="color: #666666">=0.0</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                    <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> (<span style="color: #008000">abs</span>(newenergies[i]<span style="color: #666666">-</span>oldenergies[i]))<span style="color: #666666">/</span>spOrbitals
                difference <span style="color: #666666">=</span> <span style="color: #008000">sum</span>
                oldenergies <span style="color: #666666">=</span> newenergies
                <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;Single-particle energies, ordering may have changed &quot;</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(spOrbitals):
                    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;{0:4d}  {1:.4f}&#39;</span><span style="color: #666666">.</span>format(i, Decimal(oldenergies[i])))
		hf_count <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
</pre></div>
<p>
<!-- !split  -->

<h2 id="___sec126">Practicalities with the Hartree-Fock code development, basis construction </h2>
When  setting up the Hartree-Fock algorithm you will find it convenient to number the basis states
by filling the lowest subshells. For the first two shells we could then have the following mapping.
$$
\begin{align*}
  \vert 0\rangle & = \{n=0, m=0, m_s = -0.5\} \\ 
  \vert 1\rangle & = \{n=0, m=0, m_s = 0.5\} \\
  \vert 2\rangle & = \{n=0, m=-1, m_s = -0.5\} \\
  \vert 3\rangle & = \{n=0, m=-1, m_s = 0.5\} \\
  \vert 4\rangle & = \{n=0, m=+1, m_s = -0.5\} \\
  \vert 5\rangle & = \{n=0, m=+1, m_s = 0.5\}   
\end{align*}
$$

<p>
<!-- !split  -->

<h2 id="___sec127">Practicalities with the Hartree-Fock code development, two-body basis construction, brute force </h2>
In the setup of the two-body matrix elements we can typically opt between two alternatives. We can read the matrix elements from file or calculate the matrix elements on the fly. The latter requires simply that we 
call the abovementioned function for setting up the two-body matrix elements when we run our Hartree-Fock code.

<p>
If we however wish to read from file, we can store the matrix elements in two ways:

<ul>
<li> Brute force</li>
<li> Organize according to conserved two-body quantum numbers</li>
</ul>

The brute force way is easy to implement.

<p>
<!-- !split  -->

<h2 id="___sec128">Two-body interaction, brute force part I </h2>
We can read in from file the two-body interaction matrix elements or compute once and for all and store in
memory.
The elements are
$$
\langle pr | \hat{v}|qs\rangle.
$$

<p>
The time-consuming part in the Hartree-Fock calculations
involves the calculation of the two-body matrix. Furthermore, the
storage of these matrix elements plays also an important role, in
particular we wish to access the table of matrix elements as fast as
possible.

<p>
<!-- !split  -->

<h2 id="___sec129">Two-body interaction, brute force part II </h2>
In a brute force algorithm for storing the matrix elements, if we have \( d \) basis functions, we end up with the need of storing 
\( d^4 \) matrix elements. We can reduce this considerably by the following considerations.
In the calculation of the two-body matrix elements \( \langle pr | \hat{v}|qs\rangle \) we have the following symmetries

<ol>
<li> Invariance under permutations, that is</li>
</ol>

$$
\langle pq | \hat{v}|rs\rangle = \langle qp | \hat{v}|sr\rangle.
$$


<ol>
<li> The functions entering the evaluation of the integrals are all real, meaning that if we interchange \( p\leftrightarrow q \) or  \( r\leftrightarrow s \), we end up with the same matrix element.</li>
</ol>

This reduces by a factor of eight the total number of matrix elements to be stored if we also use that 
we can store only for \( p < q \) and $ r < s$.

<p>
<!-- !split  -->

<h2 id="___sec130">Two-body interaction, brute force part III </h2>

<p>
Furthermore, in setting up a table for the two-body matrix elements we can convert the need of using four indices \( pqrs \) of 
$$
\langle pr | \hat{v}|qs\rangle,
$$

 which in a brute forces way could be coded as a four-dimensional array, to 
a two-dimensional array \( V_{lm} \), where \( l \) and \( m \) stand for all possible two-body configurations \( pq \).

<p>
Each number \( l \) and \( m \) in \( V_{lm} \)  should then point to a set of single-particle  states \( (p,q) \) and \( (r,s) \).

<p>
In our case, since we have 
symmetries which allow us to set \( p\le q \), we have, with \( d \) single particle states a total of \( d(d+1)/2 \) two-body configurations.

<p>
<!-- !split  -->

<h2 id="___sec131">Two-body interaction, brute force part IV </h2>

<p>
How do we store such a matrix? The simplest thing to do is to convert it into a one-dimensional array. How do we achieve that?

<p>
We now have a matrix \( V \) of dimension \( n\times n \) and we want to store the elements \( V_{lm} \) as a one-dimensional array \( A \) using
\( 0 \le l \le m \le n-1 \). For

<ol>
<li> \( l=0 \) we have \( n \) elements</li>
<li> \( l=1 \) we have \( n-1 \) elements</li>
<li> \( \dots \)</li>
<li> \( l=\nu \) we have \( n-\nu \) elements</li>
<li> \( \dots \)</li>
<li> \( l=n-1 \) we have \( 1 \) element,</li>
</ol>

and the total number is  
$$
\sum_{\nu =0}^{n-1}\left(n-\nu\right)=\frac{n(n+1)}{2}.
$$

<p>
<!-- !split  -->

<h2 id="___sec132">Two-body interaction, brute force part V </h2>

<p>
To find the number (\( \mathrm{number}(l,m) \)) in a one-dimensional array \( A \) which corresponds to a matrix element \( V_{lm} \), we note that
$$
\mathrm{number}(l,m)=\sum_{\nu =0}^{l-1}\left(n-\nu\right)+m-l=\frac{l(2n-l-1)}{2}+m.
$$

The first matrix element \( V(0,0) \) is obviously given by the element \( A(0) \).

<p>
We have thus reduced a four dimensional array to a one-dimensional array, where the given pairs \( (p,q) \) and \( (r,s) \) point to the matrix indices \( l \)
and \( m \), respectively. The latter are used to find the explicit number \( \mathrm{number}(l,m) \) which points to the desired matrix element stored 
in a one-dimensional array.

<p>
<!-- !split  -->

<h2 id="___sec133">Practicalities with the Hartree-Fock code development, two-body basis construction </h2>

<p>
Another way to store the matrix elements is to organize the matrix elements according to conserved quantum numbers.
This means setting up a block structure and to look up matrix elements using two-body conserved quantum numbers.
For quantum dots, the two-body quantum numbers that are conserved are
The total orbital momentum projection
$$
M = m_1 + m_2,
$$

and the total spin projection
$$
M_s = m_{s_1} + m_{s_2}
$$

<p>
<!-- !split  -->

<h2 id="___sec134">Two-body basis construction </h2>

<p>
For 2 shells we have

<p>
<table border="1">
<thead>
<tr><td align="center">\( M \)</td> <td align="center">\( M_s \)</td> <td align="center">\( \alpha \)</td> <th align="center">        State         </th> </tr>
</thead>
<tbody>
<tr><td align="center">   -2         </td> <td align="center">   0            </td> <td align="center">   1               </td> <td align="center">   \( \vert 3,2\rangle \)    </td> </tr>
<tr><td align="center">   -1         </td> <td align="center">   -1           </td> <td align="center">   3               </td> <td align="center">   \( \vert 2,0\rangle \)    </td> </tr>
<tr><td align="center">   -1         </td> <td align="center">   0            </td> <td align="center">   4               </td> <td align="center">   \( \vert 3,0\rangle \)    </td> </tr>
<tr><td align="center">   -1         </td> <td align="center">   0            </td> <td align="center">   4               </td> <td align="center">   \( \vert 2,1\rangle \)    </td> </tr>
<tr><td align="center">   -1         </td> <td align="center">   1            </td> <td align="center">   5               </td> <td align="center">   \( \vert 3,1\rangle \)    </td> </tr>
<tr><td align="center">   0          </td> <td align="center">   -1           </td> <td align="center">   6               </td> <td align="center">   \( \vert 4,2\rangle \)    </td> </tr>
<tr><td align="center">   0          </td> <td align="center">   0            </td> <td align="center">   7               </td> <td align="center">   \( \vert 1,0\rangle \)    </td> </tr>
<tr><td align="center">   0          </td> <td align="center">   0            </td> <td align="center">   7               </td> <td align="center">   \( \vert 5,2\rangle \)    </td> </tr>
<tr><td align="center">   0          </td> <td align="center">   0            </td> <td align="center">   7               </td> <td align="center">   \( \vert 4,3\rangle \)    </td> </tr>
<tr><td align="center">   0          </td> <td align="center">   1            </td> <td align="center">   8               </td> <td align="center">   \( \vert 5,3\rangle \)    </td> </tr>
<tr><td align="center">   1          </td> <td align="center">   -1           </td> <td align="center">   9               </td> <td align="center">   \( \vert 4,0\rangle \)    </td> </tr>
<tr><td align="center">   1          </td> <td align="center">   0            </td> <td align="center">   10              </td> <td align="center">   \( \vert 5,0\rangle \)    </td> </tr>
<tr><td align="center">   1          </td> <td align="center">   0            </td> <td align="center">   10              </td> <td align="center">   \( \vert 4,1\rangle \)    </td> </tr>
<tr><td align="center">   1          </td> <td align="center">   1            </td> <td align="center">   11              </td> <td align="center">   \( \vert 5,1\rangle \)    </td> </tr>
<tr><td align="center">   2          </td> <td align="center">   0            </td> <td align="center">   13              </td> <td align="center">   \( \vert 5,4\rangle \)    </td> </tr>
</tbody>
</table>
<p>
In this table we have paired orbitals with same \( M \) and \( M_s \). Where \( \alpha \in \{0,...,N\} \) and \( N \) is the number of pairs \( \{M,M_s\} \). Notice that for \( \alpha = 1 \) we only have one pair, and for \( \alpha = 4 \), we have two pairs.

<p>
<!-- !split  -->

<h2 id="___sec135">Hartree-Fock code </h2>
In developing our Hartree-Fock code, we can define a configuration class with the following mapping for a single-particle state
$$
  \vert \alpha\rangle \rightarrow \vert n m m_s\rangle,
$$

and a similar mapping for a two-body state
$$
  \vert \alpha \beta\rangle \rightarrow \vert M M_s\rangle,
$$

where \( M \) is the total angualar momentum 
$$
M = m_\alpha + m_\beta,
$$

and the \( M_s \) is the total spin
$$
M_s = m_{s_1} + m_{s_2}.
$$

<p>
<!-- !split  -->

<h2 id="___sec136">Hartree-Fock code, setting up tables of matrix elements  </h2>
The single-particle part is diagonal for the harmonic oscillator basis, that is
$$
\langle \alpha\vert \hat{h}_0\vert \beta\rangle = \delta_{\alpha \beta} \epsilon_\alpha
$$

with 
$$
\epsilon_\alpha  = \hbar\omega (2n_{\alpha}+\vert m_{\alpha}\vert +1).
$$

The two-body matrix elements are diagonal in the \( M \) and \( M_s \), that is
$$
  \langle M M_s\vert \hat{v}\vert M' M_s'\rangle = \delta_{M,M'}\delta_{M_s,M_s'}\langle MM_s\vert \hat{v}\vert MM_s\rangle.
$$

<p>
<!-- !split  -->

<h2 id="___sec137">Example calculations, \( N=6 \) and \( \omega =1.0 \) a.u.  </h2>

<p>
We list here some selected Hartree-Fock results for \( N=6 \) electrons as function of the number of major shells \( R \)
included. Here we have \( \omega =1 \) a.u.

<p>
<table border="1">
<thead>
<tr><td align="center">\( R \)</td> <td align="center">\( E_0^{HF} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   3          </td> <td align="center">   21.59320          </td> </tr>
<tr><td align="center">   4          </td> <td align="center">   20.76692          </td> </tr>
<tr><td align="center">   5          </td> <td align="center">   20.7484           </td> </tr>
<tr><td align="center">   6          </td> <td align="center">   20.72026          </td> </tr>
<tr><td align="center">   7          </td> <td align="center">   20.72013          </td> </tr>
<tr><td align="center">   8          </td> <td align="center">   20.71925          </td> </tr>
<tr><td align="center">   9          </td> <td align="center">   20.71925          </td> </tr>
<tr><td align="center">   10         </td> <td align="center">   20.71922          </td> </tr>
<tr><td align="center">   11         </td> <td align="center">   20.71922          </td> </tr>
<tr><td align="center">   12         </td> <td align="center">   20.71922          </td> </tr>
<tr><td align="center">   13         </td> <td align="center">   20.71922          </td> </tr>
</tbody>
</table>
<p>
The results are practically converged for approximately \( R=10-13 \).

<p>
<!-- !split  -->

<h2 id="___sec138">Example calculations, \( N=6 \) and \( \omega =0.1 \) a.u.  </h2>

<p>
We list here some selected Hartree-Fock results for \( N=6 \) electrons as function of the number of major shells \( R \)
included. Here we have \( \omega =0.1 \) a.u.

<p>
<table border="1">
<thead>
<tr><td align="center">\( R \)</td> <td align="center">\( E_0^{HF} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   4          </td> <td align="center">   4.01979           </td> </tr>
<tr><td align="center">   5          </td> <td align="center">   3.96315           </td> </tr>
<tr><td align="center">   6          </td> <td align="center">   3.87062           </td> </tr>
<tr><td align="center">   7          </td> <td align="center">   3.86314           </td> </tr>
<tr><td align="center">   8          </td> <td align="center">   3.85288           </td> </tr>
<tr><td align="center">   9          </td> <td align="center">   3.85259           </td> </tr>
<tr><td align="center">   10         </td> <td align="center">   3.85239           </td> </tr>
<tr><td align="center">   11         </td> <td align="center">   3.85239           </td> </tr>
<tr><td align="center">   12         </td> <td align="center">   3.85238           </td> </tr>
<tr><td align="center">   13         </td> <td align="center">   3.85238           </td> </tr>
</tbody>
</table>
<p>
Again, the results are practically converged for approximately \( R=10-13 \). 

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 2013-2017, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

