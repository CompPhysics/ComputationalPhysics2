<!--
Automatically generated HTML file from DocOnce source
(https://github.com/doconce/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 9 March 1-5: Resampling Techniques, Bootstrap and Blocking">

<title>Week 9 March 1-5: Resampling Techniques, Bootstrap and Blocking</title>


<style type="text/css">
/* bloodish style */

body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em;  color: #8A0808; }
h2 { font-size: 1.6em;  color: #8A0808; }
h3 { font-size: 1.4em;  color: #8A0808; }
h4 { color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Overview of week 9, March 1-5',
               2,
               None,
               'overview-of-week-9-march-1-5'),
              ('The top-down approach, part 1',
               2,
               None,
               'the-top-down-approach-part-1'),
              ('What have we done?', 2, None, 'what-have-we-done'),
              ('Code part 2', 2, None, 'code-part-2'),
              ('How do we proceed?', 2, None, 'how-do-we-proceed'),
              ('Resampling analysis', 2, None, 'resampling-analysis'),
              ('Why resampling methods ?', 2, None, 'why-resampling-methods'),
              ('Statistical analysis', 2, None, 'statistical-analysis'),
              ('Statistics', 2, None, 'statistics'),
              ('Statistics, moments', 2, None, 'statistics-moments'),
              ('Statistics, central moments',
               2,
               None,
               'statistics-central-moments'),
              ('Statistics, covariance', 2, None, 'statistics-covariance'),
              ('Statistics, more covariance',
               2,
               None,
               'statistics-more-covariance'),
              ('Statistics, independent variables',
               2,
               None,
               'statistics-independent-variables'),
              ('Statistics, more variance',
               2,
               None,
               'statistics-more-variance'),
              ('Statistics and stochastic processes',
               2,
               None,
               'statistics-and-stochastic-processes'),
              ('Statistics and sample variables',
               2,
               None,
               'statistics-and-sample-variables'),
              ('Statistics, sample variance and covariance',
               2,
               None,
               'statistics-sample-variance-and-covariance'),
              ('Statistics, law of large numbers',
               2,
               None,
               'statistics-law-of-large-numbers'),
              ('Statistics, more on sample error',
               2,
               None,
               'statistics-more-on-sample-error'),
              ('Statistics', 2, None, 'statistics'),
              ('Statistics, central limit theorem',
               2,
               None,
               'statistics-central-limit-theorem'),
              ('Statistics, more technicalities',
               2,
               None,
               'statistics-more-technicalities'),
              ('Statistics', 2, None, 'statistics'),
              ('Statistics and sample variance',
               2,
               None,
               'statistics-and-sample-variance'),
              ('Statistics, uncorrelated results',
               2,
               None,
               'statistics-uncorrelated-results'),
              ('Statistics, computations', 2, None, 'statistics-computations'),
              ('Statistics, more on computations of errors',
               2,
               None,
               'statistics-more-on-computations-of-errors')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->



<center><h1>Week 9 March 1-5: Resampling Techniques, Bootstrap and Blocking</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no -->

<center>
<b>Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Center fo Computing in Science Education, University of Oslo, Oslo, Norway</b></center>
<center>[2] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams, Michigan State University, East Lansing, Michigan, USA</b></center>
<br>
<p>
<center><h4>Mar 11, 2021</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="overview-of-week-9-march-1-5">Overview of week 9, March 1-5 </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Topics</b>
<p>

<ul>
<li> Top down approach first, what we need to code</li>
<li> Resampling Techniques and statistics: Bootstrap and Blocking</li> 
</ul>
</div>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Teaching Material, videos and written material</b>
<p>

<ul>
<li> Overview video on the <a href="https://www.youtube.com/watch?v=O_Fj4q8lgmc&ab_channel=MarinStatsLectures-RProgramming%26Statistics" target="_blank">Bootstrap method</a></li>
<li> These Lecture notes</li>
<li> <a href="https://www.duo.uio.no/bitstream/handle/10852/68360/PhysRevE.98.043304.pdf?sequence=2&isAllowed=y" target="_blank">Marius Johnson's Master thesis on the Blocking Method</a></li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="the-top-down-approach-part-1">The top-down approach, part 1 </h2>

<p>
Last week we discusse dhow to implement a gradient descent method like the simplest possible gradient descent with a simple learning rate as parameter to tune. We repeat the codes here.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #408080; font-style: italic"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span style="color: #408080; font-style: italic"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span style="color: #408080; font-style: italic"># Added energy minimization</span>
<span style="color: #408080; font-style: italic"># Common imports</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp, sqrt
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">random</span> <span style="color: #008000; font-weight: bold">import</span> random, seed, normalvariate
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.ticker</span> <span style="color: #008000; font-weight: bold">import</span> LinearLocator, FormatStrFormatter
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>



<span style="color: #408080; font-style: italic"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">WaveFunction</span>(r,alpha,beta):
    r1 <span style="color: #666666">=</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>
    r2 <span style="color: #666666">=</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> r12<span style="color: #666666">/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-0.5*</span>alpha<span style="color: #666666">*</span>(r1<span style="color: #666666">+</span>r2)<span style="color: #666666">+</span>deno)

<span style="color: #408080; font-style: italic"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">LocalEnergy</span>(r,alpha,beta):
    
    r1 <span style="color: #666666">=</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r2 <span style="color: #666666">=</span> (r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    deno2 <span style="color: #666666">=</span> deno<span style="color: #666666">*</span>deno
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.5*</span>(<span style="color: #666666">1-</span>alpha<span style="color: #666666">*</span>alpha)<span style="color: #666666">*</span>(r1 <span style="color: #666666">+</span> r2) <span style="color: #666666">+2.0*</span>alpha <span style="color: #666666">+</span> <span style="color: #666666">1.0/</span>r12<span style="color: #666666">+</span>deno2<span style="color: #666666">*</span>(alpha<span style="color: #666666">*</span>r12<span style="color: #666666">-</span>deno2<span style="color: #666666">+2*</span>beta<span style="color: #666666">*</span>deno<span style="color: #666666">-1.0/</span>r12)

<span style="color: #408080; font-style: italic"># Derivate of wave function ansatz as function of variational parameters</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">DerivativeWFansatz</span>(r,alpha,beta):
    
    WfDer  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
    r1 <span style="color: #666666">=</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r2 <span style="color: #666666">=</span> (r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    deno2 <span style="color: #666666">=</span> deno<span style="color: #666666">*</span>deno
    WfDer[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-0.5*</span>(r1<span style="color: #666666">+</span>r2)
    WfDer[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>r12<span style="color: #666666">*</span>r12<span style="color: #666666">*</span>deno2
    <span style="color: #008000; font-weight: bold">return</span>  WfDer

<span style="color: #408080; font-style: italic"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">QuantumForce</span>(r,alpha,beta):

    qforce <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    qforce[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">-2*</span>r[<span style="color: #666666">0</span>,:]<span style="color: #666666">*</span>alpha<span style="color: #666666">*</span>(r[<span style="color: #666666">0</span>,:]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,:])<span style="color: #666666">*</span>deno<span style="color: #666666">*</span>deno<span style="color: #666666">/</span>r12
    qforce[<span style="color: #666666">1</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">-2*</span>r[<span style="color: #666666">1</span>,:]<span style="color: #666666">*</span>alpha<span style="color: #666666">*</span>(r[<span style="color: #666666">1</span>,:]<span style="color: #666666">-</span>r[<span style="color: #666666">0</span>,:])<span style="color: #666666">*</span>deno<span style="color: #666666">*</span>deno<span style="color: #666666">/</span>r12
    <span style="color: #008000; font-weight: bold">return</span> qforce
    

<span style="color: #408080; font-style: italic"># Computing the derivative of the energy and the energy </span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">EnergyMinimization</span>(alpha, beta):

    NumberMCcycles<span style="color: #666666">=</span> <span style="color: #666666">10000</span>
    <span style="color: #408080; font-style: italic"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    D <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    TimeStep <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    <span style="color: #408080; font-style: italic"># positions</span>
    PositionOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    PositionNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    <span style="color: #408080; font-style: italic"># Quantum force</span>
    QuantumForceOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    QuantumForceNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)

    <span style="color: #408080; font-style: italic"># seed for rng generator </span>
    seed()
    energy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DeltaE <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    EnergyDer <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
    DeltaPsi <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
    DerivativePsiE <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
    <span style="color: #408080; font-style: italic">#Initial position</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            PositionOld[i,j] <span style="color: #666666">=</span> normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)
    wfold <span style="color: #666666">=</span> WaveFunction(PositionOld,alpha,beta)
    QuantumForceOld <span style="color: #666666">=</span> QuantumForce(PositionOld,alpha, beta)

    <span style="color: #408080; font-style: italic">#Loop over MC MCcycles</span>
    <span style="color: #008000; font-weight: bold">for</span> MCcycle <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberMCcycles):
        <span style="color: #408080; font-style: italic">#Trial position moving one particle at the time</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                PositionNew[i,j] <span style="color: #666666">=</span> PositionOld[i,j]<span style="color: #666666">+</span>normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)<span style="color: #666666">+</span>\
                                       QuantumForceOld[i,j]<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*</span>D
            wfnew <span style="color: #666666">=</span> WaveFunction(PositionNew,alpha,beta)
            QuantumForceNew <span style="color: #666666">=</span> QuantumForce(PositionNew,alpha, beta)
            GreensFunction <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                GreensFunction <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">+</span>QuantumForceNew[i,j])<span style="color: #666666">*</span>\
	                              (D<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">-</span>QuantumForceNew[i,j])<span style="color: #666666">-</span>\
                                      PositionNew[i,j]<span style="color: #666666">+</span>PositionOld[i,j])
      
            GreensFunction <span style="color: #666666">=</span> exp(GreensFunction)
            ProbabilityRatio <span style="color: #666666">=</span> GreensFunction<span style="color: #666666">*</span>wfnew<span style="color: #666666">**2/</span>wfold<span style="color: #666666">**2</span>
            <span style="color: #408080; font-style: italic">#Metropolis-Hastings test to see whether we accept the move</span>
            <span style="color: #008000; font-weight: bold">if</span> random() <span style="color: #666666">&lt;=</span> ProbabilityRatio:
                <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                    PositionOld[i,j] <span style="color: #666666">=</span> PositionNew[i,j]
                    QuantumForceOld[i,j] <span style="color: #666666">=</span> QuantumForceNew[i,j]
                wfold <span style="color: #666666">=</span> wfnew
        DeltaE <span style="color: #666666">=</span> LocalEnergy(PositionOld,alpha,beta)
        DerPsi <span style="color: #666666">=</span> DerivativeWFansatz(PositionOld,alpha,beta)
        DeltaPsi <span style="color: #666666">+=</span> DerPsi
        energy <span style="color: #666666">+=</span> DeltaE
        DerivativePsiE <span style="color: #666666">+=</span> DerPsi<span style="color: #666666">*</span>DeltaE
            
    <span style="color: #408080; font-style: italic"># We calculate mean values</span>
    energy <span style="color: #666666">/=</span> NumberMCcycles
    DerivativePsiE <span style="color: #666666">/=</span> NumberMCcycles
    DeltaPsi <span style="color: #666666">/=</span> NumberMCcycles
    EnergyDer  <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(DerivativePsiE<span style="color: #666666">-</span>DeltaPsi<span style="color: #666666">*</span>energy)
    <span style="color: #008000; font-weight: bold">return</span> energy, EnergyDer


<span style="color: #408080; font-style: italic">#Here starts the main program with variable declarations</span>
NumberParticles <span style="color: #666666">=</span> <span style="color: #666666">2</span>
Dimension <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #408080; font-style: italic"># guess for variational parameters</span>
alpha <span style="color: #666666">=</span> <span style="color: #666666">0.95</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
<span style="color: #408080; font-style: italic"># Set up iteration using stochastic gradient method</span>
Energy <span style="color: #666666">=</span> <span style="color: #666666">0</span>
EDerivative <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
<span style="color: #408080; font-style: italic"># Learning rate eta, max iterations, need to change to adaptive learning rate</span>
eta <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
MaxIterations <span style="color: #666666">=</span> <span style="color: #666666">50</span>
<span style="color: #008000">iter</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>

Energies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
EnergyDerivatives1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
EnergyDerivatives2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
AlphaValues <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
BetaValues <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)

<span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">iter</span> <span style="color: #666666">&lt;</span> MaxIterations:
    Energy, EDerivative <span style="color: #666666">=</span> EnergyMinimization(alpha,beta)
    alphagradient <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">0</span>]
    betagradient <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">1</span>]
    alpha <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>alphagradient
    beta <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>betagradient 
    Energies[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> Energy
    EnergyDerivatives1[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">0</span>] 
    EnergyDerivatives2[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">1</span>] 
    AlphaValues[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> alpha
    BetaValues[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> beta
    <span style="color: #008000">iter</span> <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic">#nice printout with Pandas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">pd</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">import</span> DataFrame
pd<span style="color: #666666">.</span>set_option(<span style="color: #BA2121">&#39;max_columns&#39;</span>, <span style="color: #666666">6</span>)
data <span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;Alpha&#39;</span>:AlphaValues,<span style="color: #BA2121">&#39;Beta&#39;</span>:BetaValues,<span style="color: #BA2121">&#39;Energy&#39;</span>:Energies,<span style="color: #BA2121">&#39;Alpha Derivative&#39;</span>:EnergyDerivatives1,<span style="color: #BA2121">&#39;Beta Derivative&#39;</span>:EnergyDerivatives2}

frame <span style="color: #666666">=</span> pd<span style="color: #666666">.</span>DataFrame(data)
<span style="color: #008000">print</span>(frame)
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="what-have-we-done">What have we done? </h2>
The exact energy is \( 3.0 \) for an oscillator frequency \( \omega =1 \)
(with \( \hbar =1 \)). We note however that with this learning rate and
number of iterations, the energies and the derivatives are not yet
converged.

<p>
We can improve upon this by using the algorithms provided by the <b>optimize</b> package in Python.
One of these algorithms is  Broyden&#8211;Fletcher&#8211;Goldfarb&#8211;Shanno (BFGS) algorithm.

<p>
The optimization problem is to minimize \( f(\mathbf {x} ) \) where
\( \mathbf {x} \) is a vector in \( R^{n} \), and \( f \) is a differentiable
scalar function. There are no constraints on the values that \( \mathbf{x} \) can take.

<p>
The algorithm begins at an initial estimate for the optimal value
\( \mathbf {x}_{0} \) and proceeds iteratively to get a better estimate at
each stage.

<p>
The search direction \( p_k \) at stage \( k \) is given by the solution of the analogue of the Newton equation

$$
B_{k}\mathbf {p} _{k}=-\nabla f(\mathbf {x}_{k}),
$$

<p>
where \( B_{k} \) is an approximation to the Hessian matrix, which is
updated iteratively at each stage, and \( \nabla f(\mathbf {x} _{k}) \)
is the gradient of the function
evaluated at \( x_k \). 
A line search in the direction \( p_k \) is then used to
find the next point \( x_{k+1} \) by minimising 
$$
f(\mathbf {x}_{k}+\alpha \mathbf {p}_{k}),
$$

over the scalar \( \alpha > 0 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="code-part-2">Code part 2 </h2>
The modified code here uses the BFGS algorithm but performs now a
production run and writes to file all average values of the
energy. 
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #408080; font-style: italic"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span style="color: #408080; font-style: italic"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span style="color: #408080; font-style: italic"># Added energy minimization</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp, sqrt
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">random</span> <span style="color: #008000; font-weight: bold">import</span> random, seed, normalvariate
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.ticker</span> <span style="color: #008000; font-weight: bold">import</span> LinearLocator, FormatStrFormatter
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.optimize</span> <span style="color: #008000; font-weight: bold">import</span> minimize
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>

<span style="color: #408080; font-style: italic"># Where to save data files</span>
PROJECT_ROOT_DIR <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Results&quot;</span>
DATA_ID <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Results/EnergyMin&quot;</span>

<span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>exists(PROJECT_ROOT_DIR):
    os<span style="color: #666666">.</span>mkdir(PROJECT_ROOT_DIR)

<span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>exists(DATA_ID):
    os<span style="color: #666666">.</span>makedirs(DATA_ID)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data_path</span>(dat_id):
    <span style="color: #008000; font-weight: bold">return</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(DATA_ID, dat_id)

outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(data_path(<span style="color: #BA2121">&quot;Energies.dat&quot;</span>),<span style="color: #BA2121">&#39;w&#39;</span>)


<span style="color: #408080; font-style: italic"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">WaveFunction</span>(r,alpha,beta):
    r1 <span style="color: #666666">=</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>
    r2 <span style="color: #666666">=</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> r12<span style="color: #666666">/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-0.5*</span>alpha<span style="color: #666666">*</span>(r1<span style="color: #666666">+</span>r2)<span style="color: #666666">+</span>deno)

<span style="color: #408080; font-style: italic"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">LocalEnergy</span>(r,alpha,beta):
    
    r1 <span style="color: #666666">=</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r2 <span style="color: #666666">=</span> (r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    deno2 <span style="color: #666666">=</span> deno<span style="color: #666666">*</span>deno
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.5*</span>(<span style="color: #666666">1-</span>alpha<span style="color: #666666">*</span>alpha)<span style="color: #666666">*</span>(r1 <span style="color: #666666">+</span> r2) <span style="color: #666666">+2.0*</span>alpha <span style="color: #666666">+</span> <span style="color: #666666">1.0/</span>r12<span style="color: #666666">+</span>deno2<span style="color: #666666">*</span>(alpha<span style="color: #666666">*</span>r12<span style="color: #666666">-</span>deno2<span style="color: #666666">+2*</span>beta<span style="color: #666666">*</span>deno<span style="color: #666666">-1.0/</span>r12)

<span style="color: #408080; font-style: italic"># Derivate of wave function ansatz as function of variational parameters</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">DerivativeWFansatz</span>(r,alpha,beta):
    
    WfDer  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>), np<span style="color: #666666">.</span>double)
    r1 <span style="color: #666666">=</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r2 <span style="color: #666666">=</span> (r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    deno2 <span style="color: #666666">=</span> deno<span style="color: #666666">*</span>deno
    WfDer[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-0.5*</span>(r1<span style="color: #666666">+</span>r2)
    WfDer[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>r12<span style="color: #666666">*</span>r12<span style="color: #666666">*</span>deno2
    <span style="color: #008000; font-weight: bold">return</span>  WfDer

<span style="color: #408080; font-style: italic"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">QuantumForce</span>(r,alpha,beta):

    qforce <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    r12 <span style="color: #666666">=</span> sqrt((r[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (r[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])<span style="color: #666666">**2</span>)
    deno <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1+</span>beta<span style="color: #666666">*</span>r12)
    qforce[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">-2*</span>r[<span style="color: #666666">0</span>,:]<span style="color: #666666">*</span>alpha<span style="color: #666666">*</span>(r[<span style="color: #666666">0</span>,:]<span style="color: #666666">-</span>r[<span style="color: #666666">1</span>,:])<span style="color: #666666">*</span>deno<span style="color: #666666">*</span>deno<span style="color: #666666">/</span>r12
    qforce[<span style="color: #666666">1</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">-2*</span>r[<span style="color: #666666">1</span>,:]<span style="color: #666666">*</span>alpha<span style="color: #666666">*</span>(r[<span style="color: #666666">1</span>,:]<span style="color: #666666">-</span>r[<span style="color: #666666">0</span>,:])<span style="color: #666666">*</span>deno<span style="color: #666666">*</span>deno<span style="color: #666666">/</span>r12
    <span style="color: #008000; font-weight: bold">return</span> qforce
    

<span style="color: #408080; font-style: italic"># Computing the derivative of the energy and the energy </span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">EnergyDerivative</span>(x0):

    
    <span style="color: #408080; font-style: italic"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    D <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    TimeStep <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    <span style="color: #408080; font-style: italic"># positions</span>
    PositionOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    PositionNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    <span style="color: #408080; font-style: italic"># Quantum force</span>
    QuantumForceOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    QuantumForceNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)

    energy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DeltaE <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    alpha <span style="color: #666666">=</span> x0[<span style="color: #666666">0</span>]
    beta <span style="color: #666666">=</span> x0[<span style="color: #666666">1</span>]
    EnergyDer <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DeltaPsi <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DerivativePsiE <span style="color: #666666">=</span> <span style="color: #666666">0.0</span> 
    <span style="color: #408080; font-style: italic">#Initial position</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            PositionOld[i,j] <span style="color: #666666">=</span> normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)
    wfold <span style="color: #666666">=</span> WaveFunction(PositionOld,alpha,beta)
    QuantumForceOld <span style="color: #666666">=</span> QuantumForce(PositionOld,alpha, beta)

    <span style="color: #408080; font-style: italic">#Loop over MC MCcycles</span>
    <span style="color: #008000; font-weight: bold">for</span> MCcycle <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberMCcycles):
        <span style="color: #408080; font-style: italic">#Trial position moving one particle at the time</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                PositionNew[i,j] <span style="color: #666666">=</span> PositionOld[i,j]<span style="color: #666666">+</span>normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)<span style="color: #666666">+</span>\
                                       QuantumForceOld[i,j]<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*</span>D
            wfnew <span style="color: #666666">=</span> WaveFunction(PositionNew,alpha,beta)
            QuantumForceNew <span style="color: #666666">=</span> QuantumForce(PositionNew,alpha, beta)
            GreensFunction <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                GreensFunction <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">+</span>QuantumForceNew[i,j])<span style="color: #666666">*</span>\
	                              (D<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">-</span>QuantumForceNew[i,j])<span style="color: #666666">-</span>\
                                      PositionNew[i,j]<span style="color: #666666">+</span>PositionOld[i,j])
      
            GreensFunction <span style="color: #666666">=</span> exp(GreensFunction)
            ProbabilityRatio <span style="color: #666666">=</span> GreensFunction<span style="color: #666666">*</span>wfnew<span style="color: #666666">**2/</span>wfold<span style="color: #666666">**2</span>
            <span style="color: #408080; font-style: italic">#Metropolis-Hastings test to see whether we accept the move</span>
            <span style="color: #008000; font-weight: bold">if</span> random() <span style="color: #666666">&lt;=</span> ProbabilityRatio:
                <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                    PositionOld[i,j] <span style="color: #666666">=</span> PositionNew[i,j]
                    QuantumForceOld[i,j] <span style="color: #666666">=</span> QuantumForceNew[i,j]
                wfold <span style="color: #666666">=</span> wfnew
        DeltaE <span style="color: #666666">=</span> LocalEnergy(PositionOld,alpha,beta)
        DerPsi <span style="color: #666666">=</span> DerivativeWFansatz(PositionOld,alpha,beta)
        DeltaPsi <span style="color: #666666">+=</span> DerPsi
        energy <span style="color: #666666">+=</span> DeltaE
        DerivativePsiE <span style="color: #666666">+=</span> DerPsi<span style="color: #666666">*</span>DeltaE
            
    <span style="color: #408080; font-style: italic"># We calculate mean values</span>
    energy <span style="color: #666666">/=</span> NumberMCcycles
    DerivativePsiE <span style="color: #666666">/=</span> NumberMCcycles
    DeltaPsi <span style="color: #666666">/=</span> NumberMCcycles
    EnergyDer  <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(DerivativePsiE<span style="color: #666666">-</span>DeltaPsi<span style="color: #666666">*</span>energy)
    <span style="color: #008000; font-weight: bold">return</span> EnergyDer


<span style="color: #408080; font-style: italic"># Computing the expectation value of the local energy </span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Energy</span>(x0):
    <span style="color: #408080; font-style: italic"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    D <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    TimeStep <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    <span style="color: #408080; font-style: italic"># positions</span>
    PositionOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    PositionNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    <span style="color: #408080; font-style: italic"># Quantum force</span>
    QuantumForceOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    QuantumForceNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)

    energy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DeltaE <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    alpha <span style="color: #666666">=</span> x0[<span style="color: #666666">0</span>]
    beta <span style="color: #666666">=</span> x0[<span style="color: #666666">1</span>]
    <span style="color: #408080; font-style: italic">#Initial position</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            PositionOld[i,j] <span style="color: #666666">=</span> normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)
    wfold <span style="color: #666666">=</span> WaveFunction(PositionOld,alpha,beta)
    QuantumForceOld <span style="color: #666666">=</span> QuantumForce(PositionOld,alpha, beta)

    <span style="color: #408080; font-style: italic">#Loop over MC MCcycles</span>
    <span style="color: #008000; font-weight: bold">for</span> MCcycle <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberMCcycles):
        <span style="color: #408080; font-style: italic">#Trial position moving one particle at the time</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                PositionNew[i,j] <span style="color: #666666">=</span> PositionOld[i,j]<span style="color: #666666">+</span>normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)<span style="color: #666666">+</span>\
                                       QuantumForceOld[i,j]<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*</span>D
            wfnew <span style="color: #666666">=</span> WaveFunction(PositionNew,alpha,beta)
            QuantumForceNew <span style="color: #666666">=</span> QuantumForce(PositionNew,alpha, beta)
            GreensFunction <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                GreensFunction <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">+</span>QuantumForceNew[i,j])<span style="color: #666666">*</span>\
	                              (D<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">-</span>QuantumForceNew[i,j])<span style="color: #666666">-</span>\
                                      PositionNew[i,j]<span style="color: #666666">+</span>PositionOld[i,j])
      
            GreensFunction <span style="color: #666666">=</span> exp(GreensFunction)
            ProbabilityRatio <span style="color: #666666">=</span> GreensFunction<span style="color: #666666">*</span>wfnew<span style="color: #666666">**2/</span>wfold<span style="color: #666666">**2</span>
            <span style="color: #408080; font-style: italic">#Metropolis-Hastings test to see whether we accept the move</span>
            <span style="color: #008000; font-weight: bold">if</span> random() <span style="color: #666666">&lt;=</span> ProbabilityRatio:
                <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                    PositionOld[i,j] <span style="color: #666666">=</span> PositionNew[i,j]
                    QuantumForceOld[i,j] <span style="color: #666666">=</span> QuantumForceNew[i,j]
                wfold <span style="color: #666666">=</span> wfnew
        DeltaE <span style="color: #666666">=</span> LocalEnergy(PositionOld,alpha,beta)
        energy <span style="color: #666666">+=</span> DeltaE
        <span style="color: #008000; font-weight: bold">if</span> Printout: 
           outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>(energy<span style="color: #666666">/</span>(MCcycle<span style="color: #666666">+1.0</span>)))            
    <span style="color: #408080; font-style: italic"># We calculate mean values</span>
    energy <span style="color: #666666">/=</span> NumberMCcycles
    <span style="color: #008000; font-weight: bold">return</span> energy

<span style="color: #408080; font-style: italic">#Here starts the main program with variable declarations</span>
NumberParticles <span style="color: #666666">=</span> <span style="color: #666666">2</span>
Dimension <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #408080; font-style: italic"># seed for rng generator </span>
seed()
<span style="color: #408080; font-style: italic"># Monte Carlo cycles for parameter optimization</span>
Printout <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
NumberMCcycles<span style="color: #666666">=</span> <span style="color: #666666">10000</span>
<span style="color: #408080; font-style: italic"># guess for variational parameters</span>
x0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0.9</span>,<span style="color: #666666">0.2</span>])
<span style="color: #408080; font-style: italic"># Using Broydens method to find optimal parameters</span>
res <span style="color: #666666">=</span> minimize(Energy, x0, method<span style="color: #666666">=</span><span style="color: #BA2121">&#39;BFGS&#39;</span>, jac<span style="color: #666666">=</span>EnergyDerivative, options<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;gtol&#39;</span>: <span style="color: #666666">1e-4</span>,<span style="color: #BA2121">&#39;disp&#39;</span>: <span style="color: #008000; font-weight: bold">True</span>})
x0 <span style="color: #666666">=</span> res<span style="color: #666666">.</span>x
<span style="color: #408080; font-style: italic"># Compute the energy again with the optimal parameters and increased number of Monte Cycles</span>
NumberMCcycles<span style="color: #666666">=</span> <span style="color: #666666">2**19</span>
Printout <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
FinalEnergy <span style="color: #666666">=</span> Energy(x0)
EResult <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([FinalEnergy,FinalEnergy])
outfile<span style="color: #666666">.</span>close()
<span style="color: #408080; font-style: italic">#nice printout with Pandas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">pd</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">import</span> DataFrame
data <span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;Optimal Parameters&#39;</span>:x0, <span style="color: #BA2121">&#39;Final Energy&#39;</span>:EResult}
frame <span style="color: #666666">=</span> pd<span style="color: #666666">.</span>DataFrame(data)
<span style="color: #008000">print</span>(frame)
</pre></div>
<p>
Note that the <b>minimize</b> function returns the final values for the
variable \( \alpha=x0[0] \) and \( \beta=x0[1] \) in the array \( x \).

<p>
When we have found the minimum, we use these optimal parameters to perform a production run of energies.
The output is in turn written to file and is used, together with resampling methods like the <b>blocking method</b>,
to obtain the best possible estimate for the standard deviation.   The optimal minimum is, even with our guess, rather close to the exact value of \( 3.0 \) a.u.

<p>
The <a href="https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/Resampling" target="_blank">sampling
functions</a>
can be used to perform both a blocking analysis, or a standard
bootstrap and jackknife analysis.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="how-do-we-proceed">How do we proceed? </h2>

<p>
There are several paths which can be chosen. One is to extend the
brute force gradient descent method with an adapative stochastic
gradient. There are several examples of this. A recent approach based
on <a href="https://arxiv.org/pdf/1805.09416.pdf" target="_blank">the Langevin equations</a>
seems like a promising approach for general and possibly non-convex
optimization problems.

<p>
Here we would like to point out that our next step is now to use the
optimal values for our variational parameters and use these as inputs
to a production run. Here we would output values of the energy and
perform for example a blocking analysis of the results in order to get
a best possible estimate of the standard deviation.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="resampling-analysis">Resampling analysis </h2>

<p>
The next step is then to use the above data sets and perform a
resampling analysis, either using say the Bootstrap method or the
Blocking method. Since the data will be correlated, we would recommend
to use the non-iid Bootstrap code here. The theoretical background for these resampling methods is found in the <a href="http://compphysics.github.io/ComputationalPhysics2/doc/pub/statanalysis/html/statanalysis.html" target="_blank">statistical analysis lecture notes</a>

<p>
Here we have tailored the codes to the output file from the previous example. We present first the bootstrap resampling with non-iid stochastic event.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #408080; font-style: italic"># Common imports</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>

<span style="color: #408080; font-style: italic"># Where to save the figures and data files</span>
DATA_ID <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Results/EnergyMin&quot;</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data_path</span>(dat_id):
    <span style="color: #008000; font-weight: bold">return</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(DATA_ID, dat_id)

infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(data_path(<span style="color: #BA2121">&quot;Energies.dat&quot;</span>),<span style="color: #BA2121">&#39;r&#39;</span>)

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> std, mean, concatenate, arange, loadtxt, zeros, ceil
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.random</span> <span style="color: #008000; font-weight: bold">import</span> randint
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">time</span> <span style="color: #008000; font-weight: bold">import</span> time


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tsboot</span>(data,statistic,R,l):
    t <span style="color: #666666">=</span> zeros(R); n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(data); k <span style="color: #666666">=</span> <span style="color: #008000">int</span>(ceil(<span style="color: #008000">float</span>(n)<span style="color: #666666">/</span>l));
    inds <span style="color: #666666">=</span> arange(n); t0 <span style="color: #666666">=</span> time()
    
    <span style="color: #408080; font-style: italic"># time series bootstrap</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(R):
        <span style="color: #408080; font-style: italic"># construct bootstrap sample from</span>
        <span style="color: #408080; font-style: italic"># k chunks of data. The chunksize is l</span>
        _data <span style="color: #666666">=</span> concatenate([data[j:j<span style="color: #666666">+</span>l] <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> randint(<span style="color: #666666">0</span>,n<span style="color: #666666">-</span>l,k)])[<span style="color: #666666">0</span>:n];
        t[i] <span style="color: #666666">=</span> statistic(_data)

    <span style="color: #408080; font-style: italic"># analysis</span>
    <span style="color: #008000">print</span> (<span style="color: #BA2121">&quot;Runtime: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> sec&quot;</span> <span style="color: #666666">%</span> (time()<span style="color: #666666">-</span>t0)); <span style="color: #008000">print</span> (<span style="color: #BA2121">&quot;Bootstrap Statistics :&quot;</span>)
    <span style="color: #008000">print</span> (<span style="color: #BA2121">&quot;original           bias      std. error&quot;</span>)
    <span style="color: #008000">print</span> (<span style="color: #BA2121">&quot;</span><span style="color: #BB6688; font-weight: bold">%8g</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%14g</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%15g</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">%</span> (statistic(data), \
                             mean(t) <span style="color: #666666">-</span> statistic(data), \
                             std(t) ))
    <span style="color: #008000; font-weight: bold">return</span> t
<span style="color: #408080; font-style: italic"># Read in data</span>
X <span style="color: #666666">=</span> loadtxt(infile)
<span style="color: #408080; font-style: italic"># statistic to be estimated. Takes two args.</span>
<span style="color: #408080; font-style: italic"># arg1: the data</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">stat</span>(data):
    <span style="color: #008000; font-weight: bold">return</span> mean(data)
t <span style="color: #666666">=</span> tsboot(X, stat, <span style="color: #666666">2**12</span>, <span style="color: #666666">2**10</span>)
</pre></div>
<p>
The blocking code, based on the article of <a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.98.043304" target="_blank">Marius Jonsson</a> is given here

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #408080; font-style: italic"># Common imports</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>

<span style="color: #408080; font-style: italic"># Where to save the figures and data files</span>
DATA_ID <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Results/EnergyMin&quot;</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data_path</span>(dat_id):
    <span style="color: #008000; font-weight: bold">return</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(DATA_ID, dat_id)

infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(data_path(<span style="color: #BA2121">&quot;Energies.dat&quot;</span>),<span style="color: #BA2121">&#39;r&#39;</span>)

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log2, zeros, mean, var, <span style="color: #008000">sum</span>, loadtxt, arange, array, cumsum, dot, transpose, diagonal, sqrt
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.linalg</span> <span style="color: #008000; font-weight: bold">import</span> inv

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">block</span>(x):
    <span style="color: #408080; font-style: italic"># preliminaries</span>
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x)
    d <span style="color: #666666">=</span> <span style="color: #008000">int</span>(log2(n))
    s, gamma <span style="color: #666666">=</span> zeros(d), zeros(d)
    mu <span style="color: #666666">=</span> mean(x)

    <span style="color: #408080; font-style: italic"># estimate the auto-covariance and variances </span>
    <span style="color: #408080; font-style: italic"># for each blocking transformation</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> arange(<span style="color: #666666">0</span>,d):
        n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x)
        <span style="color: #408080; font-style: italic"># estimate autocovariance of x</span>
        gamma[i] <span style="color: #666666">=</span> (n)<span style="color: #666666">**</span>(<span style="color: #666666">-1</span>)<span style="color: #666666">*</span><span style="color: #008000">sum</span>( (x[<span style="color: #666666">0</span>:(n<span style="color: #666666">-1</span>)]<span style="color: #666666">-</span>mu)<span style="color: #666666">*</span>(x[<span style="color: #666666">1</span>:n]<span style="color: #666666">-</span>mu) )
        <span style="color: #408080; font-style: italic"># estimate variance of x</span>
        s[i] <span style="color: #666666">=</span> var(x)
        <span style="color: #408080; font-style: italic"># perform blocking transformation</span>
        x <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(x[<span style="color: #666666">0</span>::<span style="color: #666666">2</span>] <span style="color: #666666">+</span> x[<span style="color: #666666">1</span>::<span style="color: #666666">2</span>])
   
    <span style="color: #408080; font-style: italic"># generate the test observator M_k from the theorem</span>
    M <span style="color: #666666">=</span> (cumsum( ((gamma<span style="color: #666666">/</span>s)<span style="color: #666666">**2*2**</span>arange(<span style="color: #666666">1</span>,d<span style="color: #666666">+1</span>)[::<span style="color: #666666">-1</span>])[::<span style="color: #666666">-1</span>] )  )[::<span style="color: #666666">-1</span>]

    <span style="color: #408080; font-style: italic"># we need a list of magic numbers</span>
    q <span style="color: #666666">=</span>array([<span style="color: #666666">6.634897</span>,<span style="color: #666666">9.210340</span>, <span style="color: #666666">11.344867</span>, <span style="color: #666666">13.276704</span>, <span style="color: #666666">15.086272</span>, <span style="color: #666666">16.811894</span>, <span style="color: #666666">18.475307</span>, <span style="color: #666666">20.090235</span>, <span style="color: #666666">21.665994</span>, <span style="color: #666666">23.209251</span>, <span style="color: #666666">24.724970</span>, <span style="color: #666666">26.216967</span>, <span style="color: #666666">27.688250</span>, <span style="color: #666666">29.141238</span>, <span style="color: #666666">30.577914</span>, <span style="color: #666666">31.999927</span>, <span style="color: #666666">33.408664</span>, <span style="color: #666666">34.805306</span>, <span style="color: #666666">36.190869</span>, <span style="color: #666666">37.566235</span>, <span style="color: #666666">38.932173</span>, <span style="color: #666666">40.289360</span>, <span style="color: #666666">41.638398</span>, <span style="color: #666666">42.979820</span>, <span style="color: #666666">44.314105</span>, <span style="color: #666666">45.641683</span>, <span style="color: #666666">46.962942</span>, <span style="color: #666666">48.278236</span>, <span style="color: #666666">49.587884</span>, <span style="color: #666666">50.892181</span>])

    <span style="color: #408080; font-style: italic"># use magic to determine when we should have stopped blocking</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> arange(<span style="color: #666666">0</span>,d):
        <span style="color: #008000; font-weight: bold">if</span>(M[k] <span style="color: #666666">&lt;</span> q[k]):
            <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">if</span> (k <span style="color: #666666">&gt;=</span> d<span style="color: #666666">-1</span>):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Warning: Use more data&quot;</span>)
    <span style="color: #008000; font-weight: bold">return</span> mu, s[k]<span style="color: #666666">/2**</span>(d<span style="color: #666666">-</span>k)


x <span style="color: #666666">=</span> loadtxt(infile)
(mean, var) <span style="color: #666666">=</span> block(x) 
std <span style="color: #666666">=</span> sqrt(var)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">pd</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">import</span> DataFrame
data <span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;Mean&#39;</span>:[mean], <span style="color: #BA2121">&#39;STDev&#39;</span>:[std]}
frame <span style="color: #666666">=</span> pd<span style="color: #666666">.</span>DataFrame(data,index<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;Values&#39;</span>])
<span style="color: #008000">print</span>(frame)
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="why-resampling-methods">Why resampling methods ? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Statistical analysis</b>
<p>

<ul>
    <li> Our simulations can be treated as <em>computer experiments</em>. This is particularly the case for Monte Carlo methods</li>
    <li> The results can be analysed with the same statistical tools as we would use analysing experimental data.</li>
    <li> As in all experiments, we are looking for expectation values and an estimate of how accurate they are, i.e., possible sources for errors.</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistical-analysis">Statistical analysis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<ul>
    <li> As in other experiments, many numerical  experiments have two classes of errors:</li>

<ul>
      <li> Statistical errors</li>
      <li> Systematical errors</li>
</ul>

    <li> Statistical errors can be estimated using standard tools from statistics</li>
    <li> Systematical errors are method specific and must be treated differently from case to case.</li> 
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics">Statistics  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The <em>probability distribution function (PDF)</em> is a function
\( p(x) \) on the domain which, in the discrete case, gives us the
probability or relative frequency with which these values of \( X \) occur:
$$
p(x) = \mathrm{prob}(X=x)
$$

In the continuous case, the PDF does not directly depict the
actual probability. Instead we define the probability for the
stochastic variable to assume any value on an infinitesimal interval
around \( x \) to be \( p(x)dx \). The continuous function \( p(x) \) then gives us
the <em>density</em> of the probability rather than the probability
itself. The probability for a stochastic variable to assume any value
on a non-infinitesimal interval \( [a,\,b] \) is then just the integral:
$$
\mathrm{prob}(a\leq X\leq b) = \int_a^b p(x)dx
$$

Qualitatively speaking, a stochastic variable represents the values of
numbers chosen as if by chance from some specified PDF so that the
selection of a large set of these numbers reproduces this PDF.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-moments">Statistics, moments </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A particularly useful class of special expectation values are the
<em>moments</em>. The \( n \)-th moment of the PDF \( p \) is defined as
follows:
$$
\langle x^n\rangle \equiv \int\! x^n p(x)\,dx
$$

The zero-th moment \( \langle 1\rangle \) is just the normalization condition of
\( p \). The first moment, \( \langle x\rangle \), is called the <em>mean</em> of \( p \)
and often denoted by the letter \( \mu \):
$$
\langle x\rangle = \mu \equiv \int\! x p(x)\,dx
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-central-moments">Statistics, central moments </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A special version of the moments is the set of <em>central moments</em>,
the n-th central moment defined as:
$$
\langle (x-\langle x \rangle )^n\rangle \equiv \int\! (x-\langle x\rangle)^n p(x)\,dx
$$

The zero-th and first central moments are both trivial, equal \( 1 \) and
\( 0 \), respectively. But the second central moment, known as the
<em>variance</em> of \( p \), is of particular interest. For the stochastic
variable \( X \), the variance is denoted as \( \sigma^2_X \) or \( \mathrm{var}(X) \):
$$
\begin{align}
\sigma^2_X\ \ =\ \ \mathrm{var}(X) & =  \langle (x-\langle x\rangle)^2\rangle =
\int\! (x-\langle x\rangle)^2 p(x)\,dx
\label{_auto1}\\
& =  \int\! \left(x^2 - 2 x \langle x\rangle^{2} +
  \langle x\rangle^2\right)p(x)\,dx
\label{_auto2}\\
& =  \langle x^2\rangle - 2 \langle x\rangle\langle x\rangle + \langle x\rangle^2
\label{_auto3}\\
& =  \langle x^2\rangle - \langle x\rangle^2
\label{_auto4}
\end{align}
$$

The square root of the variance, \( \sigma =\sqrt{\langle (x-\langle x\rangle)^2\rangle} \) is called the <em>standard deviation</em> of \( p \). It is clearly just the RMS (root-mean-square)
value of the deviation of the PDF from its mean value, interpreted
qualitatively as the <em>spread</em> of \( p \) around its mean.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-covariance">Statistics, covariance </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Another important quantity is the so called covariance, a variant of
the above defined variance. Consider again the set \( \{X_i\} \) of \( n \)
stochastic variables (not necessarily uncorrelated) with the
multivariate PDF \( P(x_1,\dots,x_n) \). The <em>covariance</em> of two
of the stochastic variables, \( X_i \) and \( X_j \), is defined as follows:
$$
\begin{align}
\mathrm{cov}(X_i,\,X_j) &\equiv \langle (x_i-\langle x_i\rangle)(x_j-\langle x_j\rangle)\rangle
\nonumber\\
&=
\int\!\cdots\!\int\!(x_i-\langle x_i \rangle)(x_j-\langle x_j \rangle)\,
P(x_1,\dots,x_n)\,dx_1\dots dx_n
\label{eq:def_covariance}
\end{align}
$$

with
$$
\langle x_i\rangle =
\int\!\cdots\!\int\!x_i\,P(x_1,\dots,x_n)\,dx_1\dots dx_n
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-more-covariance">Statistics, more covariance  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we consider the above covariance as a matrix \( C_{ij}=\mathrm{cov}(X_i,\,X_j) \), then the diagonal elements are just the familiar
variances, \( C_{ii} = \mathrm{cov}(X_i,\,X_i) = \mathrm{var}(X_i) \). It turns out that
all the off-diagonal elements are zero if the stochastic variables are
uncorrelated. This is easy to show, keeping in mind the linearity of
the expectation value. Consider the stochastic variables \( X_i \) and
\( X_j \), (\( i\neq j \)):
$$
\begin{align}
\mathrm{cov}(X_i,\,X_j) &= \langle(x_i-\langle x_i\rangle)(x_j-\langle x_j\rangle)\rangle
\label{_auto5}\\
&=\langle x_i x_j - x_i\langle x_j\rangle - \langle x_i\rangle x_j + \langle x_i\rangle\langle x_j\rangle\rangle 
\label{_auto6}\\
&=\langle x_i x_j\rangle - \langle x_i\langle x_j\rangle\rangle - \langle \langle x_i\rangle x_j\rangle +
\langle \langle x_i\rangle\langle x_j\rangle\rangle
\label{_auto7}\\
&=\langle x_i x_j\rangle - \langle x_i\rangle\langle x_j\rangle - \langle x_i\rangle\langle x_j\rangle +
\langle x_i\rangle\langle x_j\rangle
\label{_auto8}\\
&=\langle x_i x_j\rangle - \langle x_i\rangle\langle x_j\rangle
\label{_auto9}
\end{align}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-independent-variables">Statistics, independent variables  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If \( X_i \) and \( X_j \) are independent, we get 
\( \langle x_i x_j\rangle =\langle x_i\rangle\langle x_j\rangle \), resulting in \( \mathrm{cov}(X_i, X_j) = 0\ \ (i\neq j) \).

<p>
Also useful for us is the covariance of linear combinations of
stochastic variables. Let \( \{X_i\} \) and \( \{Y_i\} \) be two sets of
stochastic variables. Let also \( \{a_i\} \) and \( \{b_i\} \) be two sets of
scalars. Consider the linear combination:
$$
U = \sum_i a_i X_i \qquad V = \sum_j b_j Y_j
$$

By the linearity of the expectation value
$$
\mathrm{cov}(U, V) = \sum_{i,j}a_i b_j \mathrm{cov}(X_i, Y_j)
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-more-variance">Statistics, more variance  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Now, since the variance is just \( \mathrm{var}(X_i) = \mathrm{cov}(X_i, X_i) \), we get
the variance of the linear combination \( U = \sum_i a_i X_i \):
$$
\begin{equation}
\mathrm{var}(U) = \sum_{i,j}a_i a_j \mathrm{cov}(X_i, X_j)
\label{eq:variance_linear_combination}
\end{equation}
$$

And in the special case when the stochastic variables are
uncorrelated, the off-diagonal elements of the covariance are as we
know zero, resulting in:
$$
\mathrm{var}(U) = \sum_i a_i^2 \mathrm{cov}(X_i, X_i) = \sum_i a_i^2 \mathrm{var}(X_i)
$$

$$
\mathrm{var}(\sum_i a_i X_i) = \sum_i a_i^2 \mathrm{var}(X_i)
$$

which will become very useful in our study of the error in the mean
value of a set of measurements.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-and-stochastic-processes">Statistics and stochastic processes  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A <em>stochastic process</em> is a process that produces sequentially a
chain of values:
$$
\{x_1, x_2,\dots\,x_k,\dots\}.
$$

We will call these
values our <em>measurements</em> and the entire set as our measured
<em>sample</em>.  The action of measuring all the elements of a sample
we will call a stochastic <em>experiment</em> since, operationally,
they are often associated with results of empirical observation of
some physical or mathematical phenomena; precisely an experiment. We
assume that these values are distributed according to some 
PDF \( p_X^{\phantom X}(x) \), where \( X \) is just the formal symbol for the
stochastic variable whose PDF is \( p_X^{\phantom X}(x) \). Instead of
trying to determine the full distribution \( p \) we are often only
interested in finding the few lowest moments, like the mean
\( \mu_X^{\phantom X} \) and the variance \( \sigma_X^{\phantom X} \).
</div>


<p>
<!-- !split  -->

<h2 id="statistics-and-sample-variables">Statistics and sample variables  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In practical situations a sample is always of finite size. Let that
size be \( n \). The expectation value of a sample, the <em>sample mean</em>, is then defined as follows:
$$
\bar{x}_n \equiv \frac{1}{n}\sum_{k=1}^n x_k
$$

The <em>sample variance</em> is:
$$
\mathrm{var}(x) \equiv \frac{1}{n}\sum_{k=1}^n (x_k - \bar{x}_n)^2
$$

its square root being the <em>standard deviation of the sample</em>. The
<em>sample covariance</em> is:
$$
\mathrm{cov}(x)\equiv\frac{1}{n}\sum_{kl}(x_k - \bar{x}_n)(x_l - \bar{x}_n)
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-sample-variance-and-covariance">Statistics, sample variance and covariance </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Note that the sample variance is the sample covariance without the
cross terms. In a similar manner as the covariance in Eq.&nbsp;\eqref{eq:def_covariance} is a measure of the correlation between
two stochastic variables, the above defined sample covariance is a
measure of the sequential correlation between succeeding measurements
of a sample.

<p>
These quantities, being known experimental values, differ
significantly from and must not be confused with the similarly named
quantities for stochastic variables, mean \( \mu_X \), variance \( \mathrm{var}(X) \)
and covariance \( \mathrm{cov}(X,Y) \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-law-of-large-numbers">Statistics, law of large numbers </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The law of large numbers
states that as the size of our sample grows to infinity, the sample
mean approaches the true mean \( \mu_X^{\phantom X} \) of the chosen PDF:
$$
\lim_{n\to\infty}\bar{x}_n = \mu_X^{\phantom X}
$$

The sample mean \( \bar{x}_n \) works therefore as an estimate of the true
mean \( \mu_X^{\phantom X} \).

<p>
What we need to find out is how good an approximation \( \bar{x}_n \) is to
\( \mu_X^{\phantom X} \). In any stochastic measurement, an estimated
mean is of no use to us without a measure of its error. A quantity
that tells us how well we can reproduce it in another experiment. We
are therefore interested in the PDF of the sample mean itself. Its
standard deviation will be a measure of the spread of sample means,
and we will simply call it the <em>error</em> of the sample mean, or
just sample error, and denote it by \( \mathrm{err}_X^{\phantom X} \). In
practice, we will only be able to produce an <em>estimate</em> of the
sample error since the exact value would require the knowledge of the
true PDFs behind, which we usually do not have.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-more-on-sample-error">Statistics, more on sample error </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Let us first take a look at what happens to the sample error as the
size of the sample grows. In a sample, each of the measurements \( x_i \)
can be associated with its own stochastic variable \( X_i \). The
stochastic variable \( \overline X_n \) for the sample mean \( \bar{x}_n \) is
then just a linear combination, already familiar to us:
$$
\overline X_n = \frac{1}{n}\sum_{i=1}^n X_i
$$

All the coefficients are just equal \( 1/n \). The PDF of \( \overline X_n \),
denoted by \( p_{\overline X_n}(x) \) is the desired PDF of the sample
means.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics">Statistics  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The probability density of obtaining a sample mean \( \bar x_n \)
is the product of probabilities of obtaining arbitrary values \( x_1,
x_2,\dots,x_n \) with the constraint that the mean of the set \( \{x_i\} \)
is \( \bar x_n \):
$$
p_{\overline X_n}(x) = \int p_X^{\phantom X}(x_1)\cdots
\int p_X^{\phantom X}(x_n)\ 
\delta\!\left(x - \frac{x_1+x_2+\dots+x_n}{n}\right)dx_n \cdots dx_1
$$

And in particular we are interested in its variance \( \mathrm{var}(\overline X_n) \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-central-limit-theorem">Statistics, central limit theorem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
It is generally not possible to express \( p_{\overline X_n}(x) \) in a
closed form given an arbitrary PDF \( p_X^{\phantom X} \) and a number
\( n \). But for the limit \( n\to\infty \) it is possible to make an
approximation. The very important result is called <em>the central limit theorem</em>. It tells us that as \( n \) goes to infinity,
\( p_{\overline X_n}(x) \) approaches a Gaussian distribution whose mean
and variance equal the true mean and variance, \( \mu_{X}^{\phantom X} \)
and \( \sigma_{X}^{2} \), respectively:
$$
\begin{equation}
\lim_{n\to\infty} p_{\overline X_n}(x) =
\left(\frac{n}{2\pi\mathrm{var}(X)}\right)^{1/2}
e^{-\frac{n(x-\bar x_n)^2}{2\mathrm{var}(X)}}
\label{eq:central_limit_gaussian}
\end{equation}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-more-technicalities">Statistics, more technicalities  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The desired variance
\( \mathrm{var}(\overline X_n) \), i.e. the sample error squared
\( \mathrm{err}_X^2 \), is given by:
$$
\begin{equation}
\mathrm{err}_X^2 = \mathrm{var}(\overline X_n) = \frac{1}{n^2}
\sum_{ij} \mathrm{cov}(X_i, X_j)
\label{eq:error_exact}
\end{equation}
$$

We see now that in order to calculate the exact error of the sample
with the above expression, we would need the true means
\( \mu_{X_i}^{\phantom X} \) of the stochastic variables \( X_i \). To
calculate these requires that we know the true multivariate PDF of all
the \( X_i \). But this PDF is unknown to us, we have only got the measurements of
one sample. The best we can do is to let the sample itself be an
estimate of the PDF of each of the \( X_i \), estimating all properties of
\( X_i \) through the measurements of the sample.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics">Statistics </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Our estimate of \( \mu_{X_i}^{\phantom X} \) is then the sample mean \( \bar x \)
itself, in accordance with the the central limit theorem:
$$
\mu_{X_i}^{\phantom X} = \langle x_i\rangle \approx \frac{1}{n}\sum_{k=1}^n x_k = \bar x
$$

Using \( \bar x \) in place of \( \mu_{X_i}^{\phantom X} \) we can give an
<em>estimate</em> of the covariance in Eq.&nbsp;\eqref{eq:error_exact}
$$
\mathrm{cov}(X_i, X_j) = \langle (x_i-\langle x_i\rangle)(x_j-\langle x_j\rangle)\rangle
\approx\langle (x_i - \bar x)(x_j - \bar{x})\rangle,
$$

resulting in
$$ 
\frac{1}{n} \sum_{l}^n \left(\frac{1}{n}\sum_{k}^n (x_k -\bar x_n)(x_l - \bar x_n)\right)=\frac{1}{n}\frac{1}{n} \sum_{kl} (x_k -\bar x_n)(x_l - \bar x_n)=\frac{1}{n}\mathrm{cov}(x)
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-and-sample-variance">Statistics and sample variance  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
By the same procedure we can use the sample variance as an
estimate of the variance of any of the stochastic variables \( X_i \)
$$
\mathrm{var}(X_i)=\langle x_i - \langle x_i\rangle\rangle \approx \langle x_i - \bar x_n\rangle\nonumber,
$$

which is approximated as 
$$
\begin{equation}
\mathrm{var}(X_i)\approx \frac{1}{n}\sum_{k=1}^n (x_k - \bar x_n)=\mathrm{var}(x)
\label{eq:var_estimate_i_think}
\end{equation}
$$

<p>
Now we can calculate an estimate of the error
\( \mathrm{err}_X^{\phantom X} \) of the sample mean \( \bar x_n \):
$$
\begin{align}
\mathrm{err}_X^2
&=\frac{1}{n^2}\sum_{ij} \mathrm{cov}(X_i, X_j) \nonumber \\
&\approx&\frac{1}{n^2}\sum_{ij}\frac{1}{n}\mathrm{cov}(x) =\frac{1}{n^2}n^2\frac{1}{n}\mathrm{cov}(x)\nonumber\\
&=\frac{1}{n}\mathrm{cov}(x)
\label{eq:error_estimate}
\end{align}
$$

which is nothing but the sample covariance divided by the number of
measurements in the sample.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-uncorrelated-results">Statistics, uncorrelated results </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
In the special case that the measurements of the sample are
uncorrelated (equivalently the stochastic variables \( X_i \) are
uncorrelated) we have that the off-diagonal elements of the covariance
are zero. This gives the following estimate of the sample error:
$$
\mathrm{err}_X^2=\frac{1}{n^2}\sum_{ij} \mathrm{cov}(X_i, X_j) =
\frac{1}{n^2} \sum_i \mathrm{var}(X_i),
$$

resulting in
$$
\begin{equation}
\mathrm{err}_X^2\approx \frac{1}{n^2} \sum_i \mathrm{var}(x)= \frac{1}{n}\mathrm{var}(x)
\label{eq:error_estimate_uncorrel}
\end{equation}
$$

where in the second step we have used Eq.&nbsp;\eqref{eq:var_estimate_i_think}.
The error of the sample is then just its standard deviation divided by
the square root of the number of measurements the sample contains.
This is a very useful formula which is easy to compute. It acts as a
first approximation to the error, but in numerical experiments, we
cannot overlook the always present correlations.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-computations">Statistics, computations </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
For computational purposes one usually splits up the estimate of
\( \mathrm{err}_X^2 \), given by Eq.&nbsp;\eqref{eq:error_estimate}, into two
parts
$$
\mathrm{err}_X^2 = \frac{1}{n}\mathrm{var}(x) + \frac{1}{n}(\mathrm{cov}(x)-\mathrm{var}(x)),
$$

which equals
$$
\begin{equation}
\frac{1}{n^2}\sum_{k=1}^n (x_k - \bar x_n)^2 +\frac{2}{n^2}\sum_{k < l} (x_k - \bar x_n)(x_l - \bar x_n)
\label{eq:error_estimate_split_up}
\end{equation}
$$

The first term is the same as the error in the uncorrelated case,
Eq.&nbsp;\eqref{eq:error_estimate_uncorrel}. This means that the second
term accounts for the error correction due to correlation between the
measurements. For uncorrelated measurements this second term is zero.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="statistics-more-on-computations-of-errors">Statistics, more on computations of errors </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Computationally the uncorrelated first term is much easier to treat
efficiently than the second.
$$
\mathrm{var}(x) = \frac{1}{n}\sum_{k=1}^n (x_k - \bar x_n)^2 =
\left(\frac{1}{n}\sum_{k=1}^n x_k^2\right) - \bar x_n^2
$$

We just accumulate separately the values \( x^2 \) and \( x \) for every
measurement \( x \) we receive. The correlation term, though, has to be
calculated at the end of the experiment since we need all the
measurements to calculate the cross terms. Therefore, all measurements
have to be stored throughout the experiment.
</div>


<p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2021, Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

