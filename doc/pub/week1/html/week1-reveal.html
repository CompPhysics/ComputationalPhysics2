<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week1-reveal.html week1-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 4 January 23-27: Introduction to the course and start Variational Monte Carlo">
<title>Week 4 January 23-27: Introduction to the course and start Variational Monte Carlo</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">Week 4 January 23-27: Introduction to the course and start Variational Monte Carlo</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no -->
<center>
<b>Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Center fo Computing in Science Education, University of Oslo, Oslo, Norway</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams, Michigan State University, East Lansing, Michigan, USA</b>
</center>
<br>
<center>
<h4>Jan 26, 2023</h4>
</center> <!-- date -->
<br>


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2023, Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>

<section>
<h2 id="overview-of-week-4">Overview of week 4 </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Topics</b>
<p>
<ul>
<p><li> Introduction to the course and overview of topics to be covered</li>
<p><li> Introduction to Variational Monte Carlo methods, Metropolis Algorithm, statistics and Markov Chain theory</li>
<p><li> C++ and python programming</li>
</ul>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>Teaching Material, videos and written material</b>
<p>
<ul>
<p><li> Asynchronuous vidoes</li>
<p><li> Lecture notes and reading assignments</li>
<p><li> Additional (often recommended) background material</li> 
</ul>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>Teaching Material, videos and written material (to be uploaded after lecture)</b>
<p>
<ul>
<p><li> <a href="https://youtu.be/2wg5rDJ7bek" target="_blank">Video of lecture with subtitles</a></li>
<p><li> <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/HandWrittenNotes/2023/NotesJan26.pdf" target="_blank">Handwritten notes</a></li>
<p><li> See also <a href="http://compphysics.github.io/ComputationalPhysics/doc/pub/rw/html/rw-bs.html" target="_blank">Lectures from FYS3150/4150 on the Metropolis Algorithm</a></li>
</ul>
</div>
</section>

<section>
<h2 id="textbook">Textbook </h2>

<p>There are no unique textbooks which cover the material to be
discussed. For each week however, we will, in addition to our own
lecture notes, send links to additional literature. This can be
articles or chapters from other textbooks.  A useful textbook is
however
</p>

<ul>
<p><li> <a href="https://www.worldscientific.com/worldscibooks/10.1142/5602" target="_blank">Bernd A. Berg, <em>Markov Chain Monte Carlo Simulations and their Statistical Analysis</em>, World Scientific, 2004</a>, chapters 1, 2</li>
</ul>
<p>
<p>This book has its main focus on spin-models, but many of the concepts
are general. Chapters 1 and 2 contain a good discussion of the
statistical foundation.
</p>
</section>

<section>
<h2 id="aims">Aims </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> Be able to apply central many-particle methods like the Variational Monte Carlo method to properties of many-fermion systems and many-boson systems.</li>
<p><li> Understand how to simulate quantum mechanical systems with many interacting particles. The methods are relevant for atomic, molecular, condensed matter physics, materials science, nanotechnology, quantum chemistry  and nuclear physics.</li> 
<p><li> Learn to manage and structure larger projects, with unit tests, object orientation and writing clean code</li>
<p><li> Learn about a proper statistical analysis of large data sets</li>
<p><li> Learn to optimize with convex optimization methods functions that depend on many variables.</li>
<p><li> Parallelization and code optimizations</li>
<p><li> Depending on interests, the second project can focus on different topics. These can be <b>quantum computing for studies of quantum mechanical problems</b>, machine learning for solving quantum-mechanical problems, quantum machine learning and many-body methods like coupled cluster theory, Hartree-Fock theory and other.</li> 
</ul>
</div>
</section>

<section>
<h2 id="lectures-and-computerlab">Lectures and ComputerLab </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>

<p><li> Lectures: Thursday (2.15pm-4pm). First time January 26. Last lecture session May 18 (can be changed).</li>

<p><li> Computerlab: Thursday (4.15pm-7pm), first time January 26, last lab session May 18 (can be changed).</li>

<p><li> Weekly plans and all other information are on the webpage of the course</li>

<p><li> <b>First project to be handed in March 31</b>.</li>

<p><li> <b>Second and final project to be handed in June 1.</b></li>

<p><li> There is no final exam, only project work.</li>
</ul>
</div>
</section>

<section>
<h2 id="course-format">Course Format </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>

<p><li> Two  compulsory projects. Electronic reports only. You are free to choose your format. We use canvas.uio.no to hand in the projects.</li>

<p><li> Evaluation and grading: The two  projects count 1/2 each of the final mark. No exam.</li>

<p><li> The computer lab (room F&#216;397 in the Physics building) has no PCs, so please bring your own laptops. C/C++ and Python are the default programming language, but programming languages like Fortran2008, Rust, Julia and other can  also be used. All source codes discussed during the lectures can be found at the webpage of the course.</li> 
</ul>
</div>
</section>

<section>
<h2 id="topics-covered-in-this-course">Topics covered in this course </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>

<p><li> Parallelization (MPI and OpenMP), high-performance computing topics. Choose between Python, Fortran2008 and/or C++ as programming languages.</li>

<p><li> Algorithms for Monte Carlo Simulations (multidimensional integrals), Metropolis-Hastings and importance sampling algorithms.  Improved Monte Carlo methods.</li>

<p><li> Statistical analysis of data  from Monte Carlo calculations, bootstrapping, jackknife and blocking methods.</li>

<p><li> Eigenvalue solvers</li>

<p><li> For project 2 there are several possibilities
<ol type="a"></li>

<p><li> Variational Monte Carlo for fermions</li>

<p><li> Hartree-Fock theory for fermions</li>

<p><li> Coupled cluster theory for fermions (iterative methods)</li>

<p><li> Neural networks and Machine Learning to solve the same problems as in project 1</li>

<p><li> Eigenvalue problems with deep learning methods</li>

<p><li> Possible project on quantum computing and quantum machine learning</li>
</ol>
<p>
</ul>
</div>
</section>

<section>
<h2 id="topics-covered-in-this-course">Topics covered in this course </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>

<p><li> Search for minima in multidimensional spaces (conjugate gradient method, steepest descent method, quasi-Newton-Raphson, Broyden-Jacobian). Convex optimization, gradient methods</li>

<p><li> Iterative methods for solutions of non-linear equations.</li>

<p><li> Object orientation</li>

<p><li> Data analysis and resampling techniques</li>

<p><li> Variational Monte Carlo (VMC) for <b>ab initio</b> studies of quantum mechanical many-body systems.</li>

<p><li> Simulation of two- and three-dimensional systems like quantum dots or atoms and molecules or systems from solid state physics</li>

<p><li> <b>Simulation of trapped bosons using VMC (project 1, default)</b></li>

<p><li> <b>Machine learning and neural networks (project 2, default, same system as in project 1)</b></li>

<p><li> Extension of project 1 to fermionic systems (project 2)</li>

<p><li> Coupled cluster theory (project 2, depends on interest)</li>

<p><li> Other quantum-mechanical methods and systems can be tailored to one's interests (Hartree-Fock Theory, Many-body perturbation theory, time-dependent theories and more).</li>
</ul>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Most quantum mechanical  problems of interest in for example atomic, molecular, nuclear and solid state 
physics consist of a large number of interacting electrons and ions or nucleons. 
</p>

<p>The total number of particles \( N \) is usually sufficiently large
that an exact solution cannot be found. 
</p>

<p>Typically, 
the expectation value for a chosen hamiltonian for a system of  \( N \) particles is
</p>
<p>&nbsp;<br>
$$
   \langle H \rangle =
   \frac{\int d\boldsymbol{R}_1d\boldsymbol{R}_2\dots d\boldsymbol{R}_N
         \Psi^{\ast}(\boldsymbol{R_1},\boldsymbol{R}_2,\dots,\boldsymbol{R}_N)
          H(\boldsymbol{R_1},\boldsymbol{R}_2,\dots,\boldsymbol{R}_N)
          \Psi(\boldsymbol{R_1},\boldsymbol{R}_2,\dots,\boldsymbol{R}_N)}
        {\int d\boldsymbol{R}_1d\boldsymbol{R}_2\dots d\boldsymbol{R}_N
        \Psi^{\ast}(\boldsymbol{R_1},\boldsymbol{R}_2,\dots,\boldsymbol{R}_N)
        \Psi(\boldsymbol{R_1},\boldsymbol{R}_2,\dots,\boldsymbol{R}_N)},
$$
<p>&nbsp;<br>

<p>an in general intractable problem.</p>

<p> This integral is actually the starting point in a Variational Monte Carlo calculation. <b>Gaussian quadrature: Forget it</b>! Given 10 particles and 10 mesh points for each degree of freedom
and an
 ideal 1 Tflops machine (all operations take the same time), how long will it take to compute the above integral? The lifetime of the universe is of the order of \( 10^{17} \) s.
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>As an example from the nuclear many-body problem, we have Schroedinger's equation as a differential equation</p>
<p>&nbsp;<br>
$$
  \hat{H}\Psi(\boldsymbol{r}_1,..,\boldsymbol{r}_A,\alpha_1,..,\alpha_A)=E\Psi(\boldsymbol{r}_1,..,\boldsymbol{r}_A,\alpha_1,..,\alpha_A)
$$
<p>&nbsp;<br>

<p>where</p>
<p>&nbsp;<br>
$$
  \boldsymbol{r}_1,..,\boldsymbol{r}_A,
$$
<p>&nbsp;<br>

<p>are the coordinates and </p>
<p>&nbsp;<br>
$$
  \alpha_1,..,\alpha_A,
$$
<p>&nbsp;<br>

<p>are sets of relevant quantum numbers such as spin and isospin for a system of  \( A \) nucleons (\( A=N+Z \), \( N \) being the number of neutrons and \( Z \) the number of protons).</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>There are</p>
<p>&nbsp;<br>
$$
 2^A\times \left(\begin{array}{c} A\\ Z\end{array}\right)
$$
<p>&nbsp;<br>

<p>coupled second-order differential equations in \( 3A \) dimensions.</p>

<p>For a nucleus like beryllium-10 this number is <b>215040</b>.
This is a truely challenging many-body problem.
</p>

<p>Methods like partial differential equations can at most be used for 2-3 particles.</p>
</div>
</section>

<section>
<h2 id="various-many-body-methods">Various many-body methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> Monte-Carlo methods</li>
<p><li> Renormalization group (RG) methods, in particular density matrix RG</li>
<p><li> Large-scale diagonalization (Iterative methods, Lanczo's method, dimensionalities  \( 10^{10} \) states)</li>
<p><li> Coupled cluster theory, favoured method in quantum chemistry, molecular and atomic physics. Applications to ab initio calculations in nuclear physics as well for large nuclei.</li>
<p><li> Perturbative many-body methods</li> 
<p><li> Green's function methods</li>
<p><li> Density functional theory/Mean-field theory and Hartree-Fock theory</li>
</ul>
<p>
<p>The physics of the system hints at which many-body methods to use.</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Pros and Cons of Monte Carlo</b>
<p>
<ul>
<p><li> Is physically intuitive.</li>
<p><li> Allows one to study systems with many degrees of freedom. Diffusion Monte Carlo (DMC) and Green's function Monte Carlo (GFMC) yield in principle the exact solution to Schroedinger's equation.</li>
<p><li> Variational Monte Carlo (VMC) is easy  to implement but needs a reliable trial wave function, can be difficult to obtain.  This is where we will use Hartree-Fock theory to construct an optimal basis.</li>
<p><li> DMC/GFMC for fermions (spin with half-integer values, electrons, baryons, neutrinos, quarks)  has a sign problem. Nature prefers an anti-symmetric wave function. The PDF in this case given distribution of random walkers.</li>
<p><li> The solution has a statistical error, which can be large.</li> 
<p><li> There is a limit for how large systems one can study, DMC needs a huge number of random walkers in order to achieve stable results.</li> 
<p><li> Obtain only the lowest-lying states with a given symmetry. Can get excited states with extra labor.</li>
</ul>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Where and why do we use Monte Carlo Methods in Quantum Physics</b>
<p>
<ul>
<p><li> Quantum systems with many particles at finite temperature: Path Integral Monte Carlo with applications to dense matter and quantum liquids (phase transitions from normal fluid to superfluid). Strong correlations.</li>
<p><li> Bose-Einstein condensation of dilute gases, method transition from  non-linear PDE to Diffusion Monte Carlo as density increases.</li>
<p><li> Light atoms, molecules, solids and nuclei.</li> 
<p><li> Lattice Quantum-Chromo Dynamics. Impossible to solve without MC calculations.</li> 
<p><li> Simulations of systems in solid state physics, from semiconductors to spin systems. Many electrons active and possibly strong correlations.</li>
</ul>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>We start with the variational principle.
Given a hamiltonian \( H \) and a trial wave function \( \Psi_T \), the variational principle states that the expectation value of \( \langle H \rangle \), defined through 
</p>
<p>&nbsp;<br>
$$
   E[H]= \langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
$$
<p>&nbsp;<br>

<p>is an upper bound to the ground state energy \( E_0 \) of the hamiltonian \( H \), that is </p>
<p>&nbsp;<br>
$$
    E_0 \le \langle H \rangle .
$$
<p>&nbsp;<br>

<p>In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The trial wave function can be expanded in the eigenstates of the hamiltonian since they form a complete set, viz.,</p>
<p>&nbsp;<br>
$$
   \Psi_T(\boldsymbol{R})=\sum_i a_i\Psi_i(\boldsymbol{R}),
$$
<p>&nbsp;<br>

<p>and assuming the set of eigenfunctions to be normalized one obtains </p>
<p>&nbsp;<br>
$$
     \frac{\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})H(\boldsymbol{R})\Psi_n(\boldsymbol{R})}
        {\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})\Psi_n(\boldsymbol{R})} =\frac{\sum_{n}a^2_n E_n}
        {\sum_{n}a^2_n} \ge E_0,
$$
<p>&nbsp;<br>

<p>where we used that \( H(\boldsymbol{R})\Psi_n(\boldsymbol{R})=E_n\Psi_n(\boldsymbol{R}) \).
In general, the integrals involved in the calculation of various  expectation
values  are multi-dimensional ones. 
The variational principle yields the lowest state of a given symmetry.
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>In most cases, a wave function has only small values in large parts of 
configuration space, and a straightforward procedure which uses
homogenously distributed random points in configuration space 
will most likely lead to poor results. This may suggest that some kind
of importance sampling combined with e.g., the Metropolis algorithm 
may be  a more efficient way of obtaining the ground state energy.
The hope is then that those regions of configurations space where
the wave function assumes appreciable values are sampled more 
efficiently. 
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The tedious part in a VMC calculation is the search for the variational
minimum. A good knowledge of the system is required in order to carry out
reasonable VMC calculations. This is not always the case, 
and often VMC calculations 
serve rather as the starting
point for so-called diffusion Monte Carlo calculations (DMC). DMC is a way of
solving exactly the many-body Schroedinger equation by means of 
a stochastic procedure. A good guess on the binding energy
and its wave function is however necessary. 
A carefully performed VMC calculation can aid in this context. 
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> Construct first a trial wave function \( \psi_T(\boldsymbol{R},\boldsymbol{\alpha}) \),  for a many-body system consisting of \( N \) particles located at positions  \( \boldsymbol{R}=(\boldsymbol{R}_1,\dots ,\boldsymbol{R}_N) \). The trial wave function depends on \( \alpha \) variational parameters \( \boldsymbol{\alpha}=(\alpha_1,\dots ,\alpha_M) \).</li>
<p><li> Then we evaluate the expectation value of the hamiltonian \( H \)</li> 
</ul>
<p>
<p>&nbsp;<br>
$$
   E[H]=\langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}.
$$
<p>&nbsp;<br>

<ul>
<p><li> Thereafter we vary \( \alpha \) according to some minimization algorithm and return to the first step.</li>
</ul>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Basic steps</b>
<p>
<p>Choose a trial wave function
\( \psi_T(\boldsymbol{R}) \).
</p>
<p>&nbsp;<br>
$$
   P(\boldsymbol{R})= \frac{\left|\psi_T(\boldsymbol{R})\right|^2}{\int \left|\psi_T(\boldsymbol{R})\right|^2d\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>This is our new probability distribution function  (PDF).
The approximation to the expectation value of the Hamiltonian is now 
</p>
<p>&nbsp;<br>
$$
   E[H(\boldsymbol{\alpha})] = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Define a new quantity</p>
<p>&nbsp;<br>
$$
   E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
\tag{1}
$$
<p>&nbsp;<br>

<p>called the local energy, which, together with our trial PDF yields</p>
<p>&nbsp;<br>
$$
  E[H(\boldsymbol{\alpha})]=\int P(\boldsymbol{R})E_L(\boldsymbol{R}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^N E_L(\boldsymbol{R_i},\boldsymbol{\alpha})
\tag{2}
$$
<p>&nbsp;<br>

<p>with \( N \) being the number of Monte Carlo samples.</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo">Quantum Monte Carlo </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The Algorithm for performing a variational Monte Carlo calculations runs thus as this</p>

<ul>

<p><li> Initialisation: Fix the number of Monte Carlo steps. Choose an initial \( \boldsymbol{R} \) and variational parameters \( \alpha \) and calculate \( \left|\psi_T^{\alpha}(\boldsymbol{R})\right|^2 \).</li>

<p><li> Initialise the energy and the variance and start the Monte Carlo calculation.</li>
<ul>

<p><li> Calculate  a trial position  \( \boldsymbol{R}_p=\boldsymbol{R}+r*step \) where \( r \) is a random variable \( r \in [0,1] \).</li>

<p><li> Metropolis algorithm to accept or reject this move  \( w = P(\boldsymbol{R}_p)/P(\boldsymbol{R}) \).</li>

<p><li> If the step is accepted, then we set \( \boldsymbol{R}=\boldsymbol{R}_p \).</li>

<p><li> Update averages</li>
</ul>
<p>

<p><li> Finish and compute final averages.</li>
</ul>
<p>
<p>Observe that the jumping in space is governed by the variable <em>step</em>. This is Called brute-force sampling.
Need importance sampling to get more relevant sampling, see lectures below.
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-hydrogen-atom">Quantum Monte Carlo: hydrogen atom </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The radial Schroedinger equation for the hydrogen atom can be
written as
</p>
<p>&nbsp;<br>
$$
-\frac{\hbar^2}{2m}\frac{\partial^2 u(r)}{\partial r^2}-
\left(\frac{ke^2}{r}-\frac{\hbar^2l(l+1)}{2mr^2}\right)u(r)=Eu(r),
$$
<p>&nbsp;<br>

<p>or with dimensionless variables</p>
<p>&nbsp;<br>
$$
-\frac{1}{2}\frac{\partial^2 u(\rho)}{\partial \rho^2}-
\frac{u(\rho)}{\rho}+\frac{l(l+1)}{2\rho^2}u(\rho)-\lambda u(\rho)=0,
\tag{3}
$$
<p>&nbsp;<br>

<p>with the hamiltonian</p>
<p>&nbsp;<br>
$$
H=-\frac{1}{2}\frac{\partial^2 }{\partial \rho^2}-
\frac{1}{\rho}+\frac{l(l+1)}{2\rho^2}.
$$
<p>&nbsp;<br>

<p>Use variational parameter \( \alpha \) in the trial
wave function 
</p>
<p>&nbsp;<br>
$$
   u_T^{\alpha}(\rho)=\alpha\rho e^{-\alpha\rho}. 
\tag{4}
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-hydrogen-atom">Quantum Monte Carlo: hydrogen atom </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Inserting this wave function into the expression for the
local energy \( E_L \) gives
</p>
<p>&nbsp;<br>
$$
   E_L(\rho)=-\frac{1}{\rho}-
              \frac{\alpha}{2}\left(\alpha-\frac{2}{\rho}\right).
$$
<p>&nbsp;<br>

<p>A simple variational Monte Carlo calculation results in</p>
<table class="dotable" border="1">
<thead>
<tr><td align="center">\( \alpha \)</td> <td align="center">\( \langle H \rangle  \)</td> <td align="center">\( \sigma^2 \)</td> <td align="center">\( \sigma/\sqrt{N} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   7.00000E-01     </td> <td align="center">   -4.57759E-01                </td> <td align="center">   4.51201E-02       </td> <td align="center">   6.71715E-04              </td> </tr>
<tr><td align="center">   8.00000E-01     </td> <td align="center">   -4.81461E-01                </td> <td align="center">   3.05736E-02       </td> <td align="center">   5.52934E-04              </td> </tr>
<tr><td align="center">   9.00000E-01     </td> <td align="center">   -4.95899E-01                </td> <td align="center">   8.20497E-03       </td> <td align="center">   2.86443E-04              </td> </tr>
<tr><td align="center">   1.00000E-00     </td> <td align="center">   -5.00000E-01                </td> <td align="center">   0.00000E+00       </td> <td align="center">   0.00000E+00              </td> </tr>
<tr><td align="center">   1.10000E+00     </td> <td align="center">   -4.93738E-01                </td> <td align="center">   1.16989E-02       </td> <td align="center">   3.42036E-04              </td> </tr>
<tr><td align="center">   1.20000E+00     </td> <td align="center">   -4.75563E-01                </td> <td align="center">   8.85899E-02       </td> <td align="center">   9.41222E-04              </td> </tr>
<tr><td align="center">   1.30000E+00     </td> <td align="center">   -4.54341E-01                </td> <td align="center">   1.45171E-01       </td> <td align="center">   1.20487E-03              </td> </tr>
</tbody>
</table>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-hydrogen-atom">Quantum Monte Carlo: hydrogen atom </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>We note that at \( \alpha=1 \) we obtain the exact
result, and the variance is zero, as it should. The reason is that 
we then have the exact wave function, and the action of the hamiltionan
on the wave function
</p>
<p>&nbsp;<br>
$$
   H\psi = \mathrm{constant}\times \psi,
$$
<p>&nbsp;<br>

<p>yields just a constant. The integral which defines various 
expectation values involving moments of the hamiltonian becomes then
</p>
<p>&nbsp;<br>
$$
   \langle H^n \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H^n(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=
\mathrm{constant}\times\frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=\mathrm{constant}.
$$
<p>&nbsp;<br>

<b>This gives an important information: the exact wave function leads to zero variance!</b>
<p>Variation is then performed by minimizing both the energy and the variance.</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-for-bosons-https-github-com-mortele-variational-monte-carlo-fys4411"><a href="https://github.com/mortele/variational-monte-carlo-fys4411" target="_blank">Quantum Monte Carlo for bosons</a> </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>For bosons in a harmonic oscillator-like  trap we will use is a spherical (S)
 or an elliptical (E) harmonic trap in one, two and finally three
 dimensions, with the latter given by
</p>
<p>&nbsp;<br>
$$
 \begin{equation}
 V_{ext}(\mathbf{r}) = \Bigg\{
 \begin{array}{ll}
	 \frac{1}{2}m\omega_{ho}^2r^2 & (S)\\
 \strut
	 \frac{1}{2}m[\omega_{ho}^2(x^2+y^2) + \omega_z^2z^2] & (E)
\tag{5}
 \end{array}
 \end{equation}
$$
<p>&nbsp;<br>

<p>where (S) stands for symmetric and </p>
<p>&nbsp;<br>
$$
\begin{equation}
     \hat{H} = \sum_i^N \left(
	 \frac{-\hbar^2}{2m}
	 { \bigtriangledown }_{i}^2 +
	 V_{ext}({\bf{r}}_i)\right)  +
	 \sum_{i < j}^{N} V_{int}({\bf{r}}_i,{\bf{r}}_j),
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

<p>as the two-body Hamiltonian of the system.  </p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-for-bosons-https-github-com-mortele-variational-monte-carlo-fys4411"><a href="https://github.com/mortele/variational-monte-carlo-fys4411" target="_blank">Quantum Monte Carlo for bosons</a> </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p> We will represent the inter-boson interaction by a pairwise, repulsive potential</p>
<p>&nbsp;<br>
$$
\begin{equation}
 V_{int}(|\mathbf{r}_i-\mathbf{r}_j|) =  \Bigg\{
 \begin{array}{ll}
	 \infty & {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 0 & {|\mathbf{r}_i-\mathbf{r}_j|} > {a}
 \end{array}
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>

<p> where \( a \) is the so-called hard-core diameter of the bosons.
 Clearly, \( V_{int}(|\mathbf{r}_i-\mathbf{r}_j|) \) is zero if the bosons are
 separated by a distance \( |\mathbf{r}_i-\mathbf{r}_j| \) greater than \( a \) but
 infinite if they attempt to come within a distance \( |\mathbf{r}_i-\mathbf{r}_j| \leq a \).
</p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-for-bosons-https-github-com-mortele-variational-monte-carlo-fys4411"><a href="https://github.com/mortele/variational-monte-carlo-fys4411" target="_blank">Quantum Monte Carlo for bosons</a> </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p> Our trial wave function for the ground state with \( N \) atoms is given by</p>
<p>&nbsp;<br>
$$
 \begin{equation}
 \Psi_T(\mathbf{R})=\Psi_T(\mathbf{r}_1, \mathbf{r}_2, \dots \mathbf{r}_N,\alpha,\beta)=\prod_i g(\alpha,\beta,\mathbf{r}_i)\prod_{i < j}f(a,|\mathbf{r}_i-\mathbf{r}_j|),
\tag{8}
 \end{equation}
$$
<p>&nbsp;<br>

<p> where \( \alpha \) and \( \beta \) are variational parameters. The
 single-particle wave function is proportional to the harmonic
 oscillator function for the ground state
</p>
<p>&nbsp;<br>
$$
\begin{equation}
    g(\alpha,\beta,\mathbf{r}_i)= \exp{[-\alpha(x_i^2+y_i^2+\beta z_i^2)]}.
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-for-bosons-https-github-com-mortele-variational-monte-carlo-fys4411"><a href="https://github.com/mortele/variational-monte-carlo-fys4411" target="_blank">Quantum Monte Carlo for bosons</a> </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>For spherical traps we have \( \beta = 1 \) and for non-interacting
bosons (\( a=0 \)) we have \( \alpha = 1/2a_{ho}^2 \).  The correlation wave
 function is
</p>
<p>&nbsp;<br>
$$
 \begin{equation}
    f(a,|\mathbf{r}_i-\mathbf{r}_j|)=\Bigg\{
 \begin{array}{ll}
	 0 & {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 (1-\frac{a}{|\mathbf{r}_i-\mathbf{r}_j|}) & {|\mathbf{r}_i-\mathbf{r}_j|} > {a}.
 \end{array}
\tag{10}
\end{equation}  
$$
<p>&nbsp;<br>
</div>
<h3 id="simple-example-the-hydrogen-atom">Simple example, the hydrogen atom </h3>
<p>The radial Schroedinger equation for the hydrogen atom can be
written as (when we have gotten rid of the first derivative term in the kinetic energy and used \( rR(r)=u(r) \))
</p>
<p>&nbsp;<br>
$$
-\frac{\hbar^2}{2m}\frac{d^2 u(r)}{d r^2}-
\left(\frac{ke^2}{r}-\frac{\hbar^2l(l+1)}{2mr^2}\right)u(r)=Eu(r).
$$
<p>&nbsp;<br>

<p>We will specialize to the case with \( l=0 \) and end up with </p>
<p>&nbsp;<br>
$$
-\frac{\hbar^2}{2m}\frac{d^2 u(r)}{d r^2}-
\left(\frac{ke^2}{r}\right)u(r)=Eu(r).
$$
<p>&nbsp;<br>

<p>Then we introduce a dimensionless variable \( \rho=r/a \) where \( a \) is a constant with dimension length.
Multiplying with \( ma^2/\hbar^2 \) we can rewrite our equations as
</p>
<p>&nbsp;<br>
$$
-\frac{1}{2}\frac{d^2 u(\rho)}{d \rho^2}-
\frac{ke^2ma}{\hbar^2}\frac{u(\rho)}{\rho}-\lambda u(\rho)=0.
$$
<p>&nbsp;<br>

<p>Since \( a \) is just a parameter we choose to set</p>
<p>&nbsp;<br>
$$
\frac{ke^2ma}{\hbar^2}=1,
$$
<p>&nbsp;<br>

<p>which leads to \( a=\hbar^2/mke^2 \), better known as the Bohr radius with value \( 0.053 \) nm. Scaling the equations this way does not only render our numerical treatment simpler since we avoid carrying with us all physical parameters, but we obtain also a <b>natural</b> length scale. We will see this again and again. In our discussions below with a harmonic oscillator trap, the <b>natural</b> lentgh scale with be determined by the oscillator frequency, the mass of the particle and \( \hbar \). We have also defined a dimensionless 'energy' \( \lambda = Ema^2/\hbar^2 \). 
With the rescaled quantities, the ground state energy of the hydrogen atom is \( 1/2 \). 
The equation we want to solve is now defined by the Hamiltonian
</p>
<p>&nbsp;<br>
$$
H=-\frac{1}{2}\frac{d^2 }{d \rho^2}-\frac{1}{\rho}.
$$
<p>&nbsp;<br>

<p>As trial wave function we peep now into the analytical solution for
the hydrogen atom and use (with \( \alpha \) as a variational parameter)
</p>

<p>&nbsp;<br>
$$
   u_T^{\alpha}(\rho)=\alpha\rho \exp{-(\alpha\rho)}. 
$$
<p>&nbsp;<br>

<p>Inserting this wave function into the expression for the
local energy \( E_L \) gives
</p>
<p>&nbsp;<br>
$$
   E_L(\rho)=-\frac{1}{\rho}-
              \frac{\alpha}{2}\left(\alpha-\frac{2}{\rho}\right).
$$
<p>&nbsp;<br>

<p>To have analytical local energies saves us from computing numerically
the second derivative, a feature which often increases our numerical
expenditure with a factor of three or more. Integratng up the local energy (recall to bring back the PDF in the integration) gives  \( \overline{E}[\boldsymbol{\alpha}]=\alpha(\alpha/2-1) \). 
</p>
<h3 id="second-example-the-harmonic-oscillator-in-one-dimension">Second example, the harmonic oscillator in one dimension </h3>

<p>We present here another well-known example, the harmonic oscillator in
one dimension for one particle. This will also serve the aim of
introducing our next model, namely that of interacting electrons in a
harmonic oscillator trap.
</p>

<p>Here as well, we do have analytical solutions and the energy of the
ground state, with \( \hbar=1 \), is \( 1/2\omega \), with \( \omega \) being the
oscillator frequency. We use the following trial wave function
</p>

<p>&nbsp;<br>
$$
\psi_T(x;\alpha) = \exp{-(\frac{1}{2}\alpha^2x^2)},
$$
<p>&nbsp;<br>

<p>which results in a local energy </p>
<p>&nbsp;<br>
$$
\frac{1}{2}\left(\alpha^2+x^2(1-\alpha^4)\right).
$$
<p>&nbsp;<br>

<p>We can compare our numerically calculated energies with the exact energy as function of \( \alpha \)</p>
<p>&nbsp;<br>
$$
\overline{E}[\alpha] = \frac{1}{4}\left(\alpha^2+\frac{1}{\alpha^2}\right).
$$
<p>&nbsp;<br>

<p>Similarly, with the above ansatz, we can also compute the exact variance which reads</p>
<p>&nbsp;<br>
$$
\sigma^2[\alpha]=\frac{1}{4}\left(1+(1-\alpha^4)^2\frac{3}{4\alpha^4}\right)-\overline{E}^2.
$$
<p>&nbsp;<br>

<p>Our code for computing the energy of the ground state of the harmonic oscillator follows here. We start by defining directories where we store various outputs.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;Results/VMCHarmonic&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

outfile = <span style="color: #658b00">open</span>(data_path(<span style="color: #CD5555">&quot;VMCHarmonic.dat&quot;</span>),<span style="color: #CD5555">&#39;w&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We proceed with the implementation of the Monte Carlo algorithm but list first the ansatz for the wave function and the expression for the local energy</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># VMC for the one-dimensional harmonic oscillator</span>
<span style="color: #228B22"># Brute force Metropolis, no importance sampling and no energy minimization</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp, sqrt
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">random</span> <span style="color: #8B008B; font-weight: bold">import</span> random, seed
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decimal</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #228B22"># Trial wave function for the Harmonic oscillator in one dimension</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">WaveFunction</span>(r,alpha):
    <span style="color: #8B008B; font-weight: bold">return</span> exp(-<span style="color: #B452CD">0.5</span>*alpha*alpha*r*r)

<span style="color: #228B22"># Local energy  for the Harmonic oscillator in one dimension</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">LocalEnergy</span>(r,alpha):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*r*r*(<span style="color: #B452CD">1</span>-alpha**<span style="color: #B452CD">4</span>) + <span style="color: #B452CD">0.5</span>*alpha*alpha
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that in the Metropolis algorithm there is no need to compute the
trial wave function, mainly since we are just taking the ratio of two
exponentials. It is then from a computational point view, more
convenient to compute the argument from the ratio and then calculate
the exponential. Here we have refrained from this purely of
pedagogical reasons.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># The Monte Carlo sampling with the Metropolis algo</span>
<span style="color: #228B22"># The jit decorator tells Numba to compile this function.</span>
<span style="color: #228B22"># The argument types will be inferred by Numba when the function is called.</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MonteCarloSampling</span>():

    NumberMCcycles= <span style="color: #B452CD">100000</span>
    StepSize = <span style="color: #B452CD">1.0</span>
    <span style="color: #228B22"># positions</span>
    PositionOld = <span style="color: #B452CD">0.0</span>
    PositionNew = <span style="color: #B452CD">0.0</span>

    <span style="color: #228B22"># seed for rng generator</span>
    seed()
    <span style="color: #228B22"># start variational parameter</span>
    alpha = <span style="color: #B452CD">0.4</span>
    <span style="color: #8B008B; font-weight: bold">for</span> ia <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(MaxVariations):
        alpha += <span style="color: #B452CD">.05</span>
        AlphaValues[ia] = alpha
        energy = energy2 = <span style="color: #B452CD">0.0</span>
        <span style="color: #228B22">#Initial position</span>
        PositionOld = StepSize * (random() - <span style="color: #B452CD">.5</span>)
        wfold = WaveFunction(PositionOld,alpha)
        <span style="color: #228B22">#Loop over MC MCcycles</span>
        <span style="color: #8B008B; font-weight: bold">for</span> MCcycle <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(NumberMCcycles):
            <span style="color: #228B22">#Trial position </span>
            PositionNew = PositionOld + StepSize*(random() - <span style="color: #B452CD">.5</span>)
            wfnew = WaveFunction(PositionNew,alpha)
            <span style="color: #228B22">#Metropolis test to see whether we accept the move</span>
            <span style="color: #8B008B; font-weight: bold">if</span> random() &lt;= wfnew**<span style="color: #B452CD">2</span> / wfold**<span style="color: #B452CD">2</span>:
                PositionOld = PositionNew
                wfold = wfnew
            DeltaE = LocalEnergy(PositionOld,alpha)
            energy += DeltaE
            energy2 += DeltaE**<span style="color: #B452CD">2</span>
        <span style="color: #228B22">#We calculate mean, variance and error</span>
        energy /= NumberMCcycles
        energy2 /= NumberMCcycles
        variance = energy2 - energy**<span style="color: #B452CD">2</span>
        error = sqrt(variance/NumberMCcycles)
        Energies[ia] = energy    
        Variances[ia] = variance    
        outfile.write(<span style="color: #CD5555">&#39;%f %f %f %f \n&#39;</span> %(alpha,energy,variance,error))
    <span style="color: #8B008B; font-weight: bold">return</span> Energies, AlphaValues, Variances
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally, the results are presented here with the exact energies and variances as well.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22">#Here starts the main program with variable declarations</span>
MaxVariations = <span style="color: #B452CD">20</span>
Energies = np.zeros((MaxVariations))
ExactEnergies = np.zeros((MaxVariations))
ExactVariance = np.zeros((MaxVariations))
Variances = np.zeros((MaxVariations))
AlphaValues = np.zeros(MaxVariations)
(Energies, AlphaValues, Variances) = MonteCarloSampling()
outfile.close()
ExactEnergies = <span style="color: #B452CD">0.25</span>*(AlphaValues*AlphaValues+<span style="color: #B452CD">1.0</span>/(AlphaValues*AlphaValues))
ExactVariance = <span style="color: #B452CD">0.25</span>*(<span style="color: #B452CD">1.0</span>+((<span style="color: #B452CD">1.0</span>-AlphaValues**<span style="color: #B452CD">4</span>)**<span style="color: #B452CD">2</span>)*<span style="color: #B452CD">3.0</span>/(<span style="color: #B452CD">4</span>*(AlphaValues**<span style="color: #B452CD">4</span>)))-ExactEnergies*ExactEnergies

<span style="color: #228B22">#simple subplot</span>
plt.subplot(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
plt.plot(AlphaValues, Energies, <span style="color: #CD5555">&#39;o-&#39;</span>,AlphaValues, ExactEnergies,<span style="color: #CD5555">&#39;r-&#39;</span>)
plt.title(<span style="color: #CD5555">&#39;Energy and variance&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;Dimensionless energy&#39;</span>)
plt.subplot(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>)
plt.plot(AlphaValues, Variances, <span style="color: #CD5555">&#39;.-&#39;</span>,AlphaValues, ExactVariance,<span style="color: #CD5555">&#39;r-&#39;</span>)
plt.xlabel(<span style="color: #CD5555">r&#39;$\alpha$&#39;</span>, fontsize=<span style="color: #B452CD">15</span>)
plt.ylabel(<span style="color: #CD5555">&#39;Variance&#39;</span>)
save_fig(<span style="color: #CD5555">&quot;VMCHarmonic&quot;</span>)
plt.show()
<span style="color: #228B22">#nice printout with Pandas</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">import</span> DataFrame
data ={<span style="color: #CD5555">&#39;Alpha&#39;</span>:AlphaValues, <span style="color: #CD5555">&#39;Energy&#39;</span>:Energies,<span style="color: #CD5555">&#39;Exact Energy&#39;</span>:ExactEnergies,<span style="color: #CD5555">&#39;Variance&#39;</span>:Variances,<span style="color: #CD5555">&#39;Exact Variance&#39;</span>:ExactVariance,}
frame = pd.DataFrame(data)
<span style="color: #658b00">print</span>(frame)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>For \( \alpha=1 \) we have the exact eigenpairs, as can be deduced from the
table here. With \( \omega=1 \), the exact energy is \( 1/2 \) a.u. with zero
variance, as it should. We see also that our computed variance follows rather well the exact variance.
Increasing the number of Monte Carlo cycles will improve our statistics (try to increase the number of Monte Carlo cycles).
</p>

<p>The fact that the variance is exactly equal to zero when \( \alpha=1 \) is that 
we then have the exact wave function, and the action of the hamiltionan
on the wave function
</p>
<p>&nbsp;<br>
$$
   H\psi = \mathrm{constant}\times \psi,
$$
<p>&nbsp;<br>

<p>yields just a constant. The integral which defines various 
expectation values involving moments of the hamiltonian becomes then
</p>
<p>&nbsp;<br>
$$
   \langle H^n \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H^n(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=
\mathrm{constant}\times\frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=\mathrm{constant}.
$$
<p>&nbsp;<br>

<b>This gives an important information: the exact wave function leads to zero variance!</b>
<p>As we will see below, many practitioners perform a minimization on both the energy and the variance.</p>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
