%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Simple Motion and Forces}}

\usepackage{sphinxmessages}




\title{Classical mechanics}
\date{Dec 16, 2020}
\release{}
\author{Morten Hjorth\sphinxhyphen{}Jensen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


Here you will find a general overview of the course, with learning outcomes, teaching schedule etc.


\chapter{Teaching team, grading and other practicalities}
\label{\detokenize{intro:teaching-team-grading-and-other-practicalities}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Lectures
&

&

&\sphinxstyletheadfamily 
Location
\\
\hline
Monday 3:00\sphinxhyphen{}3:50pm
&
Wednesday 3:00\sphinxhyphen{}3:50pm
&
Friday 3:00\sphinxhyphen{}3:50pm
&
Room 1420 BPS
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Instructor
&\sphinxstyletheadfamily 
Email
&\sphinxstyletheadfamily 
Office
&\sphinxstyletheadfamily 
Office phone/cellphone
\\
\hline
\sphinxstyleemphasis{Morten Hjorth\sphinxhyphen{}Jensen} https://github.com/mhjensen
&
hjensen@msu.edu
&
Office: NSCL/FRIB 2131
&
5179087290/5172491375/+47\sphinxhyphen{}48257387
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Office Hours
&

\\
\hline
Monday/Wednesday 4\sphinxhyphen{}5:00pm, Room 2131 NSCL/FRIB
&
or immediately after class
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Homework Grader
&\sphinxstyletheadfamily 
Email
\\
\hline
\sphinxstyleemphasis{Julie Butler}
&
butler@frib.msu.edu
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Office Hours Julie Butler
\\
\hline
TBA
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Learning Assistant
&\sphinxstyletheadfamily 
Email
\\
\hline
\sphinxstyleemphasis{Jeremy Rebenstock}
&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Office Hours TBA
&

\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Additional Class
&\sphinxstyletheadfamily 
Location
\\
\hline
Wednesday 5:00\sphinxhyphen{}6pm
&
Room 1400 BPS
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Grading and dates}
\label{\detokenize{intro:grading-and-dates}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Activity
&\sphinxstyletheadfamily 
Percentage of total score
\\
\hline
Homeworks, 9 in total and due Mondays the week after
&
20\%
\\
\hline
First Midterm Project, due Wednesday March  11
&
25\%
\\
\hline
Second  Midterm Project, due Friday April 17
&
25\%
\\
\hline
Final Exam project, due May 1
&
30\%
\\
\hline
Extra Credit Assignment, hw10,  (Due Friday April 24)
&
10\%
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Grading scale
&

&

&

&

&

&

\\
\hline
4.0(90\%)
&
3.5(80\%)
&
3.0(70\%)
&
2.5(60\%)
&
2.0(50\%)
&
1.5(40\%)
&
1.0(30\%)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Possible textbooks and lecture notes}
\label{\detokenize{intro:possible-textbooks-and-lecture-notes}}
\sphinxstyleemphasis{Recommended textbook}:
\begin{itemize}
\item {} 
JRT: John R. Taylor, Classical Mechanics (Univ. Sci. Books 2005), https://www.uscibooks.com/taylor2.htm, see also https://github.com/mhjensen/Physics321/tree/master/doc/Literature
\sphinxstyleemphasis{Additional textbooks}:

\item {} 
AMS: Anders Malthe\sphinxhyphen{}Sørenssen, Elementary Mechanics using Python (Springer 2015), https://www.springer.com/gp/book/9783319195957 and https://github.com/mhjensen/Physics321/tree/master/doc/Literature

\item {} 
\sphinxstyleemphasis{Lecture notes}: Posted lecture notes are in the doc/pub folder here or at https://mhjensen.github.io/Physics321/doc/web/course.html for easier viewing. They are not meant to be a replacement for textbook. These notes are updated on a weekly basis and a \sphinxstyleemphasis{git pull} should thus always give you the latest update.

\end{itemize}


\chapter{Teaching schedule with links to material (This will be updated asap)}
\label{\detokenize{intro:teaching-schedule-with-links-to-material-this-will-be-updated-asap}}
Weekly mails (Wednesdays or Thursdays) with updates, plans for lectures etc will sent to everybody. We use also Piazza as a discussion forum. Please use this sign\sphinxhyphen{}up link piazza.com/msu/spring2020/phy321. The class link is piazza.com/msu/spring2020/phy321/home


\section{Week 2, January 6\sphinxhyphen{}10, 2020}
\label{\detokenize{intro:week-2-january-6-10-2020}}\begin{itemize}
\item {} 
Monday: Introduction to the course and start discussion of vectors, space, time and motion, JRT chapter 1.2 and lecture notes (https://mhjensen.github.io/Physics321/doc/pub/Introduction/html/Introduction.html)

\item {} 
Wednesday: More on time,space, vectors and motion, JRT 1.2 and 1.3, AMS chapters 2 and 4  and lecture notes (https://mhjensen.github.io/Physics321/doc/pub/Introduction/html/Introduction.html), first homework available

\item {} 
Friday: Forces and Newton’s laws of motion. JRT chapter 1.4 and lecture notes (https://mhjensen.github.io/Physics321/doc/pub/Introduction/html/Introduction.html). Introduction to Git and GitHub and getting started with numerical exercises. Installing software (anaconda) and first homework due January 17. For solving exercise 7 in the first homework, AMS chapters 2 and 4 are very useful

\item {} 
Solution to homeworks are in https://d2l.msu.edu/

\end{itemize}


\section{Week 3, January 13\sphinxhyphen{}17, 2020}
\label{\detokenize{intro:week-3-january-13-17-2020}}\begin{itemize}
\item {} 
Monday: Motion and forces, Newton’s laws, examples

\item {} 
Wednesday: Motion and forces, Newton’s laws, examples

\item {} 
Friday:  Motion and forces, Newton’s laws, examples,2nd homework, due January 24

\item {} 
Solution to homeworks are in https://d2l.msu.edu/

\item {} 
Good reads are Taylor chapters 1.4, 1.5, 1.6, 2.1\sphinxhyphen{}2.4 and AMS chapters 4.2 and  5

\end{itemize}


\section{Week 4, January 20\sphinxhyphen{}24, 2020}
\label{\detokenize{intro:week-4-january-20-24-2020}}\begin{itemize}
\item {} 
Monday: MLK day, no lectures

\item {} 
Wednesday: Work and energy conservation

\item {} 
Friday:  Example of conservation laws and single\sphinxhyphen{}particle motion, 3rd homework, due January 31

\item {} 
Good reads are Taylor chapters 4.1\sphinxhyphen{}.4.3 and AMS chapters 10\sphinxhyphen{}12.

\end{itemize}


\section{Week 5, January 27\sphinxhyphen{}31, 2020}
\label{\detokenize{intro:week-5-january-27-31-2020}}\begin{itemize}
\item {} 
Monday: More on Conservation laws, momentum conservation

\item {} 
Wednesday: Examples of applications of conservation laws, angular momentum conservation

\item {} 
Friday:  Conservation aws and further examples, 4th homework, due February 10

\item {} 
Good reads are Taylor chapter 4 and AMS chapters 10\sphinxhyphen{}14.

\end{itemize}


\section{Week 6, February 3\sphinxhyphen{}7, 2020}
\label{\detokenize{intro:week-6-february-3-7-2020}}\begin{itemize}
\item {} 
Monday: Conservation laws and discussion of 4th homework (exercises 6 and 7). Introducing the Velocity Verlet algorithm and the Earth Sun problem

\item {} 
Wednesday: Examples of application of conservations laws (see chapter 4 of Taylor).

\item {} 
Friday: Begin discussion of oscillations, and  5th homework, due February 17, paper and pencil can be handed in Friday the 21st at latest.

\item {} 
Good reads are Taylor chapter 4 and AMS chapters 10\sphinxhyphen{}14 for the conservation laws and the first sections of chapter 5 of Taylor on oscillations.

\end{itemize}


\section{Week 7, February 10\sphinxhyphen{}14, 2020}
\label{\detokenize{intro:week-7-february-10-14-2020}}\begin{itemize}
\item {} 
Monday: Oscillations, mathematical detials, the sliding block and energy conservation

\item {} 
Wednesday:  Oscillations, damped motion and more mathematical details

\item {} 
Friday: Oscillations, resonances and more on damped motion,  6th homework, due February 24

\item {} 
Good reads are chapter 5 of Taylor on oscillations.

\end{itemize}


\section{Week 8, February 17\sphinxhyphen{}21, 2020}
\label{\detokenize{intro:week-8-february-17-21-2020}}\begin{itemize}
\item {} 
Monday: Oscillations, driven oscillations and resonances

\item {} 
Wednesday:  Oscillation examples and  numerical integration

\item {} 
Friday: Fourier series and end of oscillation chapter  \sphinxstyleemphasis{First midterm project, available Friday Feb 21 and due March 11, 2020}

\item {} 
Good reads are sections 5.5\sphinxhyphen{}5.8 of Taylor on oscillations.

\end{itemize}


\section{Week 9, February 24\sphinxhyphen{}28, 2020}
\label{\detokenize{intro:week-9-february-24-28-2020}}\begin{itemize}
\item {} 
Monday: Fourier series and oscillations

\item {} 
Wednesday: Discussiom of first midterm and wrap up of oscillations part

\item {} 
Friday:  No lecture!

\item {} 
Good reads are chapter 8 of Taylor and Lecture notes

\end{itemize}


\section{Week 10, March 2\sphinxhyphen{}6, 2020, Spring break}
\label{\detokenize{intro:week-10-march-2-6-2020-spring-break}}\begin{itemize}
\item {} 
Monday:  No lectures, spring break

\item {} 
Wednesday: No lectures, spring break

\item {} 
Friday:  No lectures, spring break

\end{itemize}


\section{Week 11, March  9\sphinxhyphen{}13, 2020}
\label{\detokenize{intro:week-11-march-9-13-2020}}\begin{itemize}
\item {} 
Monday:  Gravity and central force problems, center of mass coordinates. Lecture notes and Taylor chapter 8. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch9.pdf

\item {} 
Wednesday: Discussion of first midterm. First midterm due Friday 13

\item {} 
Friday:  Gravity and central force problems, centrifugal barriers. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch13.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_wk9trq9k

\end{itemize}


\section{Week 12, March 16\sphinxhyphen{}20, 2020}
\label{\detokenize{intro:week-12-march-16-20-2020}}\begin{itemize}
\item {} 
Monday: Gravity and central force problems, elliptical orbits and Kepler’s laws, 7th homework, due March 23. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch16.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_t1pocrww

\item {} 
Wednesday: Gravity and central force problems, elliptical orbits  and two\sphinxhyphen{}body scattering examples. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch18.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_i9hczn21

\item {} 
Friday:  Elliptical orbits, examples and two\sphinxhyphen{}body scattering problems. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch20.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_w9xc8az7

\end{itemize}


\section{Week 13, March 23\sphinxhyphen{}27, 2020}
\label{\detokenize{intro:week-13-march-23-27-2020}}\begin{itemize}
\item {} 
Monday: Central force problems, summary and discussion of two\sphinxhyphen{}body scattering problems. 8th homework, due March 30. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch23.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_t2l86862

\item {} 
Wednesday: Two\sphinxhyphen{}body scattering. Taylor chapter 14 covers parts of the material. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch25.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_d70czgce

\item {} 
Friday:  Two\sphinxhyphen{}body scattering (Taylor chapter 14). PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch27.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_e1cs5784

\end{itemize}


\section{Week 14, March 30\sphinxhyphen{}April 3, 2020}
\label{\detokenize{intro:week-14-march-30-april-3-2020}}\begin{itemize}
\item {} 
Monday: Wrapping up two\sphinxhyphen{}body scattering and begin non\sphinxhyphen{}inertial frames.  9th homework, due April 6. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesMarch30.pdf and video of lecture https://mediaspace.msu.edu/media/t/0\_tlsccwai

\item {} 
Wednesday: Non\sphinxhyphen{}inertial frames, accelerating frames (Taylor sections 9.1\sphinxhyphen{}9.2).  PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril1.pdf and video of lecture https://mediaspace.msu.edu/media/t/0\_utc9il9y

\item {} 
Friday: Rotating non\sphinxhyphen{}inertial frames and Coriolis force (Taylor sections 9.3\sphinxhyphen{}9.6). PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril3.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_2v439nza

\end{itemize}


\section{Week 15, April  6\sphinxhyphen{}10, 2020}
\label{\detokenize{intro:week-15-april-6-10-2020}}\begin{itemize}
\item {} 
Monday: Rotating non\sphinxhyphen{}inertial frames, Coriolis force and Foucalt’s pendulum (Taylor sections 9.7\sphinxhyphen{}9.9). Second midterm available, due Fryday April 17.  PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril6.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_utivxb87

\item {} 
Wednesday: Variational calculus and the Euler\sphinxhyphen{}Lagrange equations, chapter 6 of Taylor and lecture notes. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril8.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_rz8vr2ht

\item {} 
Friday: Euler\sphinxhyphen{}Lagrange equations and Lagrangian formalism. Taylor chapter 6 and lecture notes. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril10.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_j5ugthfg

\end{itemize}


\section{Week 16, April 13\sphinxhyphen{}17, 2020}
\label{\detokenize{intro:week-16-april-13-17-2020}}\begin{itemize}
\item {} 
Monday:  Langrangian formalism, discussion of examples. Taylor chapters 6 and 7. 10th homework and extra assignments, due April 24. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril13.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_hxxec3uc

\item {} 
Wednesday: Lagrangian formalism, constraints and Lagrangian multipliers and examples. These topics are covered by Taylor’s sections 7.1,7.2, 7.3, 7.4. Sections 7.5\sphinxhyphen{}7.7 contain several nice examples while section 7.8 goes through conservation laws. The lecture notes cover many of these topics as well.  PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril15.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_2v2se359

\item {} 
Friday:  Lagrangian Formalism, conservation laws and examples, from the classical pendulum to Foucault’s pendulum. Taylor chapter 7 and lecture notes. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril17.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_ftgzt035

\end{itemize}


\section{Week 17, April 20\sphinxhyphen{}24, 2020}
\label{\detokenize{intro:week-17-april-20-24-2020}}\begin{itemize}
\item {} 
Monday:  Lagrangian formalism, conservation laws. Examples. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril20.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_b81t0tta

\item {} 
Wednesday: Lagrangian formalim, examples such as the linear chain and double pendulum. PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril22.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_sp7p28vk

\item {} 
Friday:  Summary and discussions of final exam project. \sphinxstyleemphasis{Final exam project project, due May 1}   PDF file for notes https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/NotesApril24.pdf and video of lecture https://mediaspace.msu.edu/media/t/1\_azwo1s2r

\end{itemize}


\section{Week 18, April 27\sphinxhyphen{} May 1, 2020, Finals week}
\label{\detokenize{intro:week-18-april-27-may-1-2020-finals-week}}\begin{itemize}
\item {} 
Final Exam:  Due to the Corona virus the final exam will be a project similar to the two midterm projects. Deadline May 1. We will have questions sessions Monday 27 and Wednesday 29 at 2.30pm to 4pm. Other sessions can always be arranged. Just send Morten an email or a text.

\end{itemize}


\chapter{Learning outcomes}
\label{\detokenize{intro:learning-outcomes}}
After the course you should:
\begin{itemize}
\item {} 
be able to analyze forces that act on objects, apply Newton’s laws to determine the equations of motion, and solve these analytically and numerically,

\item {} 
Know about  inertial frames and their relation to accelerating and rotating frames (non\sphinxhyphen{}inertial frames)

\item {} 
Know about forces, work, energy, angular momentum, linear momentum and conservation laws

\item {} 
Know about  various types of motions, falling objects, objects moving in various fields

\item {} 
Know how to analyze energy diagrams and defining effective potential

\item {} 
Have knowledge about small oscillations, Harmonic oscillator potential and equations of motion

\item {} 
Have knowledge about transformation of variables that allow for analytical solutions, example two\sphinxhyphen{}body problems

\item {} 
Have knowledge about central forces and two\sphinxhyphen{}body problems, center\sphinxhyphen{}of\sphinxhyphen{}mass and relative coordinates as reference frame

\item {} 
Have knowledge about two\sphinxhyphen{}body scattering problems, classical scattering cross section

\item {} 
Have knowledge about Variational calculus and Lagrangian formalism

\item {} 
Know how to derive the equations of motion from the Lagrangian formalism with and without constraints (Lagrangian multipliers)

\end{itemize}

To solve many of these problems, we have through different projects and weekly exercises studied many systems numerically, from falling objects with and without friction/air resistance, small oscillations (harmonic oscillator), gravitational problems and other central force problems, rotations and the classical pendulum. To solve these systems, we have applied different algorithms for solving differential equations. These are
\begin{itemize}
\item {} 
Euler\sphinxhyphen{}Cromer and Velocity\sphinxhyphen{}Verlet as energy conserving algorithms (time\sphinxhyphen{}independent forces)

\item {} 
Runge\sphinxhyphen{}Kutta family of algorithms for time\sphinxhyphen{}dependent forces
We have also, in connection with for example the work\sphinxhyphen{}energy theorem studied methods for evaluating integrals. These are

\item {} 
Numerical integration using the Trapezoidal, midpoint and Simpson’s rule.

\end{itemize}

You should also have acquired skills in structuring a numerical project, as well as having developed a critical understanding of the pros and cons of the methods and an understanding of their limits and what can go wrong.  Computing means solving scientific problems using computers. It covers numerical as well as symbolic computing. Computing is also about developing an understanding of the scientific process by enhancing algorithmic thinking when solving problems.  Computing competence has
always been a central part of the science and engineering education.
In particular, some of the competences that are important in the development of your own understanding of
computations, we would like to emphasize
\begin{itemize}
\item {} 
derivation, verification, and implementation of algorithms

\item {} 
understanding what can go wrong with algorithms

\item {} 
overview of important, known algorithms for solving mechanics problems (To a extent large differential equations and integration)

\item {} 
understanding how algorithms are used to solve mathematical problems

\item {} 
Making science (your results) reproducible

\item {} 
algorithmic thinking for gaining deeper insights about scientific problems

\end{itemize}


\section{Space, Time, Motion, Reference Frames  and Reminder on vectors and other mathematical quantities}
\label{\detokenize{chapter2:space-time-motion-reference-frames-and-reminder-on-vectors-and-other-mathematical-quantities}}\label{\detokenize{chapter2::doc}}
Our studies will start with the motion of different types of objects
such as a falling ball, a runner, a bicycle etc etc. It means that an
object’s position in space varies with time.
In order to study such systems we need to define
\begin{itemize}
\item {} 
choice of origin

\item {} 
choice of the direction of the axes

\item {} 
choice of positive direction (left\sphinxhyphen{}handed or right\sphinxhyphen{}handed system of reference)

\item {} 
choice of units and dimensions

\end{itemize}

These choices lead to some important questions such as
\begin{itemize}
\item {} 
is the  physics of a system independent of the origin of the axes?

\item {} 
is the  physics independent of the directions of the axes, that is are there privileged axes?

\item {} 
is the physics independent of the orientation of system?

\item {} 
is the physics independent of the scale of the length?

\end{itemize}


\subsection{Dimension, units and labels}
\label{\detokenize{chapter2:dimension-units-and-labels}}
Throughout this course we will use the standardized SI units. The standard unit for length is thus one meter 1m, for mass
one kilogram 1kg, for time one second 1s, for force one Newton 1kgm/s\(^2\) and for energy 1 Joule 1kgm\(^2\)s\(^{-2}\).

We will use the following notations for various variables (vectors are always boldfaced in these lecture notes):
\begin{itemize}
\item {} 
position \(\boldsymbol{r}\), in one dimention we will normally just use \(x\),

\item {} 
mass \(m\),

\item {} 
time \(t\),

\item {} 
velocity \(\boldsymbol{v}\) or just \(v\) in one dimension,

\item {} 
acceleration \(\boldsymbol{a}\) or just \(a\) in one dimension,

\item {} 
momentum \(\boldsymbol{p}\) or just \(p\) in one dimension,

\item {} 
kinetic energy \(K\),

\item {} 
potential energy \(V\) and

\item {} 
frequency \(\omega\).

\end{itemize}

More variables will be defined as we need them.

It is also important to keep track of dimensionalities. Don’t mix this up with a chosen unit for a given variable. We mark the dimensionality in these lectures as \([a]\), where \(a\) is the quantity we are interested in. Thus
\begin{itemize}
\item {} 
\([\boldsymbol{r}]=\) length

\item {} 
\([m]=\) mass

\item {} 
\([K]=\) energy

\item {} 
\([t]=\) time

\item {} 
\([\boldsymbol{v}]=\) length over time

\item {} 
\([\boldsymbol{a}]=\) length over time squared

\item {} 
\([\boldsymbol{p}]=\) mass times length over time

\item {} 
\([\omega]=\) 1/time

\end{itemize}


\subsection{Elements of Vector Algebra}
\label{\detokenize{chapter2:elements-of-vector-algebra}}
\sphinxstylestrong{Note}: This section is under revision

In these lectures we will use boldfaced lower\sphinxhyphen{}case letters to label a vector. A vector \(\boldsymbol{a}\) in three dimensions is thus defined as
\begin{equation*}
\begin{split}
\boldsymbol{a} =(a_x,a_y, a_z),
\end{split}
\end{equation*}
and using the unit vectors in a cartesian system we have
\begin{equation*}
\begin{split}
\boldsymbol{a} = a_x\boldsymbol{e}_x+a_y\boldsymbol{e}_y+a_z\boldsymbol{e}_z,
\end{split}
\end{equation*}
where the unit vectors have magnitude \(\vert\boldsymbol{e}_i\vert = 1\) with \(i=x,y,z\).

Using the fact that multiplication of reals is distributive we can show that
\begin{equation*}
\begin{split}
\boldsymbol{a}(\boldsymbol{b}+\boldsymbol{c})=\boldsymbol{a}\boldsymbol{b}+\boldsymbol{a}\boldsymbol{c},
\end{split}
\end{equation*}
Similarly we can also show that (using product rule for differentiating reals)
\begin{equation*}
\begin{split}
\frac{d}{dt}(\boldsymbol{a}\boldsymbol{b})=\boldsymbol{a}\frac{d\boldsymbol{b}}{dt}+\boldsymbol{b}\frac{d\boldsymbol{a}}{dt}.
\end{split}
\end{equation*}
We can repeat these operations for the cross products and show that they are distribuitive
\begin{equation*}
\begin{split}
\boldsymbol{a}\times(\boldsymbol{b}+\boldsymbol{c})=\boldsymbol{a}\times\boldsymbol{b}+\boldsymbol{a}\times\boldsymbol{c}.
\end{split}
\end{equation*}
We have also that
\begin{equation*}
\begin{split}
\frac{d}{dt}(\boldsymbol{a}\times\boldsymbol{b})=\boldsymbol{a}\times\frac{d\boldsymbol{b}}{dt}+\boldsymbol{b}\times\frac{d\boldsymbol{a}}{dt}.
\end{split}
\end{equation*}
The rotation of a three\sphinxhyphen{}dimensional  vector \(\boldsymbol{a}=(a_x,a_y,a_z)\) in the \(xy\) plane around an angle \(\phi\) results in a new vector \(\boldsymbol{b}=(b_x,b_y,b_z)\).  This operation can be expressed in terms of linear algebra as a matrix (the rotation matrix) multiplied with a vector. We can write this as
\begin{equation*}
\begin{split}
\begin{bmatrix} b_x \\ b_y \\ b_z \end{bmatrix} = \begin{bmatrix} \cos{\phi} & \sin{\phi} & 0 \\ -\sin{\phi} & \cos{\phi} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix} a_x \\ a_y \\ a_z \end{bmatrix}.
\end{split}
\end{equation*}
We can write this in a more compact form as \(\boldsymbol{b} = \boldsymbol{R}\boldsymbol{a}\), where the rotation matrix is defined as
\begin{equation*}
\begin{split}
\boldsymbol{R} = \begin{bmatrix} \cos{\phi} & \sin{\phi} & 0 \\ -\sin{\phi} & \cos{\phi} & 0 \\ 0 & 0 & 1\end{bmatrix}.
\end{split}
\end{equation*}

\subsection{Falling baseball in one dimension}
\label{\detokenize{chapter2:falling-baseball-in-one-dimension}}
We anticipate the mathematical model to come and assume that we have a
model for the motion of a falling baseball without air resistance.
Our system (the baseball) is at an initial height \(y_0\) (which we will
specify in the program below) at the initial time \(t_0=0\). In our program example here we will plot the position in steps of \(\Delta t\) up to a final time \(t_f\).
The mathematical formula for the position \(y(t)\) as function of time \(t\) is
\begin{equation*}
\begin{split}
y(t) = y_0-\frac{1}{2}gt^2,
\end{split}
\end{equation*}
where \(g=9.80665=0.980655\times 10^1\)m/s\(^2\) is a constant representing the standard acceleration due to gravity.
We have here adopted the conventional standard value. This does not take into account other effects, such as buoyancy or drag.
Furthermore, we stop when the ball hits the ground, which takes place at
\begin{equation*}
\begin{split}
y(t) = 0= y_0-\frac{1}{2}gt^2,
\end{split}
\end{equation*}
which gives us a final time \(t_f=\sqrt{2y_0/g}\).

As of now we simply assume that   we know the formula for the falling object. Afterwards, we will derive it.


\subsection{Our Python Encounter}
\label{\detokenize{chapter2:our-python-encounter}}
We start with preparing folders for storing our calculations, figures and if needed, specific data files we use as input or output files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline

\PYG{c+c1}{\PYGZsh{} Common imports}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{c+c1}{\PYGZsh{} Where to save the figures and data files}
\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Results}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{FIGURE\PYGZus{}ID} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Results/FigureFiles}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{DATA\PYGZus{}ID} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DataFiles/}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR}\PYG{p}{)}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{)}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{image\PYGZus{}path}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{,} \PYG{n}{fig\PYGZus{}id}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{data\PYGZus{}path}\PYG{p}{(}\PYG{n}{dat\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{,} \PYG{n}{dat\PYGZus{}id}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}fig}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}in case we have an input file we wish to read in}
\PYG{c+c1}{\PYGZsh{}infile = open(data\PYGZus{}path(\PYGZdq{}MassEval2016.dat\PYGZdq{}),\PYGZsq{}r\PYGZsq{})}
\end{sphinxVerbatim}

You could also define a function for making our plots. You
can obviously avoid this and simply set up various \sphinxstylestrong{matplotlib}
commands every time you need them. You may however find it convenient
to collect all such commands in one function and simply call this
function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pylab} \PYG{k+kn}{import} \PYG{n}{plt}\PYG{p}{,} \PYG{n}{mpl}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mpl}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{font.family}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{serif}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{def} \PYG{n+nf}{MakePlot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,} \PYG{n}{styles}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{,} \PYG{n}{axlabels}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{styles}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{labels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{n}{axlabels}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{n}{axlabels}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

Thereafter we start setting up the code for the falling object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{patches} \PYG{k}{as} \PYG{n+nn}{mpatches}

\PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{9.80655} \PYG{c+c1}{\PYGZsh{}m/s\PYGZca{}2}
\PYG{n}{y\PYGZus{}0} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{c+c1}{\PYGZsh{} initial position in meters}
\PYG{n}{DeltaT} \PYG{o}{=} \PYG{l+m+mf}{0.1}  \PYG{c+c1}{\PYGZsh{} time step}
\PYG{c+c1}{\PYGZsh{} final time when y = 0, t = sqrt(2*10/g)}
\PYG{n}{tfinal} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{y\PYGZus{}0}\PYG{o}{/}\PYG{n}{g}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}set up arrays }
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{tfinal}\PYG{p}{,}\PYG{n}{DeltaT}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=}\PYG{n}{y\PYGZus{}0} \PYG{o}{\PYGZhy{}}\PYG{n}{g}\PYG{o}{*}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{t}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{c+c1}{\PYGZsh{} Then make a nice printout in table form using Pandas}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t[s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{t}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y[m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{y}
        \PYG{p}{\PYGZcb{}}
\PYG{n}{RawData} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{RawData}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ggplot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{blue\PYGZus{}patch} \PYG{o}{=} \PYG{n}{mpatches}\PYG{o}{.}\PYG{n}{Patch}\PYG{p}{(}\PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Height y as function of  time t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{handles}\PYG{o}{=}\PYG{p}{[}\PYG{n}{blue\PYGZus{}patch}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t[s]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y[m]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{save\PYGZus{}fig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FallingBaseball}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    t[s]       y[m]
0    0.0  10.000000
1    0.1   9.950967
2    0.2   9.803869
3    0.3   9.558705
4    0.4   9.215476
5    0.5   8.774181
6    0.6   8.234821
7    0.7   7.597395
8    0.8   6.861904
9    0.9   6.028347
10   1.0   5.096725
11   1.1   4.067037
12   1.2   2.939284
13   1.3   1.713465
14   1.4   0.389581
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{chapter2_25_1}.png}

Here we used \sphinxstylestrong{pandas} (see below) to systemize the output of the position as function of time.


\subsection{Average quantities}
\label{\detokenize{chapter2:average-quantities}}
We define now the average velocity as
\begin{equation*}
\begin{split}
\overline{v}(t) = \frac{y(t+\Delta t)-y(t)}{\Delta t}.
\end{split}
\end{equation*}
In the code we have set the time step \(\Delta t\) to a given value. We could define it in terms of the number of points \(n\) as
\begin{equation*}
\begin{split}
\Delta t = \frac{t_{\mathrm{final}-}t_{\mathrm{initial}}}{n+1}.
\end{split}
\end{equation*}
Since we have discretized the variables, we introduce the counter \(i\) and let \(y(t)\rightarrow y(t_i)=y_i\) and \(t\rightarrow t_i\)
with \(i=0,1,\dots, n\). This gives us the following shorthand notations that we will use for the rest of this course. We define
\begin{equation*}
\begin{split}
y_i = y(t_i),\hspace{0.2cm} i=0,1,2,\dots,n.
\end{split}
\end{equation*}
This applies to other variables which depend on say time. Examples are the velocities, accelerations, momenta etc.
Furthermore we use the shorthand
\begin{equation*}
\begin{split}
y_{i\pm 1} = y(t_i\pm \Delta t),\hspace{0.12cm} i=0,1,2,\dots,n.
\end{split}
\end{equation*}

\subsection{Compact equations}
\label{\detokenize{chapter2:compact-equations}}
We can then rewrite in a more compact form the average velocity as
\begin{equation*}
\begin{split}
\overline{v}_i = \frac{y_{i+1}-y_{i}}{\Delta t}.
\end{split}
\end{equation*}
The velocity is defined as the change in position per unit time.
In the limit \(\Delta t \rightarrow 0\) this defines the instantaneous velocity, which is nothing but the slope of the position at a time \(t\).
We have thus
\begin{equation*}
\begin{split}
v(t) = \frac{dy}{dt}=\lim_{\Delta t \rightarrow 0}\frac{y(t+\Delta t)-y(t)}{\Delta t}.
\end{split}
\end{equation*}
Similarly, we can define the average acceleration as the change in velocity per unit time as
\begin{equation*}
\begin{split}
\overline{a}_i = \frac{v_{i+1}-v_{i}}{\Delta t},
\end{split}
\end{equation*}
resulting in the instantaneous acceleration
\begin{equation*}
\begin{split}
a(t) = \frac{dv}{dt}=\lim_{\Delta t\rightarrow 0}\frac{v(t+\Delta t)-v(t)}{\Delta t}.
\end{split}
\end{equation*}
\sphinxstylestrong{A note on notations}: When writing for example the velocity as \(v(t)\) we are then referring to the continuous and instantaneous value. A subscript like
\(v_i\) refers always to the discretized values.


\subsection{A differential equation}
\label{\detokenize{chapter2:a-differential-equation}}
We can rewrite the instantaneous acceleration as
\begin{equation*}
\begin{split}
a(t) = \frac{dv}{dt}=\frac{d}{dt}\frac{dy}{dt}=\frac{d^2y}{dt^2}.
\end{split}
\end{equation*}
This forms the starting point for our definition of forces later. It is a famous second\sphinxhyphen{}order differential equation. If the acceleration is constant we can now recover the formula for the falling ball we started with.
The acceleration can depend on the position and the velocity. To be more formal we should then write the above differential equation as
\begin{equation*}
\begin{split}
\frac{d^2y}{dt^2}=a(t,y(t),\frac{dy}{dt}).
\end{split}
\end{equation*}
With given initial conditions for \(y(t_0)\) and \(v(t_0)\) we can then
integrate the above equation and find the velocities and positions at
a given time \(t\).

If we multiply with mass, we have one of the famous expressions for Newton’s second law,
\begin{equation*}
\begin{split}
F(y,v,t)=m\frac{d^2y}{dt^2}=ma(t,y(t),\frac{dy}{dt}),
\end{split}
\end{equation*}
where \(F\) is the force acting on an object with mass \(m\). We see that it also has the right dimension, mass times length divided by time squared.
We will come back to this soon.


\subsection{Integrating our equations}
\label{\detokenize{chapter2:integrating-our-equations}}
Formally we can then, starting with the acceleration (suppose we have measured it, how could we do that?)
compute say the height of a building.  To see this we perform the following integrations from an initial time \(t_0\)  to a given time \(t\)
\begin{equation*}
\begin{split}
\int_{t_0}^t dt a(t) = \int_{t_0}^t dt \frac{dv}{dt} = v(t)-v(t_0),
\end{split}
\end{equation*}
or as
\begin{equation*}
\begin{split}
v(t)=v(t_0)+\int_{t_0}^t dt a(t).
\end{split}
\end{equation*}
When we know the velocity as function of time, we can find the position as function of time starting from the defintion of velocity as the derivative with respect to time, that is we have
\begin{equation*}
\begin{split}
\int_{t_0}^t dt v(t) = \int_{t_0}^t dt \frac{dy}{dt} = y(t)-y(t_0),
\end{split}
\end{equation*}
or as
\begin{equation*}
\begin{split}
y(t)=y(t_0)+\int_{t_0}^t dt v(t).
\end{split}
\end{equation*}
These equations define what is called the integration method for
finding the position and the velocity as functions of time. There is
no loss of generality if we extend these equations to more than one
spatial dimension.


\subsection{Constant acceleration case, the velocity}
\label{\detokenize{chapter2:constant-acceleration-case-the-velocity}}
Let us compute the velocity using the constant value for the acceleration given by \(-g\). We have
\begin{equation*}
\begin{split}
v(t)=v(t_0)+\int_{t_0}^t dt a(t)=v(t_0)+\int_{t_0}^t dt (-g).
\end{split}
\end{equation*}
Using our initial time as \(t_0=0\)s and setting the initial velocity \(v(t_0)=v_0=0\)m/s we get when integrating
\begin{equation*}
\begin{split}
v(t)=-gt.
\end{split}
\end{equation*}
The more general case is
\begin{equation*}
\begin{split}
v(t)=v_0-g(t-t_0).
\end{split}
\end{equation*}
We can then integrate the velocity and obtain the final formula for the position as function of time through
\begin{equation*}
\begin{split}
y(t)=y(t_0)+\int_{t_0}^t dt v(t)=y_0+\int_{t_0}^t dt v(t)=y_0+\int_{t_0}^t dt (-gt),
\end{split}
\end{equation*}
With \(y_0=10\)m and \(t_0=0\)s, we obtain the equation we started with
\begin{equation*}
\begin{split}
y(t)=10-\frac{1}{2}gt^2.
\end{split}
\end{equation*}

\subsection{Computing the averages}
\label{\detokenize{chapter2:computing-the-averages}}
After this mathematical background we are now ready to compute the mean velocity using our data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Now we can compute the mean velocity using our data}
\PYG{c+c1}{\PYGZsh{} We define first an array Vaverage}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{n}{Vaverage} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Vaverage}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{DeltaT}
\PYG{c+c1}{\PYGZsh{} Now we can compute the mean accelearatio using our data}
\PYG{c+c1}{\PYGZsh{} We define first an array Aaverage}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{n}{Aaverage} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{Aaverage}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{g}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Aaverage}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Vaverage}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{Vaverage}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{DeltaT}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t[s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{t}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y[m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{y}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v[m/s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{Vaverage}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a[m/s\PYGZca{}2]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{Aaverage}
        \PYG{p}{\PYGZcb{}}
\PYG{n}{NewData} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{NewData}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    t[s]       y[m]     v[m/s]  a[m/s\PYGZca{}2]
0    0.0  10.000000   0.000000  \PYGZhy{}9.80655
1    0.1   9.950967  \PYGZhy{}1.470982  \PYGZhy{}9.80655
2    0.2   9.803869  \PYGZhy{}2.451638  \PYGZhy{}9.80655
3    0.3   9.558705  \PYGZhy{}3.432292  \PYGZhy{}9.80655
4    0.4   9.215476  \PYGZhy{}4.412948  \PYGZhy{}9.80655
5    0.5   8.774181  \PYGZhy{}5.393602  \PYGZhy{}9.80655
6    0.6   8.234821  \PYGZhy{}6.374258  \PYGZhy{}9.80655
7    0.7   7.597395  \PYGZhy{}7.354913  \PYGZhy{}9.80655
8    0.8   6.861904  \PYGZhy{}8.335567  \PYGZhy{}9.80655
9    0.9   6.028347  \PYGZhy{}9.316222  \PYGZhy{}9.80655
10   1.0   5.096725 \PYGZhy{}10.296878  \PYGZhy{}9.80655
11   1.1   4.067037 \PYGZhy{}11.277533  \PYGZhy{}9.80655
12   1.2   2.939284 \PYGZhy{}12.258187  \PYGZhy{}9.80655
\end{sphinxVerbatim}

Note that we don’t print the last values!


\subsection{Including Air Resistance in our model}
\label{\detokenize{chapter2:including-air-resistance-in-our-model}}
In our discussions till now of the falling baseball, we have ignored
air resistance and simply assumed that our system is only influenced
by the gravitational force.  We will postpone the derivation of air
resistance till later, after our discussion of Newton’s laws and
forces.

For our discussions here it suffices to state that the accelerations is now modified to
\begin{equation*}
\begin{split}
\boldsymbol{a}(t) = -g +D\boldsymbol{v}(t)\vert v(t)\vert,
\end{split}
\end{equation*}
where \(\vert v(t)\vert\) is the absolute value of the velocity and \(D\) is a constant which pertains to the specific object we are studying.
Since we are dealing with motion in one dimension, we can simplify the above to
\begin{equation*}
\begin{split}
a(t) = -g +Dv^2(t).
\end{split}
\end{equation*}
We can rewrite this as a differential equation
\begin{equation*}
\begin{split}
a(t) = \frac{dv}{dt}=\frac{d^2y}{dt^2}= -g +Dv^2(t).
\end{split}
\end{equation*}
Using the integral equations discussed above we can integrate twice
and obtain first the velocity as function of time and thereafter the
position as function of time.

For this particular case, we can actually obtain an analytical
solution for the velocity and for the position. Here we will first
compute the solutions analytically, thereafter we will derive Euler’s
method for solving these differential equations numerically.


\subsection{Analytical solutions}
\label{\detokenize{chapter2:analytical-solutions}}
For simplicity let us just write \(v(t)\) as \(v\). We have
\begin{equation*}
\begin{split}
\frac{dv}{dt}= -g +Dv^2(t).
\end{split}
\end{equation*}
We can solve this using the technique of separation of variables. We
isolate on the left all terms that involve \(v\) and on the right all
terms that involve time. We get then
\begin{equation*}
\begin{split}
\frac{dv}{g -Dv^2(t) }= -dt,
\end{split}
\end{equation*}
We scale now the equation to the left by introducing a constant
\(v_T=\sqrt{g/D}\). This constant has dimension length/time. Can you
show this?

Next we integrate the left\sphinxhyphen{}hand side (lhs) from \(v_0=0\) m/s to \(v\) and
the right\sphinxhyphen{}hand side (rhs) from \(t_0=0\) to \(t\) and obtain
\begin{equation*}
\begin{split}
\int_{0}^v\frac{dv}{g -Dv^2(t) }= \frac{v_T}{g}\mathrm{arctanh}(\frac{v}{v_T})  =-\int_0^tdt = -t.
\end{split}
\end{equation*}
We can reorganize these equations as
\begin{equation*}
\begin{split}
v_T\mathrm{arctanh}(\frac{v}{v_T})  =-gt,
\end{split}
\end{equation*}
which gives us \(v\) as function of time
\begin{equation*}
\begin{split}
v(t)=v_T\tanh{-(\frac{gt}{v_T})}.
\end{split}
\end{equation*}

\subsection{Finding the final height}
\label{\detokenize{chapter2:finding-the-final-height}}
With the velocity we can then find the height \(y(t)\) by integrating yet another time, that is
\begin{equation*}
\begin{split}
y(t)=y(t_0)+\int_{t_0}^t dt v(t)=\int_{0}^t dt[v_T\tanh{-(\frac{gt}{v_T})}].
\end{split}
\end{equation*}
This integral is a little bit trickier but we can look it up in a table over
known integrals and we get
\begin{equation*}
\begin{split}
y(t)=y(t_0)-\frac{v_T^2}{g}\log{[\cosh{(\frac{gt}{v_T})}]}.
\end{split}
\end{equation*}
Alternatively we could have used the symbolic Python package \sphinxstylestrong{Sympy}  (example will be inserted later).

In most cases however, we need to revert to numerical solutions.


\subsection{Our first attempt at solving differential equations}
\label{\detokenize{chapter2:our-first-attempt-at-solving-differential-equations}}
Here we will try the simplest possible approach to solving the second\sphinxhyphen{}order differential
equation
\begin{equation*}
\begin{split}
a(t) =\frac{d^2y}{dt^2}= -g +Dv^2(t).
\end{split}
\end{equation*}
We rewrite it as two coupled first\sphinxhyphen{}order equations (this is a standard approach)
\begin{equation*}
\begin{split}
\frac{dy}{dt} = v(t),
\end{split}
\end{equation*}
with initial condition \(y(t_0)=y_0\) and
\begin{equation*}
\begin{split}
a(t) =\frac{dv}{dt}= -g +Dv^2(t),
\end{split}
\end{equation*}
with initial condition \(v(t_0)=v_0\).

Many of the algorithms for solving differential equations start with simple Taylor equations.
If we now Taylor expand \(y\) and \(v\) around a value \(t+\Delta t\) we have
\begin{equation*}
\begin{split}
y(t+\Delta t) = y(t)+\Delta t \frac{dy}{dt}+\frac{\Delta t^2}{2!} \frac{d^2y}{dt^2}+O(\Delta t^3),
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
v(t+\Delta t) = v(t)+\Delta t \frac{dv}{dt}+\frac{\Delta t^2}{2!} \frac{d^2v}{dt^2}+O(\Delta t^3).
\end{split}
\end{equation*}
Using the fact that \(dy/dt = v\) and \(dv/dt=a\) and keeping only terms up to \(\Delta t\) we have
\begin{equation*}
\begin{split}
y(t+\Delta t) = y(t)+\Delta t v(t)+O(\Delta t^2),
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
v(t+\Delta t) = v(t)+\Delta t a(t)+O(\Delta t^2).
\end{split}
\end{equation*}

\subsection{Discretizing our equations}
\label{\detokenize{chapter2:discretizing-our-equations}}
Using our discretized versions of the equations with for example
\(y_{i}=y(t_i)\) and \(y_{i\pm 1}=y(t_i+\Delta t)\), we can rewrite the
above equations as (and truncating at \(\Delta t\))
\begin{equation*}
\begin{split}
y_{i+1} = y_i+\Delta t v_i,
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
v_{i+1} = v_i+\Delta t a_i.
\end{split}
\end{equation*}
These are the famous Euler equations (forward Euler).

To solve these equations numerically we start at a time \(t_0\) and simply integrate up these equations to a final time \(t_f\),
The step size \(\Delta t\) is an input  parameter in our code.
You can define it directly in the code below as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DeltaT} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\end{sphinxVerbatim}

With a given final time \sphinxstylestrong{tfinal}  we can then find the number of integration points via the \sphinxstylestrong{ceil} function included in the \sphinxstylestrong{math} package of Python
as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define final time, assuming that initial time is zero}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{ceil}
\PYG{n}{tfinal} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{ceil}\PYG{p}{(}\PYG{n}{tfinal}\PYG{o}{/}\PYG{n}{DeltaT}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

The \sphinxstylestrong{ceil} function returns the smallest integer not less than the input in say

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{21.15}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
22
\end{sphinxVerbatim}

which in the case here is 22.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{21.75}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
22
\end{sphinxVerbatim}

which also yields 22. The  \sphinxstylestrong{floor} function in the \sphinxstylestrong{math} package
is used to return the closest integer value which is less than or equal to the specified expression or value.
Compare the previous result to the usage of \sphinxstylestrong{floor}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{floor}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{21.75}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
21
\end{sphinxVerbatim}

Alternatively, we can define ourselves the number of integration(mesh) points. In this case we could have

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{tinitial} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{tfinal} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{DeltaT} \PYG{o}{=} \PYG{p}{(}\PYG{n}{tfinal}\PYG{o}{\PYGZhy{}}\PYG{n}{tinitial}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{DeltaT}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.05
\end{sphinxVerbatim}

Since we will set up one\sphinxhyphen{}dimensional arrays that contain the values of
various variables like time, position, velocity, acceleration etc, we
need to know the value of \(n\), the number of data points (or
integration or mesh points).  With \(n\) we can initialize a given array
by setting all elelements to zero, as done here

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define array a}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
\end{sphinxVerbatim}


\subsection{Code for implementing Euler’s method}
\label{\detokenize{chapter2:code-for-implementing-euler-s-method}}
In the code here we implement this simple Eurler scheme choosing a value for \(D=0.0245\) m/s.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Common imports}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{c+c1}{\PYGZsh{} Where to save the figures and data files}
\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Results}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{FIGURE\PYGZus{}ID} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Results/FigureFiles}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{DATA\PYGZus{}ID} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DataFiles/}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}ROOT\PYGZus{}DIR}\PYG{p}{)}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{)}

\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{image\PYGZus{}path}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{FIGURE\PYGZus{}ID}\PYG{p}{,} \PYG{n}{fig\PYGZus{}id}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{data\PYGZus{}path}\PYG{p}{(}\PYG{n}{dat\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DATA\PYGZus{}ID}\PYG{p}{,} \PYG{n}{dat\PYGZus{}id}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}fig}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{(}\PYG{n}{fig\PYGZus{}id}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{9.80655} \PYG{c+c1}{\PYGZsh{}m/s\PYGZca{}2}
\PYG{n}{D} \PYG{o}{=} \PYG{l+m+mf}{0.00245} \PYG{c+c1}{\PYGZsh{}m/s}
\PYG{n}{DeltaT} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{c+c1}{\PYGZsh{}set up arrays }
\PYG{n}{tfinal} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{ceil}\PYG{p}{(}\PYG{n}{tfinal}\PYG{o}{/}\PYG{n}{DeltaT}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} define scaling constant vT}
\PYG{n}{vT} \PYG{o}{=} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{g}\PYG{o}{/}\PYG{n}{D}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set up arrays for t, a, v, and y and we can compare our results with analytical ones}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{yanalytic} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Initial conditions}
\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.0}  \PYG{c+c1}{\PYGZsh{}m/s}
\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{c+c1}{\PYGZsh{}m}
\PYG{n}{yanalytic}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Start integrating using Euler\PYGZsq{}s method}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} expression for acceleration}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{o}{+} \PYG{n}{D}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} update velocity and position}
    \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{DeltaT}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{DeltaT}\PYG{o}{*}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} update time to next time step and compute analytical answer}
    \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{DeltaT}
    \PYG{n}{yanalytic}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{vT}\PYG{o}{*}\PYG{n}{vT}\PYG{o}{/}\PYG{n}{g}\PYG{p}{)}\PYG{o}{*}\PYG{n}{log}\PYG{p}{(}\PYG{n}{cosh}\PYG{p}{(}\PYG{n}{g}\PYG{o}{*}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{vT}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{break}
\PYG{n}{a}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{o}{+} \PYG{n}{D}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t[s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{t}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y[m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{yanalytic}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v[m/s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{v}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a[m/s\PYGZca{}2]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{a}
        \PYG{p}{\PYGZcb{}}
\PYG{n}{NewData} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{NewData}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}finally we plot the data}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{yanalytic}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tfinal}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y and exact}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v[m/s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time[s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a[m/s\PYGZca{}2]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{save\PYGZus{}fig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EulerIntegration}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   t[s]      y[m]    v[m/s]  a[m/s\PYGZca{}2]
0   0.0  0.000000  0.000000 \PYGZhy{}9.806550
1   0.1  0.049031 \PYGZhy{}0.980655 \PYGZhy{}9.804194
2   0.2  0.098034 \PYGZhy{}1.961074 \PYGZhy{}9.797128
3   0.3  0.146963 \PYGZhy{}2.940787 \PYGZhy{}9.785362
4   0.4  0.195770 \PYGZhy{}3.919323 \PYGZhy{}9.768915
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{chapter2_121_1}.png}

Try different values for \(\Delta t\) and study the difference between the exact solution and the numerical solution.


\subsection{Simple extension, the Euler\sphinxhyphen{}Cromer method}
\label{\detokenize{chapter2:simple-extension-the-euler-cromer-method}}
The Euler\sphinxhyphen{}Cromer method is a simple variant of the standard Euler
method. We use the newly updated velocity \(v_{i+1}\) as an input to the
new position, that is, instead of
\begin{equation*}
\begin{split}
y_{i+1} = y_i+\Delta t v_i,
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
v_{i+1} = v_i+\Delta t a_i,
\end{split}
\end{equation*}
we use now the newly calculate for \(v_{i+1}\) as input to \(y_{i+1}\), that is
we compute first
\begin{equation*}
\begin{split}
v_{i+1} = v_i+\Delta t a_i,
\end{split}
\end{equation*}
and then
\begin{equation*}
\begin{split}
y_{i+1} = y_i+\Delta t v_{i+1},
\end{split}
\end{equation*}
Implementing the Euler\sphinxhyphen{}Cromer method yields a simple change to the previous code. We only need to change the following line in the loop over time
steps

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} more codes in between here}
    \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{DeltaT}\PYG{o}{*}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{DeltaT}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} more code}
\end{sphinxVerbatim}


\subsection{Python practicalities, Software and needed installations}
\label{\detokenize{chapter2:python-practicalities-software-and-needed-installations}}
We will make extensive use of Python as programming language and its
myriad of available libraries.  You will find
Jupyter notebooks invaluable in your work.

If you have Python installed (we strongly recommend Python3) and you feel
pretty familiar with installing different packages, we recommend that
you install the following Python packages via \sphinxstylestrong{pip} as
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
pip install numpy scipy matplotlib ipython scikit\sphinxhyphen{}learn mglearn sympy pandas pillow

\end{enumerate}

For Python3, replace \sphinxstylestrong{pip} with \sphinxstylestrong{pip3}.

For OSX users we recommend, after having installed Xcode, to
install \sphinxstylestrong{brew}. Brew allows for a seamless installation of additional
software via for example
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
brew install python3

\end{enumerate}

For Linux users, with its variety of distributions like for example the widely popular Ubuntu distribution,
you can use \sphinxstylestrong{pip} as well and simply install Python as
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
sudo apt\sphinxhyphen{}get install python3  (or python for pyhton2.7)

\end{enumerate}

etc etc.


\subsection{Python installers}
\label{\detokenize{chapter2:python-installers}}
If you don’t want to perform these operations separately and venture
into the hassle of exploring how to set up dependencies and paths, we
recommend two widely used distrubutions which set up all relevant
dependencies for Python, namely
\begin{itemize}
\item {} 
\sphinxhref{https://docs.anaconda.com/}{Anaconda},

\end{itemize}

which is an open source
distribution of the Python and R programming languages for large\sphinxhyphen{}scale
data processing, predictive analytics, and scientific computing, that
aims to simplify package management and deployment. Package versions
are managed by the package management system \sphinxstylestrong{conda}.
\begin{itemize}
\item {} 
\sphinxhref{https://www.enthought.com/product/canopy/}{Enthought canopy}

\end{itemize}

is a Python
distribution for scientific and analytic computing distribution and
analysis environment, available for free and under a commercial
license.

Furthermore, \sphinxhref{https://colab.research.google.com/notebooks/welcome.ipynb}{Google’s Colab} is a free Jupyter notebook environment that requires
no setup and runs entirely in the cloud. Try it out!


\subsection{Useful Python libraries}
\label{\detokenize{chapter2:useful-python-libraries}}
Here we list several useful Python libraries we strongly recommend (if you use anaconda many of these are already there)
\begin{itemize}
\item {} 
\sphinxhref{https://www.numpy.org/}{NumPy} is a highly popular library for large, multi\sphinxhyphen{}dimensional arrays and matrices, along with a large collection of high\sphinxhyphen{}level mathematical functions to operate on these arrays

\item {} 
\sphinxhref{https://pandas.pydata.org/}{The pandas} library provides high\sphinxhyphen{}performance, easy\sphinxhyphen{}to\sphinxhyphen{}use data structures and data analysis tools

\item {} 
\sphinxhref{http://xarray.pydata.org/en/stable/}{Xarray} is a Python package that makes working with labelled multi\sphinxhyphen{}dimensional arrays simple, efficient, and fun!

\item {} 
\sphinxhref{https://www.scipy.org/}{Scipy} (pronounced “Sigh Pie”) is a Python\sphinxhyphen{}based ecosystem of open\sphinxhyphen{}source software for mathematics, science, and engineering.

\item {} 
\sphinxhref{https://matplotlib.org/}{Matplotlib} is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms.

\item {} 
\sphinxhref{https://github.com/HIPS/autograd}{Autograd} can automatically differentiate native Python and Numpy code. It can handle a large subset of Python’s features, including loops, ifs, recursion and closures, and it can even take derivatives of derivatives of derivatives

\item {} 
\sphinxhref{https://www.sympy.org/en/index.html}{SymPy} is a Python library for symbolic mathematics.

\item {} 
\sphinxhref{https://scikit-learn.org/stable/}{scikit\sphinxhyphen{}learn} has simple and efficient tools for machine learning, data mining and data analysis

\item {} 
\sphinxhref{https://www.tensorflow.org/}{TensorFlow} is a Python library for fast numerical computing created and released by Google

\item {} 
\sphinxhref{https://keras.io/}{Keras} is a high\sphinxhyphen{}level neural networks API, written in Python and capable of running on top of TensorFlow, CNTK, or Theano

\item {} 
And many more such as \sphinxhref{https://pytorch.org/}{pytorch},  \sphinxhref{https://pypi.org/project/Theano/}{Theano} etc

\end{itemize}

Your jupyter notebook can easily be
converted into a nicely rendered \sphinxstylestrong{PDF} file or a Latex file for
further processing. For example, convert to latex as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    pycod jupyter nbconvert filename.ipynb \PYGZhy{}\PYGZhy{}to latex 
\end{sphinxVerbatim}

And to add more versatility, the Python package \sphinxhref{http://www.sympy.org/en/index.html}{SymPy} is a Python library for symbolic mathematics. It aims to become a full\sphinxhyphen{}featured computer algebra system (CAS)  and is entirely written in Python.


\subsection{Numpy examples and Important Matrix and vector handling packages}
\label{\detokenize{chapter2:numpy-examples-and-important-matrix-and-vector-handling-packages}}
There are several central software libraries for linear algebra and eigenvalue problems. Several of the more
popular ones have been wrapped into ofter software packages like those from the widely used text \sphinxstylestrong{Numerical Recipes}. The original source codes in many of the available packages are often taken from the widely used
software package LAPACK, which follows two other popular packages
developed in the 1970s, namely EISPACK and LINPACK.  We describe them shortly here.
\begin{itemize}
\item {} 
LINPACK: package for linear equations and least square problems.

\item {} 
LAPACK:package for solving symmetric, unsymmetric and generalized eigenvalue problems. From LAPACK’s website \sphinxurl{http://www.netlib.org} it is possible to download for free all source codes from this library. Both C/C++ and Fortran versions are available.

\item {} 
BLAS (I, II and III): (Basic Linear Algebra Subprograms) are routines that provide standard building blocks for performing basic vector and matrix operations. Blas I is vector operations, II vector\sphinxhyphen{}matrix operations and III matrix\sphinxhyphen{}matrix operations. Highly parallelized and efficient codes, all available for download from \sphinxurl{http://www.netlib.org}.

\end{itemize}


\subsection{Basic Matrix Features}
\label{\detokenize{chapter2:basic-matrix-features}}
\sphinxstylestrong{Matrix properties reminder.}
\begin{equation*}
\begin{split}
\mathbf{A} =
      \begin{bmatrix} a_{11} & a_{12} & a_{13} & a_{14} \\
                                 a_{21} & a_{22} & a_{23} & a_{24} \\
                                   a_{31} & a_{32} & a_{33} & a_{34} \\
                                  a_{41} & a_{42} & a_{43} & a_{44}
             \end{bmatrix}\qquad
\mathbf{I} =
      \begin{bmatrix} 1 & 0 & 0 & 0 \\
                                 0 & 1 & 0 & 0 \\
                                 0 & 0 & 1 & 0 \\
                                 0 & 0 & 0 & 1
             \end{bmatrix}
\end{split}
\end{equation*}
The inverse of a matrix is defined by
\begin{equation*}
\begin{split}
\mathbf{A}^{-1} \cdot \mathbf{A} = I
\end{split}
\end{equation*}



\subsubsection{Some famous Matrices}
\label{\detokenize{chapter2:some-famous-matrices}}\begin{itemize}
\item {} 
Diagonal if \(a_{ij}=0\) for \(i\ne j\)

\item {} 
Upper triangular if \(a_{ij}=0\) for \(i > j\)

\item {} 
Lower triangular if \(a_{ij}=0\) for \(i < j\)

\item {} 
Upper Hessenberg if \(a_{ij}=0\) for \(i > j+1\)

\item {} 
Lower Hessenberg if \(a_{ij}=0\) for \(i < j+1\)

\item {} 
Tridiagonal if \(a_{ij}=0\) for \(|i -j| > 1\)

\item {} 
Lower banded with bandwidth \(p\): \(a_{ij}=0\) for \(i > j+p\)

\item {} 
Upper banded with bandwidth \(p\): \(a_{ij}=0\) for \(i < j+p\)

\item {} 
Banded, block upper triangular, block lower triangular….

\end{itemize}


\subsubsection{More Basic Matrix Features}
\label{\detokenize{chapter2:more-basic-matrix-features}}
\sphinxstylestrong{Some Equivalent Statements.}

For an \(N\times N\) matrix  \(\mathbf{A}\) the following properties are all equivalent
\begin{itemize}
\item {} 
If the inverse of \(\mathbf{A}\) exists, \(\mathbf{A}\) is nonsingular.

\item {} 
The equation \(\mathbf{Ax}=0\) implies \(\mathbf{x}=0\).

\item {} 
The rows of \(\mathbf{A}\) form a basis of \(R^N\).

\item {} 
The columns of \(\mathbf{A}\) form a basis of \(R^N\).

\item {} 
\(\mathbf{A}\) is a product of elementary matrices.

\item {} 
\(0\) is not eigenvalue of \(\mathbf{A}\).

\end{itemize}


\subsection{Numpy and arrays}
\label{\detokenize{chapter2:numpy-and-arrays}}
\sphinxhref{http://www.numpy.org/}{Numpy} provides an easy way to handle arrays in Python. The standard way to import this library is as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

Here follows a simple example where we set up an array of ten elements, all determined by random numbers drawn according to the normal distribution,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n}{n}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[ 0.86346649  0.50790833 \PYGZhy{}1.81262148  1.96432159  1.06696328  1.49329983
  1.98850472  0.68412956 \PYGZhy{}1.65689402 \PYGZhy{}0.46548886]
\end{sphinxVerbatim}

We defined a vector \(x\) with \(n=10\) elements with its values given by the Normal distribution \(N(0,1)\).
Another alternative is to declare a vector as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1 2 3]
\end{sphinxVerbatim}

Here we have defined a vector with three elements, with \(x_0=1\), \(x_1=2\) and \(x_2=3\). Note that both Python and C++
start numbering array elements from \(0\) and on. This means that a vector with \(n\) elements has a sequence of entities \(x_0, x_1, x_2, \dots, x_{n-1}\). We could also let (recommended) Numpy to compute the logarithms of a specific array as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1.38629436 1.94591015 2.07944154]
\end{sphinxVerbatim}

In the last example we used Numpy’s unary function \(np.log\). This function is
highly tuned to compute array elements since the code is vectorized
and does not require looping. We normaly recommend that you use the
Numpy intrinsic functions instead of the corresponding \sphinxstylestrong{log} function
from Python’s \sphinxstylestrong{math} module. The looping is done explicitely by the
\sphinxstylestrong{np.log} function. The alternative, and slower way to compute the
logarithms of a vector would be to write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{log}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1 1 2]
\end{sphinxVerbatim}

We note that our code is much longer already and we need to import the \sphinxstylestrong{log} function from the \sphinxstylestrong{math} module.
The attentive reader will also notice that the output is \([1, 1, 2]\). Python interprets automagically our numbers as integers (like the \sphinxstylestrong{automatic} keyword in C++). To change this we could define our array elements to be double precision numbers as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1.38629436 1.94591015 2.07944154]
\end{sphinxVerbatim}

or simply write them as double precision numbers (Python uses 64 bits as default for floating point type variables), that is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}20\PYGZhy{}f6d7a289d493\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{3}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

To check the number of bytes (remember that one byte contains eight bits for double precision variables), you can use simple use the \sphinxstylestrong{itemsize} functionality (the array \(x\) is actually an object which inherits the functionalities defined in Numpy) as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{itemsize}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Matrices in Python}
\label{\detokenize{chapter2:matrices-in-python}}
Having defined vectors, we are now ready to try out matrices. We can
define a \(3 \times 3 \) real matrix \(\hat{A}\) as (recall that we user
lowercase letters for vectors and uppercase letters for matrices)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{]} \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

If we use the \sphinxstylestrong{shape} function we would get \((3, 3)\) as output, that is verifying that our matrix is a \(3\times 3\) matrix. We can slice the matrix and print for example the first column (Python organized matrix elements in a row\sphinxhyphen{}major order, see below) as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{]} \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print the first column, row\PYGZhy{}major order and elements start with 0}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

We can continue this was by printing out other columns or rows. The example here prints out the second column

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{]} \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print the first column, row\PYGZhy{}major order and elements start with 0}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Numpy contains many other functionalities that allow us to slice, subdivide etc etc arrays. We strongly recommend that you look up the \sphinxhref{http://www.numpy.org/}{Numpy website for more details}. Useful functions when defining a matrix are the \sphinxstylestrong{np.zeros} function which declares a matrix of a given dimension and sets all elements to zero

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{} define a matrix of dimension 10 x 10 and set all elements to zero}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(} \PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

or initializing all elements to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{} define a matrix of dimension 10 x 10 and set all elements to one}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(} \PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

or as unitarily distributed random numbers (see the material on random number generators in the statistics part)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{} define a matrix of dimension 10 x 10 and set all elements to random numbers with x \PYGZbs{}in [0, 1]}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Meet the Pandas}
\label{\detokenize{chapter2:meet-the-pandas}}








Another useful Python package is
\sphinxhref{https://pandas.pydata.org/}{pandas}, which is an open source library
providing high\sphinxhyphen{}performance, easy\sphinxhyphen{}to\sphinxhyphen{}use data structures and data
analysis tools for Python. \sphinxstylestrong{pandas} stands for panel data, a term borrowed from econometrics and is an efficient library for data analysis with an emphasis on tabular data.
\sphinxstylestrong{pandas} has two major classes, the \sphinxstylestrong{DataFrame} class with two\sphinxhyphen{}dimensional data objects and tabular data organized in columns and the class \sphinxstylestrong{Series} with a focus on one\sphinxhyphen{}dimensional data objects. Both classes allow you to index data easily as we will see in the examples below.
\sphinxstylestrong{pandas} allows you also to perform mathematical operations on the data, spanning from simple reshapings of vectors and matrices to statistical operations.

The following simple example shows how we can, in an easy way make tables of our data. Here we define a data set which includes names, place of birth and date of birth, and displays the data in an easy to read way. We will see repeated use of \sphinxstylestrong{pandas}, in particular in connection with classification of data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frodo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bilbo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Aragorn II}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Samwise}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Baggins}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Baggins}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Elessar}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gamgee}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Place of birth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Eriador}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Date of Birth T.A.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2968}\PYG{p}{,} \PYG{l+m+mi}{2890}\PYG{p}{,} \PYG{l+m+mi}{2931}\PYG{p}{,} \PYG{l+m+mi}{2980}\PYG{p}{]}
        \PYG{p}{\PYGZcb{}}
\PYG{n}{data\PYGZus{}pandas} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data\PYGZus{}pandas}\PYG{p}{)}
\end{sphinxVerbatim}

In the above we have imported \sphinxstylestrong{pandas} with the shorthand \sphinxstylestrong{pd}, the latter has become the standard way we import \sphinxstylestrong{pandas}. We make then a list of various variables
and reorganize the above lists into a \sphinxstylestrong{DataFrame} and then print out  a neat table with specific column labels as \sphinxstyleemphasis{Name}, \sphinxstyleemphasis{place of birth} and \sphinxstyleemphasis{date of birth}.
Displaying these results, we see that the indices are given by the default numbers from zero to three.
\sphinxstylestrong{pandas} is extremely flexible and we can easily change the above indices by defining a new type of indexing as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data\PYGZus{}pandas} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Frodo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bilbo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aragorn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data\PYGZus{}pandas}\PYG{p}{)}
\end{sphinxVerbatim}

Thereafter we display the content of the row which begins with the index \sphinxstylestrong{Aragorn}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data\PYGZus{}pandas}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aragorn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

We can easily append data to this, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{new\PYGZus{}hobbit} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Peregrin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Took}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Place of birth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Date of Birth T.A.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2990}\PYG{p}{]}
              \PYG{p}{\PYGZcb{}}
\PYG{n}{data\PYGZus{}pandas}\PYG{o}{=}\PYG{n}{data\PYGZus{}pandas}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{new\PYGZus{}hobbit}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pippin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data\PYGZus{}pandas}\PYG{p}{)}
\end{sphinxVerbatim}

Here are other examples where we use the \sphinxstylestrong{DataFrame} functionality to handle arrays, now with more interesting features for us, namely numbers. We set up a matrix
of dimensionality \(10\times 5\) and compute the mean value and standard deviation of each column. Similarly, we can perform mathematial operations like squaring the matrix elements and many other operations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} setting up a 10 x 5 matrix}
\PYG{n}{rows} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{cols} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{)}
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{df}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

Thereafter we can select specific columns only and plot final results

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Third}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fourth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fifth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{df}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{o}{.}\PYG{n}{describe}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{pylab} \PYG{k+kn}{import} \PYG{n}{plt}\PYG{p}{,} \PYG{n}{mpl}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mpl}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{font.family}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{serif}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{df}\PYG{o}{.}\PYG{n}{cumsum}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{df}\PYG{o}{.}\PYG{n}{plot}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rot}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

We can produce a \(4\times 4\) matrix

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n}{df1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df1}\PYG{p}{)}
\end{sphinxVerbatim}

and many other operations.

The \sphinxstylestrong{Series} class is another important class included in
\sphinxstylestrong{pandas}. You can view it as a specialization of \sphinxstylestrong{DataFrame} but where
we have just a single column of data. It shares many of the same features as \_DataFrame. As with \sphinxstylestrong{DataFrame},
most operations are vectorized, achieving thereby a high performance when dealing with computations of arrays, in particular labeled arrays.
As we will see below it leads also to a very concice code close to the mathematical operations we may be interested in.
For multidimensional arrays, we recommend strongly \sphinxhref{http://xarray.pydata.org/en/stable/}{xarray}. \sphinxstylestrong{xarray} has much of the same flexibility as \sphinxstylestrong{pandas}, but allows for the extension to higher dimensions than two.


\section{Basic Steps of Scientific Investigations}
\label{\detokenize{chapter3:basic-steps-of-scientific-investigations}}\label{\detokenize{chapter3::doc}}
An overarching aim in this course is to give you a deeper
understanding of the scientific method. The problems we study will all
involve cases where we can apply classical mechanics. In our previous
material we already assumed that we had a model for the motion of an
object.  Alternatively we could have data from experiment (like Usain
Bolt’s 100m world record run in 2008).  Or we could have performed
ourselves an experiment and we want to understand which forces are at
play and whether these forces can be understood in terms of
fundamental forces.

Our first step consists in identifying the problem. What we sketch
here may include a mix of experiment and theoretical simulations, or
just experiment or only theory.


\subsection{Identifying our System}
\label{\detokenize{chapter3:identifying-our-system}}
Here we can ask questions like
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
What kind of object is moving

\item {} 
What kind of data do we have

\item {} 
How do we measure position, velocity, acceleration etc

\item {} 
Which initial conditions influence our system

\item {} 
Other aspects which allow us to identify the system

\end{enumerate}


\subsection{Defining a Model}
\label{\detokenize{chapter3:defining-a-model}}
With our eventual data and observations we would now like to develop a
model for the system. In the end we want obviously to be able to
understand which forces are at play and how they influence our
specific system. That is, can we extract some deeper insights about a
system?

We need then to
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Find the forces that act on our system

\item {} 
Introduce models for the forces

\item {} 
Identify the equations which can govern the system (Newton’s second law for example)

\item {} 
More elements we deem important for defining our model

\end{enumerate}


\subsection{Solving the Equations}
\label{\detokenize{chapter3:solving-the-equations}}
With the model at hand, we can then solve the equations. In classical mechanics we normally end up  with solving sets of coupled ordinary differential equations or partial differential equations.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Using Newton’s second law we have equations of the type \(\boldsymbol{F}=m\boldsymbol{a}=md\boldsymbol{v}/dt\)

\item {} 
We need to  define the initial conditions (typically the initial velocity and position as functions of time) and/or initial conditions and boundary conditions

\item {} 
The solution of the equations give us then the position, the velocity and other time\sphinxhyphen{}dependent quantities which may specify the motion of a given object.

\end{enumerate}

We are not yet done. With our lovely solvers, we need to start thinking.

Now it is time to ask the big questions. What do our results mean? Can we give a simple interpretation in terms of fundamental laws?  What do our results mean? Are they correct?
Thus, typical questions we may ask are
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Are our results for say \(\boldsymbol{r}(t)\) valid?  Do we trust what we did?  Can you validate and verify the correctness of your results?

\item {} 
Evaluate the answers and their implications

\item {} 
Compare with experimental data if possible. Does our model make sense?

\item {} 
and obviously many other questions.

\end{enumerate}

The analysis stage feeds back to the first stage. It may happen that
the data we had were not good enough, there could be large statistical
uncertainties. We may need to collect more data or perhaps we did a
sloppy job in identifying the degrees of freedom.

All these steps are essential elements in a scientific
enquiry. Hopefully, through a mix of numerical simulations, analytical
calculations and experiments we may gain a deeper insight about the
physics of a specific system.

Let us now remind ourselves of Newton’s laws, since these are the laws of motion we will study in this course.


\subsection{Newton’s Laws}
\label{\detokenize{chapter3:newton-s-laws}}
When analyzing a physical system we normally start with distinguishing between the object we are studying (we will label this in more general terms as our \sphinxstylestrong{system}) and how this system interacts with the environment (which often means everything else!)

In our investigations we will thus analyze a specific physics problem in terms of the system and the environment.
In doing so we need to identify the forces that act on the system and assume that the
forces acting on the system must have a source, an identifiable cause in
the environment.

A force acting on for example a falling object must be related to an interaction with something in the environment.
This also means that we do not consider internal forces. The latter are forces between
one part of the object and another part. In this course we will mainly focus on external forces.

Forces are either contact forces or long\sphinxhyphen{}range forces.

Contact forces, as evident from the name, are forces that occur at the contact between
the system and the environment. Well\sphinxhyphen{}known long\sphinxhyphen{}range forces are the gravitional force and the electromagnetic force.


\subsection{Setting up a model for forces acting on an object}
\label{\detokenize{chapter3:setting-up-a-model-for-forces-acting-on-an-object}}
In order to set up the forces which act on an object, the following steps may be useful
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Divide the problem into system and environment.

\item {} 
Draw a figure of the object and everything in contact with the object.

\item {} 
Draw a closed curve around the system.

\item {} 
Find contact points—these are the points where contact forces may act.

\item {} 
Give names and symbols to all the contact forces.

\item {} 
Identify the long\sphinxhyphen{}range forces.

\item {} 
Make a drawing of the object. Draw the forces as arrows, vectors, starting from where the force is acting. The direction of the vector(s) indicates the (positive) direction of the force. Try to make the length of the arrow indicate the relative magnitude of the forces.

\item {} 
Draw in the axes of the coordinate system. It is often convenient to make one axis parallel to the direction of motion. When you choose the direction of the axis you also choose the positive direction for the axis.

\end{enumerate}


\subsection{Newton’s Laws, the Second one first}
\label{\detokenize{chapter3:newton-s-laws-the-second-one-first}}
Newton’s second law of motion: The force \(\boldsymbol{F}\) on an object of inertial mass \(m\)
is related to the acceleration a of the object through
\begin{equation*}
\begin{split}
\boldsymbol{F} = m\boldsymbol{a},
\end{split}
\end{equation*}
where \(\boldsymbol{a}\) is the acceleration.

Newton’s laws of motion are laws of nature that have been found by experimental
investigations and have been shown to hold up to continued experimental investigations.
Newton’s laws are valid over a wide range of length\sphinxhyphen{} and time\sphinxhyphen{}scales. We
use Newton’s laws of motion to describe everything from the motion of atoms to the
motion of galaxies.

The second law is a vector equation with the acceleration having the same
direction as the force. The acceleration is proportional to the force via the mass \(m\) of the system under study.

Newton’s second law introduces a new property of an object, the so\sphinxhyphen{}called
inertial mass \(m\). We determine the inertial mass of an object by measuring the
acceleration for a given applied force.


\subsection{Then the First Law}
\label{\detokenize{chapter3:then-the-first-law}}
What happens if the net external force on a body is zero? Applying Newton’s second
law, we find:
\begin{equation*}
\begin{split}
\boldsymbol{F} = 0 = m\boldsymbol{a},
\end{split}
\end{equation*}
which gives using the definition of the acceleration
\begin{equation*}
\begin{split}
\boldsymbol{a} = \frac{d\boldsymbol{v}}{dt}=0.
\end{split}
\end{equation*}
The acceleration is zero, which means that the velocity of the object is constant. This
is often referred to as Newton’s first law. An object in a state of uniform motion tends to remain in
that state unless an external force changes its state of motion.
Why do we need a separate law for this? Is it not simply a special case of Newton’s
second law? Yes, Newton’s first law can be deduced from the second law as we have
illustrated. However, the first law is often used for a different purpose: Newton’s
First Law tells us about the limit of applicability of Newton’s Second law. Newton’s
Second law can only be used in reference systems where the First law is obeyed. But
is not the First law always valid? No! The First law is only valid in reference systems
that are not accelerated. If you observe the motion of a ball from an accelerating
car, the ball will appear to accelerate even if there are no forces acting on it. We call
systems that are not accelerating inertial systems, and Newton’s first law is often
called the law of inertia. Newton’s first and second laws of motion are only valid in
inertial systems.

A system is an inertial system if it is not accelerated. It means that the reference system
must not be accelerating linearly or rotating. Unfortunately, this means that most
systems we know are not really inertial systems. For example, the surface of the
Earth is clearly not an inertial system, because the Earth is rotating. The Earth is also
not an inertial system, because it ismoving in a curved path around the Sun. However,
even if the surface of the Earth is not strictly an inertial system, it may be considered
to be approximately an inertial system for many laboratory\sphinxhyphen{}size experiments.


\subsection{And finally the Third Law}
\label{\detokenize{chapter3:and-finally-the-third-law}}
If there is a force from object A on object B, there is also a force from object B on object A.
This fundamental principle of interactions is called Newton’s third law. We do not
know of any force that do not obey this law: All forces appear in pairs. Newton’s
third law is usually formulated as: For every action there is an equal and opposite
reaction.


\subsection{Motion of a Single Object}
\label{\detokenize{chapter3:motion-of-a-single-object}}
Here we consider the motion of a single particle moving under
the influence of some set of forces.  We will consider some problems where
the force does not depend on the position. In that case Newton’s law
\(m\dot{\boldsymbol{v}}=\boldsymbol{F}(\boldsymbol{v})\) is a first\sphinxhyphen{}order differential
equation and one solves for \(\boldsymbol{v}(t)\), then moves on to integrate
\(\boldsymbol{v}\) to get the position. In essentially all of these cases we cna find an analytical solution.


\subsection{Air Resistance in One Dimension}
\label{\detokenize{chapter3:air-resistance-in-one-dimension}}
Air resistance tends to scale as the square of the velocity. This is
in contrast to many problems chosen for textbooks, where it is linear
in the velocity. The choice of a linear dependence is motivated by
mathematical simplicity (it keeps the differential equation linear)
rather than by physics. One can see that the force should be quadratic
in velocity by considering the momentum imparted on the air
molecules. If an object sweeps through a volume \(dV\) of air in time
\(dt\), the momentum imparted on the air is




\begin{equation*}
\begin{split}
\begin{equation}
dP=\rho_m dV v,
\label{_auto1} \tag{1}
\end{equation}
\end{split}
\end{equation*}
where \(v\) is the velocity of the object and \(\rho_m\) is the mass
density of the air. If the molecules bounce back as opposed to stop
you would double the size of the term. The opposite value of the
momentum is imparted onto the object itself. Geometrically, the
differential volume is




\begin{equation*}
\begin{split}
\begin{equation}
dV=Avdt,
\label{_auto2} \tag{2}
\end{equation}
\end{split}
\end{equation*}
where \(A\) is the cross\sphinxhyphen{}sectional area and \(vdt\) is the distance the
object moved in time \(dt\).


\subsection{Resulting Acceleration}
\label{\detokenize{chapter3:resulting-acceleration}}
Plugging this into the expression above,




\begin{equation*}
\begin{split}
\begin{equation}
\frac{dP}{dt}=-\rho_m A v^2.
\label{_auto3} \tag{3}
\end{equation}
\end{split}
\end{equation*}
This is the force felt by the particle, and is opposite to its
direction of motion. Now, because air doesn’t stop when it hits an
object, but flows around the best it can, the actual force is reduced
by a dimensionless factor \(c_W\), called the drag coefficient.




\begin{equation*}
\begin{split}
\begin{equation}
F_{\rm drag}=-c_W\rho_m Av^2,
\label{_auto4} \tag{4}
\end{equation}
\end{split}
\end{equation*}
and the acceleration is
\begin{equation*}
\begin{split}
\begin{eqnarray}
\frac{dv}{dt}=-\frac{c_W\rho_mA}{m}v^2.
\end{eqnarray}
\end{split}
\end{equation*}
For a particle with initial velocity \(v_0\), one can separate the \(dt\)
to one side of the equation, and move everything with \(v\)s to the
other side. We did this in our discussion of simple motion and will not repeat it here.

On more general terms,
for many systems, e.g. an automobile, there are multiple sources of
resistance. In addition to wind resistance, where the force is
proportional to \(v^2\), there are dissipative effects of the tires on
the pavement, and in the axel and drive train. These other forces can
have components that scale proportional to \(v\), and components that
are independent of \(v\). Those independent of \(v\), e.g. the usual
\(f=\mu_K N\) frictional force you consider in your first Physics courses, only set in
once the object is actually moving. As speeds become higher, the \(v^2\)
components begin to dominate relative to the others. For automobiles
at freeway speeds, the \(v^2\) terms are largely responsible for the
loss of efficiency. To travel a distance \(L\) at fixed speed \(v\), the
energy/work required to overcome the dissipative forces are \(fL\),
which for a force of the form \(f=\alpha v^n\) becomes
\begin{equation*}
\begin{split}
\begin{eqnarray}
W=\int dx~f=\alpha v^n L.
\end{eqnarray}
\end{split}
\end{equation*}
For \(n=0\) the work is
independent of speed, but for the wind resistance, where \(n=2\),
slowing down is essential if one wishes to reduce fuel consumption. It
is also important to consider that engines are designed to be most
efficient at a chosen range of power output. Thus, some cars will get
better mileage at higher speeds (They perform better at 50 mph than at
5 mph) despite the considerations mentioned above.


\subsection{Going Ballistic, Projectile Motion or a Softer Approach, Falling Raindrops}
\label{\detokenize{chapter3:going-ballistic-projectile-motion-or-a-softer-approach-falling-raindrops}}
As an example of Newton’s Laws we consider projectile motion (or a
falling raindrop or a ball we throw up in the air) with a drag force. Even though air resistance is
largely proportional to the square of the velocity, we will consider
the drag force to be linear to the velocity, \(\boldsymbol{F}=-m\gamma\boldsymbol{v}\),
for the purposes of this exercise. The acceleration for a projectile moving upwards,
\(\boldsymbol{a}=\boldsymbol{F}/m\), becomes
\begin{equation*}
\begin{split}
\begin{eqnarray}
\frac{dv_x}{dt}=-\gamma v_x,\\
\nonumber
\frac{dv_y}{dt}=-\gamma v_y-g,
\end{eqnarray}
\end{split}
\end{equation*}
and \(\gamma\) has dimensions of inverse time.

If you on the other hand have a falling raindrop, how do these equations change? See for example Figure 2.1 in Taylor.
Let us stay with a ball which is thrown up in the air at \(t=0\).


\subsection{Ways of solving these equations}
\label{\detokenize{chapter3:ways-of-solving-these-equations}}
We will go over two different ways to solve this equation. The first
by direct integration, and the second as a differential equation. To
do this by direct integration, one simply multiplies both sides of the
equations above by \(dt\), then divide by the appropriate factors so
that the \(v\)s are all on one side of the equation and the \(dt\) is on
the other. For the \(x\) motion one finds an easily integrable equation,
\begin{equation*}
\begin{split}
\begin{eqnarray}
\frac{dv_x}{v_x}&=&-\gamma dt,\\
\nonumber
\int_{v_{0x}}^{v_{x}}\frac{dv_x}{v_x}&=&-\gamma\int_0^{t}dt,\\
\nonumber
\ln\left(\frac{v_{x}}{v_{0x}}\right)&=&-\gamma t,\\
\nonumber
v_{x}(t)&=&v_{0x}e^{-\gamma t}.
\end{eqnarray}
\end{split}
\end{equation*}
This is very much the result you would have written down
by inspection. For the \(y\)\sphinxhyphen{}component of the velocity,
\begin{equation*}
\begin{split}
\begin{eqnarray}
\frac{dv_y}{v_y+g/\gamma}&=&-\gamma dt\\
\nonumber
\ln\left(\frac{v_{y}+g/\gamma}{v_{0y}-g/\gamma}\right)&=&-\gamma t_f,\\
\nonumber
v_{fy}&=&-\frac{g}{\gamma}+\left(v_{0y}+\frac{g}{\gamma}\right)e^{-\gamma t}.
\end{eqnarray}
\end{split}
\end{equation*}
Whereas \(v_x\) starts at some value and decays
exponentially to zero, \(v_y\) decays exponentially to the terminal
velocity, \(v_t=-g/\gamma\).


\subsection{Solving as differential equations}
\label{\detokenize{chapter3:solving-as-differential-equations}}
Although this direct integration is simpler than the method we invoke
below, the method below will come in useful for some slightly more
difficult differential equations in the future. The differential
equation for \(v_x\) is straight\sphinxhyphen{}forward to solve. Because it is first
order there is one arbitrary constant, \(A\), and by inspection the
solution is




\begin{equation*}
\begin{split}
\begin{equation}
v_x=Ae^{-\gamma t}.
\label{_auto5} \tag{5}
\end{equation}
\end{split}
\end{equation*}
The arbitrary constants for equations of motion are usually determined
by the initial conditions, or more generally boundary conditions. By
inspection \(A=v_{0x}\), the initial \(x\) component of the velocity.


\subsection{Differential Equations, contn}
\label{\detokenize{chapter3:differential-equations-contn}}
The differential equation for \(v_y\) is a bit more complicated due to
the presence of \(g\). Differential equations where all the terms are
linearly proportional to a function, in this case \(v_y\), or to
derivatives of the function, e.g., \(v_y\), \(dv_y/dt\),
\(d^2v_y/dt^2\cdots\), are called linear differential equations. If
there are terms proportional to \(v^2\), as would happen if the drag
force were proportional to the square of the velocity, the
differential equation is not longer linear. Because this expression
has only one derivative in \(v\) it is a first\sphinxhyphen{}order linear differential
equation. If a term were added proportional to \(d^2v/dt^2\) it would be
a second\sphinxhyphen{}order differential equation.  In this case we have a term
completely independent of \(v\), the gravitational acceleration \(g\), and
the usual strategy is to first rewrite the equation with all the
linear terms on one side of the equal sign,




\begin{equation*}
\begin{split}
\begin{equation}
\frac{dv_y}{dt}+\gamma v_y=-g.
\label{_auto6} \tag{6}
\end{equation}
\end{split}
\end{equation*}

\subsection{Splitting into two parts}
\label{\detokenize{chapter3:splitting-into-two-parts}}
Now, the solution to the equation can be broken into two
parts. Because this is a first\sphinxhyphen{}order differential equation we know
that there will be one arbitrary constant. Physically, the arbitrary
constant will be determined by setting the initial velocity, though it
could be determined by setting the velocity at any given time. Like
most differential equations, solutions are not “solved”. Instead,
one guesses at a form, then shows the guess is correct. For these
types of equations, one first tries to find a single solution,
i.e. one with no arbitrary constants. This is called the \{\textbackslash{}it
particular\} solution, \(y_p(t)\), though it should really be called
“a” particular solution because there are an infinite number of such
solutions. One then finds a solution to the \{\textbackslash{}it homogenous\} equation,
which is the equation with zero on the right\sphinxhyphen{}hand side,




\begin{equation*}
\begin{split}
\begin{equation}
\frac{dv_{y,h}}{dt}+\gamma v_{y,h}=0.
\label{_auto7} \tag{7}
\end{equation}
\end{split}
\end{equation*}
Homogenous solutions will have arbitrary constants.

The particular solution will solve the same equation as the original
general equation




\begin{equation*}
\begin{split}
\begin{equation}
\frac{dv_{y,p}}{dt}+\gamma v_{y,p}=-g.
\label{_auto8} \tag{8}
\end{equation}
\end{split}
\end{equation*}
However, we don’t need find one with arbitrary constants. Hence, it is
called a \sphinxstylestrong{particular} solution.

The sum of the two,




\begin{equation*}
\begin{split}
\begin{equation}
v_y=v_{y,p}+v_{y,h},
\label{_auto9} \tag{9}
\end{equation}
\end{split}
\end{equation*}
is a solution of the total equation because of the linear nature of
the differential equation. One has now found a \sphinxstyleemphasis{general} solution
encompassing all solutions, because it both satisfies the general
equation (like the particular solution), and has an arbitrary constant
that can be adjusted to fit any initial condition (like the homogneous
solution). If the equation were not linear, e.g if there were a term
such as \(v_y^2\) or \(v_y\dot{v}_y\), this technique would not work.


\subsection{More details}
\label{\detokenize{chapter3:more-details}}
Returning to the example above, the homogenous solution is the same as
that for \(v_x\), because there was no gravitational acceleration in
that case,




\begin{equation*}
\begin{split}
\begin{equation}
v_{y,h}=Be^{-\gamma t}.
\label{_auto10} \tag{10}
\end{equation}
\end{split}
\end{equation*}
In this case a particular solution is one with constant velocity,




\begin{equation*}
\begin{split}
\begin{equation}
v_{y,p}=-g/\gamma.
\label{_auto11} \tag{11}
\end{equation}
\end{split}
\end{equation*}
Note that this is the terminal velocity of a particle falling from a
great height. The general solution is thus,




\begin{equation*}
\begin{split}
\begin{equation}
v_y=Be^{-\gamma t}-g/\gamma,
\label{_auto12} \tag{12}
\end{equation}
\end{split}
\end{equation*}
and one can find \(B\) from the initial velocity,




\begin{equation*}
\begin{split}
\begin{equation}
v_{0y}=B-g/\gamma,~~~B=v_{0y}+g/\gamma.
\label{_auto13} \tag{13}
\end{equation}
\end{split}
\end{equation*}
Plugging in the expression for \(B\) gives the \(y\) motion given the initial velocity,




\begin{equation*}
\begin{split}
\begin{equation}
v_y=(v_{0y}+g/\gamma)e^{-\gamma t}-g/\gamma.
\label{_auto14} \tag{14}
\end{equation}
\end{split}
\end{equation*}
It is easy to see that this solution has \(v_y=v_{0y}\) when \(t=0\) and
\(v_y=-g/\gamma\) when \(t\rightarrow\infty\).

One can also integrate the two equations to find the coordinates \(x\)
and \(y\) as functions of \(t\),
\begin{equation*}
\begin{split}
\begin{eqnarray}
x&=&\int_0^t dt'~v_{0x}(t')=\frac{v_{0x}}{\gamma}\left(1-e^{-\gamma t}\right),\\
\nonumber
y&=&\int_0^t dt'~v_{0y}(t')=-\frac{gt}{\gamma}+\frac{v_{0y}+g/\gamma}{\gamma}\left(1-e^{-\gamma t}\right).
\end{eqnarray}
\end{split}
\end{equation*}
If the question was to find the position at a time \(t\), we would be
finished. However, the more common goal in a projectile equation
problem is to find the range, i.e. the distance \(x\) at which \(y\)
returns to zero. For the case without a drag force this was much
simpler. The solution for the \(y\) coordinate would have been
\(y=v_{0y}t-gt^2/2\). One would solve for \(t\) to make \(y=0\), which would
be \(t=2v_{0y}/g\), then plug that value for \(t\) into \(x=v_{0x}t\) to
find \(x=2v_{0x}v_{0y}/g=v_0\sin(2\theta_0)/g\). One follows the same
steps here, except that the expression for \(y(t)\) is more
complicated. Searching for the time where \(y=0\), and we get




\begin{equation*}
\begin{split}
\begin{equation}
0=-\frac{gt}{\gamma}+\frac{v_{0y}+g/\gamma}{\gamma}\left(1-e^{-\gamma t}\right).
\label{_auto15} \tag{15}
\end{equation}
\end{split}
\end{equation*}
This cannot be inverted into a simple expression \(t=\cdots\). Such
expressions are known as “transcendental equations”, and are not the
rare instance, but are the norm. In the days before computers, one
might plot the right\sphinxhyphen{}hand side of the above graphically as
a function of time, then find the point where it crosses zero.

Now, the most common way to solve for an equation of the above type
would be to apply Newton’s method numerically. This involves the
following algorithm for finding solutions of some equation \(F(t)=0\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
First guess a value for the time, \(t_{\rm guess}\).

\item {} 
Calculate \(F\) and its derivative, \(F(t_{\rm guess})\) and \(F'(t_{\rm guess})\).

\item {} 
Unless you guessed perfectly, \(F\ne 0\), and assuming that \(\Delta F\approx F'\Delta t\), one would choose

\item {} 
\(\Delta t=-F(t_{\rm guess})/F'(t_{\rm guess})\).

\item {} 
Now repeat step 1, but with \(t_{\rm guess}\rightarrow t_{\rm guess}+\Delta t\).

\end{enumerate}

If the \(F(t)\) were perfectly linear in \(t\), one would find \(t\) in one
step. Instead, one typically finds a value of \(t\) that is closer to
the final answer than \(t_{\rm guess}\). One breaks the loop once one
finds \(F\) within some acceptable tolerance of zero. A program to do
this will be added shortly.


\subsection{Motion in a Magnetic Field}
\label{\detokenize{chapter3:motion-in-a-magnetic-field}}
Another example of a velocity\sphinxhyphen{}dependent force is magnetism,
\begin{equation*}
\begin{split}
\begin{eqnarray}
\boldsymbol{F}&=&q\boldsymbol{v}\times\boldsymbol{B},\\
\nonumber
F_i&=&q\sum_{jk}\epsilon_{ijk}v_jB_k.
\end{eqnarray}
\end{split}
\end{equation*}
For a uniform field in the \(z\) direction \(\boldsymbol{B}=B\hat{z}\), the force can only have \(x\) and \(y\) components,
\begin{equation*}
\begin{split}
\begin{eqnarray}
F_x&=&qBv_y\\
\nonumber
F_y&=&-qBv_x.
\end{eqnarray}
\end{split}
\end{equation*}
The differential equations are
\begin{equation*}
\begin{split}
\begin{eqnarray}
\dot{v}_x&=&\omega_c v_y,\omega_c= qB/m\\
\nonumber
\dot{v}_y&=&-\omega_c v_x.
\end{eqnarray}
\end{split}
\end{equation*}
One can solve the equations by taking time derivatives of either equation, then substituting into the other equation,
\begin{equation*}
\begin{split}
\begin{eqnarray}
\ddot{v}_x=\omega_c\dot{v_y}=-\omega_c^2v_x,\\
\nonumber
\ddot{v}_y&=&-\omega_c\dot{v}_x=-\omega_cv_y.
\end{eqnarray}
\end{split}
\end{equation*}
The solution to these equations can be seen by inspection,
\begin{equation*}
\begin{split}
\begin{eqnarray}
v_x&=&A\sin(\omega_ct+\phi),\\
\nonumber
v_y&=&A\cos(\omega_ct+\phi).
\end{eqnarray}
\end{split}
\end{equation*}
One can integrate the equations to find the positions as a function of time,
\begin{equation*}
\begin{split}
\begin{eqnarray}
x-x_0&=&\int_{x_0}^x dx=\int_0^t dt v(t)\\
\nonumber
&=&\frac{-A}{\omega_c}\cos(\omega_ct+\phi),\\
\nonumber
y-y_0&=&\frac{A}{\omega_c}\sin(\omega_ct+\phi).
\end{eqnarray}
\end{split}
\end{equation*}
The trajectory is a circle centered at \(x_0,y_0\) with amplitude \(A\) rotating in the clockwise direction.

The equations of motion for the \(z\) motion are




\begin{equation*}
\begin{split}
\begin{equation}
\dot{v_z}=0,
\label{_auto16} \tag{16}
\end{equation}
\end{split}
\end{equation*}
which leads to




\begin{equation*}
\begin{split}
\begin{equation}
z-z_0=V_zt.
\label{_auto17} \tag{17}
\end{equation}
\end{split}
\end{equation*}
Added onto the circle, the motion is helical.

Note that the kinetic energy,




\begin{equation*}
\begin{split}
\begin{equation}
T=\frac{1}{2}m(v_x^2+v_y^2+v_z^2)=\frac{1}{2}m(\omega_c^2A^2+V_z^2),
\label{_auto18} \tag{18}
\end{equation}
\end{split}
\end{equation*}
is constant. This is because the force is perpendicular to the
velocity, so that in any differential time element \(dt\) the work done
on the particle \(\boldsymbol{F}\cdot{dr}=dt\boldsymbol{F}\cdot{v}=0\).

One should think about the implications of a velocity dependent
force. Suppose one had a constant magnetic field in deep space. If a
particle came through with velocity \(v_0\), it would undergo cyclotron
motion with radius \(R=v_0/\omega_c\). However, if it were still its
motion would remain fixed. Now, suppose an observer looked at the
particle in one reference frame where the particle was moving, then
changed their velocity so that the particle’s velocity appeared to be
zero. The motion would change from circular to fixed. Is this
possible?

The solution to the puzzle above relies on understanding
relativity. Imagine that the first observer believes \(\boldsymbol{B}\ne 0\) and
that the electric field \(\boldsymbol{E}=0\). If the observer then changes
reference frames by accelerating to a velocity \(\boldsymbol{v}\), in the new
frame \(\boldsymbol{B}\) and \(\boldsymbol{E}\) both change. If the observer moved to the
frame where the charge, originally moving with a small velocity \(v\),
is now at rest, the new electric field is indeed \(\boldsymbol{v}\times\boldsymbol{B}\),
which then leads to the same acceleration as one had before. If the
velocity is not small compared to the speed of light, additional
\(\gamma\) factors come into play,
\(\gamma=1/\sqrt{1-(v/c)^2}\). Relativistic motion will not be
considered in this course.


\subsection{Sliding Block tied to a Wall}
\label{\detokenize{chapter3:sliding-block-tied-to-a-wall}}
Another classical case is that of simple harmonic oscillations, here represented by a block sliding on a horizontal frictionless surface. The block is tied to a wall with a spring. If the spring is not compressed or stretched too far, the force on the block at a given position \(x\) is
\begin{equation*}
\begin{split}
F=-kx.
\end{split}
\end{equation*}
The negative sign means that the force acts to restore the object to an equilibrium position. Newton’s equation of motion for this idealized system is then
\begin{equation*}
\begin{split}
m\frac{d^2x}{dt^2}=-kx,
\end{split}
\end{equation*}
or we could rephrase it as




\begin{equation*}
\begin{split}
\frac{d^2x}{dt^2}=-\frac{k}{m}x=-\omega_0^2x,
\label{eq:newton1} \tag{19}
\end{split}
\end{equation*}
with the angular frequency \(\omega_0^2=k/m\).

The above differential equation has the advantage that it can be solved  analytically with solutions on the form
\begin{equation*}
\begin{split}
x(t)=Acos(\omega_0t+\nu),
\end{split}
\end{equation*}
where \(A\) is the amplitude and \(\nu\) the phase constant.   This provides in turn an important test for the numerical
solution and the development of a program for more complicated cases which cannot be solved analytically.

With the position \(x(t)\) and the velocity  \(v(t)=dx/dt\) we can reformulate Newton’s equation in the following way
\begin{equation*}
\begin{split}
\frac{dx(t)}{dt}=v(t),
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
\frac{dv(t)}{dt}=-\omega_0^2x(t).
\end{split}
\end{equation*}
We are now going to solve these equations using first the standard forward Euler  method. Later we will try to improve upon this.

Before proceeding however, it is important to note that in addition to the exact solution, we have at least two further tests which can be used to check our solution.

Since functions like \(cos\) are periodic with a period \(2\pi\), then the solution \(x(t)\) has also to be periodic. This means that
\begin{equation*}
\begin{split}
x(t+T)=x(t),
\end{split}
\end{equation*}
with \(T\) the period defined as
\begin{equation*}
\begin{split}
T=\frac{2\pi}{\omega_0}=\frac{2\pi}{\sqrt{k/m}}.
\end{split}
\end{equation*}
Observe that \(T\) depends only on \(k/m\) and not on the amplitude of the solution.

In addition to the periodicity test, the total energy has also to be conserved.

Suppose we choose the initial conditions
\begin{equation*}
\begin{split}
x(t=0)=1\hspace{0.1cm} \mathrm{m}\hspace{1cm} v(t=0)=0\hspace{0.1cm}\mathrm{m/s},
\end{split}
\end{equation*}
meaning that block is at rest at \(t=0\) but with a potential energy
\begin{equation*}
\begin{split}
E_0=\frac{1}{2}kx(t=0)^2=\frac{1}{2}k.
\end{split}
\end{equation*}
The total energy at any time \(t\) has however to be conserved, meaning that our solution has to fulfil the condition
\begin{equation*}
\begin{split}
E_0=\frac{1}{2}kx(t)^2+\frac{1}{2}mv(t)^2.
\end{split}
\end{equation*}
We will derive this equation in our discussion on \sphinxhref{https://mhjensen.github.io/Physics321/doc/pub/energyconserv/html/energyconserv.html}{energy conservation}.

An algorithm which implements these equations is included below.
\begin{itemize}
\item {} 
Choose the initial position and speed, with the most common choice \(v(t=0)=0\) and some fixed value for the position.

\item {} 
Choose the method you wish to employ in solving the problem.

\item {} 
Subdivide the time interval \([t_i,t_f] \) into a grid with step size

\end{itemize}
\begin{equation*}
\begin{split}
h=\frac{t_f-t_i}{N},
\end{split}
\end{equation*}
where \(N\) is the number of mesh points.
\begin{itemize}
\item {} 
Calculate now the total energy given by

\end{itemize}
\begin{equation*}
\begin{split}
E_0=\frac{1}{2}kx(t=0)^2=\frac{1}{2}k.
\end{split}
\end{equation*}\begin{itemize}
\item {} 
Choose ODE solver to obtain \(x_{i+1}\) and \(v_{i+1}\) starting from the previous values \(x_i\) and \(v_i\).

\item {} 
When we have computed \(x(v)_{i+1}\) we upgrade  \(t_{i+1}=t_i+h\).

\item {} 
This iterative  process continues till we reach the maximum time \(t_f\).

\item {} 
The results are checked against the exact solution. Furthermore, one has to check the stability of the numerical solution against the chosen number of mesh points \(N\).

\end{itemize}

The following python program ( code will be added shortly)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} This program solves Newtons equation for a block sliding on}
\PYG{c+c1}{\PYGZsh{} an horizontal frictionless surface.}
\PYG{c+c1}{\PYGZsh{} The block is tied to the wall with a spring, so N\PYGZsq{}s eq takes the form:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}  m d\PYGZca{}2x/dt\PYGZca{}2 = \PYGZhy{} kx}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} In order to make the solution dimless, we set k/m = 1.}
\PYG{c+c1}{\PYGZsh{} This results in two coupled diff. eq\PYGZsq{}s that may be written as:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}  dx/dt = v}
\PYG{c+c1}{\PYGZsh{}  dv/dt = \PYGZhy{}x}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} The user has to specify the initial velocity and position,}
\PYG{c+c1}{\PYGZsh{} and the number of steps. The time interval is fixed to}
\PYG{c+c1}{\PYGZsh{} t \PYGZbs{}in [0, 4\PYGZbs{}pi) (two periods)}
\PYG{c+c1}{\PYGZsh{}}
\end{sphinxVerbatim}


\subsection{The classical pendulum and scaling the equations}
\label{\detokenize{chapter3:the-classical-pendulum-and-scaling-the-equations}}
The angular equation of motion of the pendulum is given by
Newton’s equation and with no external force it reads




\begin{equation*}
\begin{split}
\begin{equation}
  ml\frac{d^2\theta}{dt^2}+mgsin(\theta)=0,
\label{_auto19} \tag{20}
\end{equation}
\end{split}
\end{equation*}
with an angular velocity and acceleration given by




\begin{equation*}
\begin{split}
\begin{equation}
     v=l\frac{d\theta}{dt},
\label{_auto20} \tag{21}
\end{equation}
\end{split}
\end{equation*}
and




\begin{equation*}
\begin{split}
\begin{equation}
     a=l\frac{d^2\theta}{dt^2}.
\label{_auto21} \tag{22}
\end{equation}
\end{split}
\end{equation*}

\subsection{More on the Pendulum}
\label{\detokenize{chapter3:more-on-the-pendulum}}
We do however expect that the motion will gradually come to an end due a viscous drag torque acting on the pendulum.
In the presence of the drag, the above equation becomes




\begin{equation*}
\begin{split}
\begin{equation}
   ml\frac{d^2\theta}{dt^2}+\nu\frac{d\theta}{dt}  +mgsin(\theta)=0, \label{eq:pend1} \tag{23}
\end{equation}
\end{split}
\end{equation*}
where \(\nu\) is now a positive constant parameterizing the viscosity
of the medium in question. In order to maintain the motion against
viscosity, it is necessary to add some external driving force.
We choose here a periodic driving force. The last equation becomes then




\begin{equation*}
\begin{split}
\begin{equation}
   ml\frac{d^2\theta}{dt^2}+\nu\frac{d\theta}{dt}  +mgsin(\theta)=Asin(\omega t), \label{eq:pend2} \tag{24}
\end{equation}
\end{split}
\end{equation*}
with \(A\) and \(\omega\) two constants representing the amplitude and
the angular frequency respectively. The latter is called the driving frequency.


\subsection{More on the Pendulum}
\label{\detokenize{chapter3:id1}}
We define
\begin{equation*}
\begin{split}
\omega_0=\sqrt{g/l},
\end{split}
\end{equation*}
the so\sphinxhyphen{}called natural frequency and the new dimensionless quantities
\begin{equation*}
\begin{split}
\hat{t}=\omega_0t,
\end{split}
\end{equation*}
with the dimensionless driving frequency
\begin{equation*}
\begin{split}
\hat{\omega}=\frac{\omega}{\omega_0},
\end{split}
\end{equation*}
and introducing the quantity \(Q\), called the \sphinxstyleemphasis{quality factor},
\begin{equation*}
\begin{split}
Q=\frac{mg}{\omega_0\nu},
\end{split}
\end{equation*}
and the dimensionless amplitude
\begin{equation*}
\begin{split}
\hat{A}=\frac{A}{mg}
\end{split}
\end{equation*}
We have
\begin{equation*}
\begin{split}
\frac{d^2\theta}{d\hat{t}^2}+\frac{1}{Q}\frac{d\theta}{d\hat{t}}  
     +sin(\theta)=\hat{A}cos(\hat{\omega}\hat{t}).
\end{split}
\end{equation*}
This equation can in turn be recast in terms of two coupled first\sphinxhyphen{}order differential equations as follows
\begin{equation*}
\begin{split}
\frac{d\theta}{d\hat{t}}=\hat{v},
\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}
\frac{d\hat{v}}{d\hat{t}}=-\frac{\hat{v}}{Q}-sin(\theta)+\hat{A}cos(\hat{\omega}\hat{t}).
\end{split}
\end{equation*}
These are the equations to be solved.  The factor \(Q\) represents the number of oscillations of the undriven system that must occur before  its energy is significantly reduced due to the viscous drag. The  amplitude \(\hat{A}\) is measured in units of the maximum possible  gravitational torque while \(\hat{\omega}\) is the angular frequency of the external torque measured in units of the pendulum’s natural frequency.







\renewcommand{\indexname}{Index}
\printindex
\end{document}