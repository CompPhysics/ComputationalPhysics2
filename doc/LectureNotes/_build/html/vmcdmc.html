
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Variational Monte Carlo methods &#8212; Advanced Topics in Computational Physics</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.e7340bb3dbd8dde6db86f25597f54a1b.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Gradient Methods" href="gradientmethods.html" />
    <link rel="prev" title="4. Many-body perturbation theory" href="mbpt.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Advanced Topics in Computational Physics</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Computational Physics 2: computational quantum mechanics
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Schedule
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Instructor information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks and practicalities
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Basic Many-Body Physics
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="basicmanybody.html">
   1. Many-body Hamiltonians, basic linear algebra and Second Quantization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hartreefocktheory.html">
   2. Hartree-Fock methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fcitheory.html">
   3. Full configuration interaction theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mbpt.html">
   4. Many-body perturbation theory
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic Methods
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. Variational Monte Carlo methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="gradientmethods.html">
   2. Gradient Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="resamplingmethods.html">
   3. Resampling Techniques, Bootstrap and Blocking
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Computational Aspects
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="vectorization.html">
   1. Optimization and Vectorization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallelization.html">
   2. Parallelization with MPI and OpenMPI
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Deep Learning
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="linearregression.html">
   1. Linear Regression and more Advanced Regression Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="logisticregression.html">
   2. Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="supportvectormachines.html">
   3. Support Vector Machines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="neuralnetworks.html">
   4. Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boltzmannmachines.html">
   5. Boltzmann Machines
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Quantum Computing and Quantum Machine Learning
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="basicquantumcomputing.html">
   1. Quantum Computing
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/vmcdmc.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-motivation">
   1.1. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   1.2. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   1.3. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   1.4. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   1.5. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   1.6. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   1.7. Quantum Monte Carlo Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo">
   1.8. Quantum Monte Carlo
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-hydrogen-atom">
   1.9. Quantum Monte Carlo: hydrogen atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   1.10. Quantum Monte Carlo: hydrogen atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   1.11. Quantum Monte Carlo: hydrogen atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-for-bosons">
   1.12. Quantum Monte Carlo for bosons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   1.13. Quantum Monte Carlo for bosons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   1.14. Quantum Monte Carlo for bosons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   1.15. Quantum Monte Carlo for bosons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions">
   1.16. A simple Python code that solves the two-boson or two-fermion case in two-dimensions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-the-helium-atom">
   1.17. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   1.18. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   1.19. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id14">
   1.20. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-first-attempt-at-solving-the-helium-atom">
   1.21. The first attempt at solving the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id15">
   1.22. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id16">
   1.23. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id17">
   1.24. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id18">
   1.25. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id19">
   1.26. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id20">
   1.27. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id21">
   1.28. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id22">
   1.29. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id23">
   1.30. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id24">
   1.31. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id25">
   1.32. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id26">
   1.33. The first attempt at solving the Helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-metropolis-algorithm">
   1.34. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id27">
   1.35. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id28">
   1.36. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id29">
   1.37. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id30">
   1.38. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id31">
   1.39. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id32">
   1.40. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling">
   1.41. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   1.42. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id34">
   1.43. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id35">
   1.44. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id36">
   1.45. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-program-elements">
   1.46. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id37">
   1.47. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id38">
   1.48. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id39">
   1.49. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id40">
   1.50. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id41">
   1.51. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id42">
   1.52. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id43">
   1.53. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id44">
   1.54. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id45">
   1.55. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id46">
   1.56. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id47">
   1.57. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id48">
   1.58. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id49">
   1.59. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id50">
   1.60. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id51">
   1.61. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id52">
   1.62. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id53">
   1.63. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#use-the-c-random-class-for-random-number-generations">
   1.64. Use the C++ random class for random number generations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#use-the-c-random-class-for-rngs-the-mersenne-twister-class">
   1.65. Use the C++ random class for RNGs, the Mersenne twister class
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#use-the-c-random-class-for-rngs-the-metropolis-test">
   1.66. Use the C++ random class for RNGs, the Metropolis test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-fokker-planck-and-langevin-equations">
   1.67. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id54">
   1.68. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id55">
   1.69. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id56">
   1.70. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id57">
   1.71. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id58">
   1.72. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id59">
   1.73. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id60">
   1.74. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id61">
   1.75. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id62">
   1.76. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id63">
   1.77. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id64">
   1.78. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id65">
   1.79. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id66">
   1.80. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id67">
   1.81. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id68">
   1.82. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id69">
   1.83. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id70">
   1.84. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id71">
   1.85. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id72">
   1.86. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id73">
   1.87. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id74">
   1.88. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id75">
   1.89. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id76">
   1.90. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id77">
   1.91. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id78">
   1.92. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id79">
   1.93. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-example-for-two-electrons-in-a-quantum-dots">
   1.94. Code example for two electrons in a quantum dots
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bringing-the-gradient-optmization">
   1.95. Bringing the gradient optmization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#and-then-for-the-non-interacting-two-particle-case">
   1.96. And then for the non-interacting two-particle case
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#project-2-vmc-for-fermions-efficient-calculation-of-slater-determinants">
   1.97. Project 2, VMC for fermions: Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#matrix-elements-of-slater-determinants">
   1.98. Matrix elements of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#efficient-calculation-of-slater-determinants">
   1.99. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id80">
   1.100. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id81">
   1.101. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id82">
   1.102. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id83">
   1.103. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id84">
   1.104. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id85">
   1.105. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id86">
   1.106. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id87">
   1.107. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id88">
   1.108. Efficient calculation of Slater determinants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-gradient-and-the-laplacian">
   1.109. The gradient and the Laplacian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-compute-the-derivates-of-the-slater-determinant">
   1.110. How to compute the derivates of the Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-slater-determinant">
   1.111. The Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-slater-determinant">
   1.112. Rewriting the Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#splitting-the-slater-determinant">
   1.113. Splitting the Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#spin-up-and-spin-down-parts">
   1.114. Spin up and spin down parts
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#factorization">
   1.115. Factorization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#number-of-operations">
   1.116. Number of operations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#counting-the-number-of-flops">
   1.117. Counting the number of FLOPS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computation-of-ratios">
   1.118. Computation of ratios
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scaling-properties">
   1.119. Scaling properties
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-get-the-determinant">
   1.120. How to get the determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lu-decomposition-and-determinant">
   1.121. LU decomposition and determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#determinant-of-a-matrix">
   1.122. Determinant of a matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#expectation-value-of-the-kinetic-energy">
   1.123. Expectation value of the kinetic energy
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#second-derivative-of-the-jastrow-factor">
   1.124. Second derivative of the Jastrow factor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functional-form">
   1.125. Functional form
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id89">
   1.126. Second derivative of the Jastrow factor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gradient-and-laplacian">
   1.127. Gradient and Laplacian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-gradient-for-the-determinant">
   1.128. The gradient for the determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#jastrow-gradient-in-quantum-force">
   1.129. Jastrow gradient in quantum force
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metropolis-hastings-part">
   1.130. Metropolis Hastings part
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-particle-states">
   1.131. Single-particle states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id90">
   1.132. Single-particle states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problems-with-neon-states-for-vmc">
   1.133. Problems with neon states for VMC
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id91">
   1.134. Problems with neon states for VMC
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#spherical-harmonics">
   1.135. Spherical harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examples-of-spherical-harmonics">
   1.136. Examples of spherical harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problems-with-spherical-harmonics">
   1.137. Problems with spherical harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#real-solid-harmonics">
   1.138. Real solid harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solid-harmonics">
   1.139. Solid harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relation-between-solid-harmonics-and-spherical-harmonics">
   1.140. Relation between solid harmonics and spherical harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-lowest-order-real-solid-harmonics">
   1.141. The lowest-order real solid harmonics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#proof-for-updating-algorithm-for-slater-determinant">
   1.142. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id92">
   1.143. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id93">
   1.144. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id94">
   1.145. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id95">
   1.146. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id96">
   1.147. Proof for updating algorithm for Slater determinant
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id97">
   1.148. Proof for updating algorithm for Slater determinant
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="variational-monte-carlo-methods">
<h1><span class="section-number">1. </span>Variational Monte Carlo methods<a class="headerlink" href="#variational-monte-carlo-methods" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quantum-monte-carlo-motivation">
<h2><span class="section-number">1.1. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#quantum-monte-carlo-motivation" title="Permalink to this headline">¶</a></h2>
<p>We start with the variational principle.
Given a hamiltonian <span class="math notranslate nohighlight">\(H\)</span> and a trial wave function <span class="math notranslate nohighlight">\(\Psi_T\)</span>, the variational principle states that the expectation value of <span class="math notranslate nohighlight">\(\langle H \rangle\)</span>, defined through</p>
<div class="math notranslate nohighlight">
\[
E[H]= \langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
\]</div>
<p>is an upper bound to the ground state energy <span class="math notranslate nohighlight">\(E_0\)</span> of the hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
E_0 \le \langle H \rangle .
\]</div>
<p>In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.</p>
</div>
<div class="section" id="id1">
<h2><span class="section-number">1.2. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The trial wave function can be expanded in the eigenstates of the hamiltonian since they form a complete set, viz.,</p>
<div class="math notranslate nohighlight">
\[
\Psi_T(\boldsymbol{R})=\sum_i a_i\Psi_i(\boldsymbol{R}),
\]</div>
<p>and assuming the set of eigenfunctions to be normalized one obtains</p>
<div class="math notranslate nohighlight">
\[
\frac{\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})H(\boldsymbol{R})\Psi_n(\boldsymbol{R})}
        {\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})\Psi_n(\boldsymbol{R})} =\frac{\sum_{n}a^2_n E_n}
        {\sum_{n}a^2_n} \ge E_0,
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(H(\boldsymbol{R})\Psi_n(\boldsymbol{R})=E_n\Psi_n(\boldsymbol{R})\)</span>.
In general, the integrals involved in the calculation of various  expectation
values  are multi-dimensional ones.
The variational principle yields the lowest state of a given symmetry.</p>
</div>
<div class="section" id="id2">
<h2><span class="section-number">1.3. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>In most cases, a wave function has only small values in large parts of
configuration space, and a straightforward procedure which uses
homogenously distributed random points in configuration space
will most likely lead to poor results. This may suggest that some kind
of importance sampling combined with e.g., the Metropolis algorithm
may be  a more efficient way of obtaining the ground state energy.
The hope is then that those regions of configurations space where
the wave function assumes appreciable values are sampled more
efficiently.</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">1.4. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The tedious part in a VMC calculation is the search for the variational
minimum. A good knowledge of the system is required in order to carry out
reasonable VMC calculations. This is not always the case,
and often VMC calculations
serve rather as the starting
point for so-called diffusion Monte Carlo calculations (DMC). DMC is a way of
solving exactly the many-body Schroedinger equation by means of
a stochastic procedure. A good guess on the binding energy
and its wave function is however necessary.
A carefully performed VMC calculation can aid in this context.</p>
</div>
<div class="section" id="id4">
<h2><span class="section-number">1.5. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Construct first a trial wave function <span class="math notranslate nohighlight">\(\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\)</span>,  for a many-body system consisting of <span class="math notranslate nohighlight">\(N\)</span> particles located at positions  <span class="math notranslate nohighlight">\(\boldsymbol{R}=(\boldsymbol{R}_1,\dots ,\boldsymbol{R}_N)\)</span>. The trial wave function depends on <span class="math notranslate nohighlight">\(\alpha\)</span> variational parameters <span class="math notranslate nohighlight">\(\boldsymbol{\alpha}=(\alpha_1,\dots ,\alpha_M)\)</span>.</p></li>
<li><p>Then we evaluate the expectation value of the hamiltonian <span class="math notranslate nohighlight">\(H\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[
E[H]=\langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}.
\]</div>
<ul class="simple">
<li><p>Thereafter we vary <span class="math notranslate nohighlight">\(\alpha\)</span> according to some minimization algorithm and return to the first step.</p></li>
</ul>
</div>
<div class="section" id="id5">
<h2><span class="section-number">1.6. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p><strong>Basic steps.</strong></p>
<p>Choose a trial wave function
<span class="math notranslate nohighlight">\(\psi_T(\boldsymbol{R})\)</span>.</p>
<div class="math notranslate nohighlight">
\[
P(\boldsymbol{R})= \frac{\left|\psi_T(\boldsymbol{R})\right|^2}{\int \left|\psi_T(\boldsymbol{R})\right|^2d\boldsymbol{R}}.
\]</div>
<p>This is our new probability distribution function  (PDF).
The approximation to the expectation value of the Hamiltonian is now</p>
<div class="math notranslate nohighlight">
\[
E[H(\boldsymbol{\alpha})] = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
\]</div>
</div>
<div class="section" id="id6">
<h2><span class="section-number">1.7. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Define a new quantity</p>
<!-- Equation labels as ordinary links -->
<div id="eq:locale1"></div>
<div class="math notranslate nohighlight">
\[
E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
\label{eq:locale1} \tag{1}
\]</div>
<p>called the local energy, which, together with our trial PDF yields</p>
<!-- Equation labels as ordinary links -->
<div id="eq:vmc1"></div>
<div class="math notranslate nohighlight">
\[
E[H(\boldsymbol{\alpha})]=\int P(\boldsymbol{R})E_L(\boldsymbol{R}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^NP(\boldsymbol{R_i},\boldsymbol{\alpha})E_L(\boldsymbol{R_i},\boldsymbol{\alpha})
\label{eq:vmc1} \tag{2}
\]</div>
<p>with <span class="math notranslate nohighlight">\(N\)</span> being the number of Monte Carlo samples.</p>
</div>
<div class="section" id="quantum-monte-carlo">
<h2><span class="section-number">1.8. </span>Quantum Monte Carlo<a class="headerlink" href="#quantum-monte-carlo" title="Permalink to this headline">¶</a></h2>
<p>The Algorithm for performing a variational Monte Carlo calculations runs thus as this</p>
<ul class="simple">
<li><p>Initialisation: Fix the number of Monte Carlo steps. Choose an initial <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> and variational parameters <span class="math notranslate nohighlight">\(\alpha\)</span> and calculate <span class="math notranslate nohighlight">\(\left|\psi_T^{\alpha}(\boldsymbol{R})\right|^2\)</span>.</p></li>
<li><p>Initialise the energy and the variance and start the Monte Carlo calculation.</p>
<ul>
<li><p>Calculate  a trial position  <span class="math notranslate nohighlight">\(\boldsymbol{R}_p=\boldsymbol{R}+r*step\)</span> where <span class="math notranslate nohighlight">\(r\)</span> is a random variable <span class="math notranslate nohighlight">\(r \in [0,1]\)</span>.</p></li>
<li><p>Metropolis algorithm to accept or reject this move  <span class="math notranslate nohighlight">\(w = P(\boldsymbol{R}_p)/P(\boldsymbol{R})\)</span>.</p></li>
<li><p>If the step is accepted, then we set <span class="math notranslate nohighlight">\(\boldsymbol{R}=\boldsymbol{R}_p\)</span>.</p></li>
<li><p>Update averages</p></li>
</ul>
</li>
<li><p>Finish and compute final averages.</p></li>
</ul>
<p>Observe that the jumping in space is governed by the variable <em>step</em>. This is Called brute-force sampling.
Need importance sampling to get more relevant sampling, see lectures below.</p>
</div>
<div class="section" id="quantum-monte-carlo-hydrogen-atom">
<h2><span class="section-number">1.9. </span>Quantum Monte Carlo: hydrogen atom<a class="headerlink" href="#quantum-monte-carlo-hydrogen-atom" title="Permalink to this headline">¶</a></h2>
<p>The radial Schroedinger equation for the hydrogen atom can be
written as</p>
<div class="math notranslate nohighlight">
\[
-\frac{\hbar^2}{2m}\frac{\partial^2 u(r)}{\partial r^2}-
\left(\frac{ke^2}{r}-\frac{\hbar^2l(l+1)}{2mr^2}\right)u(r)=Eu(r),
\]</div>
<p>or with dimensionless variables</p>
<!-- Equation labels as ordinary links -->
<div id="eq:hydrodimless1"></div>
<div class="math notranslate nohighlight">
\[
-\frac{1}{2}\frac{\partial^2 u(\rho)}{\partial \rho^2}-
\frac{u(\rho)}{\rho}+\frac{l(l+1)}{2\rho^2}u(\rho)-\lambda u(\rho)=0,
\label{eq:hydrodimless1} \tag{3}
\]</div>
<p>with the hamiltonian</p>
<div class="math notranslate nohighlight">
\[
H=-\frac{1}{2}\frac{\partial^2 }{\partial \rho^2}-
\frac{1}{\rho}+\frac{l(l+1)}{2\rho^2}.
\]</div>
<p>Use variational parameter <span class="math notranslate nohighlight">\(\alpha\)</span> in the trial
wave function</p>
<!-- Equation labels as ordinary links -->
<div id="eq:trialhydrogen"></div>
<div class="math notranslate nohighlight">
\[
u_T^{\alpha}(\rho)=\alpha\rho e^{-\alpha\rho}. 
\label{eq:trialhydrogen} \tag{4}
\]</div>
</div>
<div class="section" id="id7">
<h2><span class="section-number">1.10. </span>Quantum Monte Carlo: hydrogen atom<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Inserting this wave function into the expression for the
local energy <span class="math notranslate nohighlight">\(E_L\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
E_L(\rho)=-\frac{1}{\rho}-
              \frac{\alpha}{2}\left(\alpha-\frac{2}{\rho}\right).
\]</div>
<p>A simple variational Monte Carlo calculation results in</p>
<table border="1">
<thead>
<tr><th align="center">  $\alpha$ </th> <th align="center">$\langle H \rangle $</th> <th align="center"> $\sigma^2$</th> <th align="center">$\sigma/\sqrt{N}$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   7.00000E-01    </td> <td align="center">   -4.57759E-01            </td> <td align="center">   4.51201E-02    </td> <td align="center">   6.71715E-04          </td> </tr>
<tr><td align="center">   8.00000E-01    </td> <td align="center">   -4.81461E-01            </td> <td align="center">   3.05736E-02    </td> <td align="center">   5.52934E-04          </td> </tr>
<tr><td align="center">   9.00000E-01    </td> <td align="center">   -4.95899E-01            </td> <td align="center">   8.20497E-03    </td> <td align="center">   2.86443E-04          </td> </tr>
<tr><td align="center">   1.00000E-00    </td> <td align="center">   -5.00000E-01            </td> <td align="center">   0.00000E+00    </td> <td align="center">   0.00000E+00          </td> </tr>
<tr><td align="center">   1.10000E+00    </td> <td align="center">   -4.93738E-01            </td> <td align="center">   1.16989E-02    </td> <td align="center">   3.42036E-04          </td> </tr>
<tr><td align="center">   1.20000E+00    </td> <td align="center">   -4.75563E-01            </td> <td align="center">   8.85899E-02    </td> <td align="center">   9.41222E-04          </td> </tr>
<tr><td align="center">   1.30000E+00    </td> <td align="center">   -4.54341E-01            </td> <td align="center">   1.45171E-01    </td> <td align="center">   1.20487E-03          </td> </tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h2><span class="section-number">1.11. </span>Quantum Monte Carlo: hydrogen atom<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>We note that at <span class="math notranslate nohighlight">\(\alpha=1\)</span> we obtain the exact
result, and the variance is zero, as it should. The reason is that
we then have the exact wave function, and the action of the hamiltionan
on the wave function</p>
<div class="math notranslate nohighlight">
\[
H\psi = \mathrm{constant}\times \psi,
\]</div>
<p>yields just a constant. The integral which defines various
expectation values involving moments of the hamiltonian becomes then</p>
<div class="math notranslate nohighlight">
\[
\langle H^n \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H^n(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=
\mathrm{constant}\times\frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=\mathrm{constant}.
\]</div>
<p><strong>This gives an important information: the exact wave function leads to zero variance!</strong>
Variation is then performed by minimizing both the energy and the variance.</p>
</div>
<div class="section" id="quantum-monte-carlo-for-bosons">
<h2><span class="section-number">1.12. </span><a class="reference external" href="https://github.com/mortele/variational-monte-carlo-fys4411">Quantum Monte Carlo for bosons</a><a class="headerlink" href="#quantum-monte-carlo-for-bosons" title="Permalink to this headline">¶</a></h2>
<p>For bosons in a harmonic oscillator-like  trap we will use is a spherical (S)
or an elliptical (E) harmonic trap in one, two and finally three
dimensions, with the latter given by</p>
<!-- Equation labels as ordinary links -->
<div id="trap_eqn"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
 V_{ext}(\mathbf{r}) = \Bigg\{
 \begin{array}{ll}
	 \frac{1}{2}m\omega_{ho}^2r^2 &amp; (S)\\
 \strut
	 \frac{1}{2}m[\omega_{ho}^2(x^2+y^2) + \omega_z^2z^2] &amp; (E)
\label{trap_eqn} \tag{5}
 \end{array}
 \end{equation}
\end{split}\]</div>
<p>where (S) stands for symmetric and</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
     \hat{H} = \sum_i^N \left(
	 \frac{-\hbar^2}{2m}
	 { \bigtriangledown }_{i}^2 +
	 V_{ext}({\bf{r}}_i)\right)  +
	 \sum_{i&lt;j}^{N} V_{int}({\bf{r}}_i,{\bf{r}}_j),
\label{_auto1} \tag{6}
\end{equation}
\]</div>
<p>as the two-body Hamiltonian of the system.</p>
</div>
<div class="section" id="id9">
<h2><span class="section-number">1.13. </span><a class="reference external" href="https://github.com/mortele/variational-monte-carlo-fys4411">Quantum Monte Carlo for bosons</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>We will represent the inter-boson interaction by a pairwise, repulsive potential</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
 V_{int}(|\mathbf{r}_i-\mathbf{r}_j|) =  \Bigg\{
 \begin{array}{ll}
	 \infty &amp; {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 0 &amp; {|\mathbf{r}_i-\mathbf{r}_j|} &gt; {a}
 \end{array}
\label{_auto2} \tag{7}
\end{equation}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> is the so-called hard-core diameter of the bosons.
Clearly, <span class="math notranslate nohighlight">\(V_{int}(|\mathbf{r}_i-\mathbf{r}_j|)\)</span> is zero if the bosons are
separated by a distance <span class="math notranslate nohighlight">\(|\mathbf{r}_i-\mathbf{r}_j|\)</span> greater than <span class="math notranslate nohighlight">\(a\)</span> but
infinite if they attempt to come within a distance <span class="math notranslate nohighlight">\(|\mathbf{r}_i-\mathbf{r}_j| \leq a\)</span>.</p>
</div>
<div class="section" id="id10">
<h2><span class="section-number">1.14. </span><a class="reference external" href="https://github.com/mortele/variational-monte-carlo-fys4411">Quantum Monte Carlo for bosons</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>Our trial wave function for the ground state with <span class="math notranslate nohighlight">\(N\)</span> atoms is given by</p>
<!-- Equation labels as ordinary links -->
<div id="eq:trialwf"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
 \Psi_T(\mathbf{R})=\Psi_T(\mathbf{r}_1, \mathbf{r}_2, \dots \mathbf{r}_N,\alpha,\beta)=\prod_i g(\alpha,\beta,\mathbf{r}_i)\prod_{i&lt;j}f(a,|\mathbf{r}_i-\mathbf{r}_j|),
\label{eq:trialwf} \tag{8}
 \end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are variational parameters. The
single-particle wave function is proportional to the harmonic
oscillator function for the ground state</p>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
    g(\alpha,\beta,\mathbf{r}_i)= \exp{[-\alpha(x_i^2+y_i^2+\beta z_i^2)]}.
\label{_auto3} \tag{9}
\end{equation}
\]</div>
</div>
<div class="section" id="id11">
<h2><span class="section-number">1.15. </span><a class="reference external" href="https://github.com/mortele/variational-monte-carlo-fys4411">Quantum Monte Carlo for bosons</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>For spherical traps we have <span class="math notranslate nohighlight">\(\beta = 1\)</span> and for non-interacting
bosons (<span class="math notranslate nohighlight">\(a=0\)</span>) we have <span class="math notranslate nohighlight">\(\alpha = 1/2a_{ho}^2\)</span>.  The correlation wave
function is</p>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
    f(a,|\mathbf{r}_i-\mathbf{r}_j|)=\Bigg\{
 \begin{array}{ll}
	 0 &amp; {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 (1-\frac{a}{|\mathbf{r}_i-\mathbf{r}_j|}) &amp; {|\mathbf{r}_i-\mathbf{r}_j|} &gt; {a}.
 \end{array}
\label{_auto4} \tag{10}
\end{equation}
\end{split}\]</div>
</div>
<div class="section" id="a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions">
<h2><span class="section-number">1.16. </span>A simple Python code that solves the two-boson or two-fermion case in two-dimensions<a class="headerlink" href="#a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># Importing various packages</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#Trial wave function for quantum dots in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="n">r12</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span><span class="o">+</span><span class="n">deno</span><span class="p">)</span>

<span class="c1">#Local energy  for quantum dots in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">deno2</span> <span class="o">=</span> <span class="n">deno</span><span class="o">*</span><span class="n">deno</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="o">+</span><span class="n">deno2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">r12</span><span class="o">-</span><span class="n">deno2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">deno</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="p">)</span>

<span class="c1"># The Monte Carlo sampling with the Metropolis algo</span>
<span class="k">def</span> <span class="nf">MonteCarloSampling</span><span class="p">():</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">100000</span>
    <span class="n">StepSize</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># seed for rng generator</span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="c1"># start variational parameter</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">025</span>
        <span class="n">AlphaValues</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span> 
        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">01</span>
            <span class="n">BetaValues</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1">#Initial position</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

            <span class="c1">#Loop over MC MCcycles</span>
            <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
                <span class="c1">#Trial position</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">StepSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

                <span class="c1">#Metropolis test to see whether we accept the move</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">wfold</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                   <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                   <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
                   <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
                <span class="n">energy2</span> <span class="o">+=</span> <span class="n">DeltaE</span><span class="o">**</span><span class="mi">2</span>

            <span class="c1">#We calculate mean, variance and error ...</span>
            <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">energy2</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">-</span> <span class="n">energy</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="o">/</span><span class="n">NumberMCcycles</span><span class="p">)</span>
            <span class="n">Energies</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>    
    <span class="k">return</span> <span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">MaxVariations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MaxVariations</span><span class="p">,</span><span class="n">MaxVariations</span><span class="p">))</span>
<span class="n">AlphaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="n">BetaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="p">(</span><span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span> <span class="o">=</span> <span class="n">MonteCarloSampling</span><span class="p">()</span>

<span class="c1"># Prepare for plots</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="c1"># Plot the surface.</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Energies</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Customize the z axis.</span>
<span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\alpha$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\beta$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle E \rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">LinearLocator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.02f</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="c1"># Add a color bar which maps values to colors.</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="quantum-monte-carlo-the-helium-atom">
<h2><span class="section-number">1.17. </span>Quantum Monte Carlo: the helium atom<a class="headerlink" href="#quantum-monte-carlo-the-helium-atom" title="Permalink to this headline">¶</a></h2>
<p>The helium atom consists of two electrons and a nucleus with
charge <span class="math notranslate nohighlight">\(Z=2\)</span>.
The contribution<br />
to the potential energy due to the attraction from the nucleus is</p>
<div class="math notranslate nohighlight">
\[
-\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2},
\]</div>
<p>and if we add the repulsion arising from the two
interacting electrons, we obtain the potential energy</p>
<div class="math notranslate nohighlight">
\[
V(r_1, r_2)=-\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2}+
               \frac{ke^2}{r_{12}},
\]</div>
<p>with the electrons separated at a distance
<span class="math notranslate nohighlight">\(r_{12}=|\boldsymbol{r}_1-\boldsymbol{r}_2|\)</span>.</p>
</div>
<div class="section" id="id12">
<h2><span class="section-number">1.18. </span>Quantum Monte Carlo: the helium atom<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>The hamiltonian becomes then</p>
<div class="math notranslate nohighlight">
\[
\hat{H}=-\frac{\hbar^2\nabla_1^2}{2m}-\frac{\hbar^2\nabla_2^2}{2m}
          -\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2}+
               \frac{ke^2}{r_{12}},
\]</div>
<p>and  Schroedingers equation reads</p>
<div class="math notranslate nohighlight">
\[
\hat{H}\psi=E\psi.
\]</div>
<p>All observables are evaluated with respect to the probability distribution</p>
<div class="math notranslate nohighlight">
\[
P(\boldsymbol{R})= \frac{\left|\psi_T(\boldsymbol{R})\right|^2}{\int \left|\psi_T(\boldsymbol{R})\right|^2d\boldsymbol{R}}.
\]</div>
<p>generated by the trial wave function.<br />
The trial wave function must approximate an exact
eigenstate in order that accurate results are to be obtained.</p>
</div>
<div class="section" id="id13">
<h2><span class="section-number">1.19. </span>Quantum Monte Carlo: the helium atom<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>Choice of trial wave function for Helium:
Assume <span class="math notranslate nohighlight">\(r_1 \rightarrow 0\)</span>.</p>
<p>2
7</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
E_L(R)=
    \frac{1}{\mathbf{R}_T(r_1)}\left(-\frac{1}{2}\frac{d^2}{dr_1^2}-
     \frac{1}{r_1}\frac{d}{dr_1}
     -\frac{Z}{r_1}\right)\mathbf{R}_T(r_1) + \mathrm{finite\hspace{0.1cm} terms}
\]</div>
<p>For small values of <span class="math notranslate nohighlight">\(r_1\)</span>, the terms which dominate are</p>
<div class="math notranslate nohighlight">
\[
\lim_{r_1 \rightarrow 0}E_L(R)=
    \frac{1}{\mathbf{R}_T(r_1)}\left(-
     \frac{1}{r_1}\frac{d}{dr_1}
     -\frac{Z}{r_1}\right)\mathbf{R}_T(r_1),
\]</div>
<p>since the second derivative does not diverge due to the finiteness of  <span class="math notranslate nohighlight">\(\Psi\)</span> at the origin.</p>
</div>
<div class="section" id="id14">
<h2><span class="section-number">1.20. </span>Quantum Monte Carlo: the helium atom<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>This results in</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\mathbf{R}_T(r_1)}\frac{d \mathbf{R}_T(r_1)}{dr_1}=-Z,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\mathbf{R}_T(r_1)\propto e^{-Zr_1}.
\]</div>
<p>A similar condition applies to electron 2 as well.
For orbital momenta <span class="math notranslate nohighlight">\(l &gt; 0\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\mathbf{R}_T(r)}\frac{d \mathbf{R}_T(r)}{dr}=-\frac{Z}{l+1}.
\]</div>
<p>Similarly, studying the case <span class="math notranslate nohighlight">\(r_{12}\rightarrow 0\)</span> we can write
a possible trial wave function as</p>
<!-- Equation labels as ordinary links -->
<div id="eq:wavehelium2"></div>
<div class="math notranslate nohighlight">
\[
\psi_T(\boldsymbol{R})=e^{-\alpha(r_1+r_2)}e^{\beta r_{12}}.
\label{eq:wavehelium2} \tag{11}
\]</div>
<p>The last equation can be generalized to</p>
<div class="math notranslate nohighlight">
\[
\psi_T(\boldsymbol{R})=\phi(\boldsymbol{r}_1)\phi(\boldsymbol{r}_2)\dots\phi(\boldsymbol{r}_N)
                   \prod_{i &lt; j}f(r_{ij}),
\]</div>
<p>for a system with <span class="math notranslate nohighlight">\(N\)</span> electrons or particles.</p>
</div>
<div class="section" id="the-first-attempt-at-solving-the-helium-atom">
<h2><span class="section-number">1.21. </span>The first attempt at solving the helium atom<a class="headerlink" href="#the-first-attempt-at-solving-the-helium-atom" title="Permalink to this headline">¶</a></h2>
<p>During the development of our code we need to make several checks. It is also very instructive to compute a closed form expression for the local energy. Since our wave function is rather simple  it is straightforward
to find an analytic expressions.  Consider first the case of the simple helium function</p>
<div class="math notranslate nohighlight">
\[
\Psi_T(\boldsymbol{r}_1,\boldsymbol{r}_2) = e^{-\alpha(r_1+r_2)}
\]</div>
<p>The local energy is for this case</p>
<div class="math notranslate nohighlight">
\[
E_{L1} = \left(\alpha-Z\right)\left(\frac{1}{r_1}+\frac{1}{r_2}\right)+\frac{1}{r_{12}}-\alpha^2
\]</div>
<p>which gives an expectation value for the local energy given by</p>
<div class="math notranslate nohighlight">
\[
\langle E_{L1} \rangle = \alpha^2-2\alpha\left(Z-\frac{5}{16}\right)
\]</div>
</div>
<div class="section" id="id15">
<h2><span class="section-number">1.22. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>With closed form formulae we  can speed up the computation of the correlation. In our case
we write it as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C= \exp{\left\{\sum_{i &lt; j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>which means that the gradient needed for the so-called quantum force and local energy
can be calculated analytically.
This will speed up your code since the computation of the correlation part and the Slater determinant are the most
time consuming parts in your code.</p>
<p>We will refer to this correlation function as <span class="math notranslate nohighlight">\(\Psi_C\)</span> or the <em>linear Pade-Jastrow</em>.</p>
</div>
<div class="section" id="id16">
<h2><span class="section-number">1.23. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>We can test this by computing the local energy for our helium wave function</p>
<div class="math notranslate nohighlight">
\[
\psi_{T}(\boldsymbol{r}_1,\boldsymbol{r}_2) = 
   \exp{\left(-\alpha(r_1+r_2)\right)}
   \exp{\left(\frac{r_{12}}{2(1+\beta r_{12})}\right)},
\]</div>
<p>with <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> as variational parameters.</p>
<p>The local energy is for this case</p>
<div class="math notranslate nohighlight">
\[
E_{L2} = E_{L1}+\frac{1}{2(1+\beta r_{12})^2}\left\{\frac{\alpha(r_1+r_2)}{r_{12}}(1-\frac{\boldsymbol{r}_1\boldsymbol{r}_2}{r_1r_2})-\frac{1}{2(1+\beta r_{12})^2}-\frac{2}{r_{12}}+\frac{2\beta}{1+\beta r_{12}}\right\}
\]</div>
<p>It is very useful to test your code against these expressions. It means also that you don’t need to
compute a derivative numerically as discussed in the code example below.</p>
</div>
<div class="section" id="id17">
<h2><span class="section-number">1.24. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>For the computation of various derivatives with different types of wave functions, you will find it useful to use python with symbolic python, that is sympy, see <a class="reference external" href="http://docs.sympy.org/latest/index.html">online manual</a>.  Using sympy allows you autogenerate both Latex code as well c++, python or Fortran codes. Here you will find some simple examples. We choose
the <span class="math notranslate nohighlight">\(2s\)</span> hydrogen-orbital  (not normalized) as an example</p>
<div class="math notranslate nohighlight">
\[
\phi_{2s}(\boldsymbol{r}) = (Zr - 2)\exp{-(\frac{1}{2}Zr)},
\]</div>
<p>with <span class="math notranslate nohighlight">\( r^2 = x^2 + y^2 + z^2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">r</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">phi</span>
<span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This doesn’t look very nice, but sympy provides several functions that allow for improving and simplifying the output.</p>
</div>
<div class="section" id="id18">
<h2><span class="section-number">1.25. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>We can improve our output by factorizing and substituting expressions</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">printing</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#Creates a symbolic equivalent of r</span>
<span class="c1">#print latex and c++ code</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id19">
<h2><span class="section-number">1.26. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>We can in turn look at second derivatives</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">printing</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#Creates a symbolic equivalent of r</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="c1"># Collect the Z values</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="c1"># Factorize also the r**2 terms</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">((</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>With some practice this allows one to be able to check one’s own calculation and translate automatically into code lines.</p>
</div>
<div class="section" id="id20">
<h2><span class="section-number">1.27. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, main program first.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &quot;vmcsolver.h&quot;
    #include &lt;iostream&gt;
    using namespace std;
    
    int main()
    {
        VMCSolver *solver = new VMCSolver();
        solver-&gt;runMonteCarloIntegration();
        return 0;
    }
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h2><span class="section-number">1.28. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, the VMCSolver header file.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #ifndef VMCSOLVER_H
    #define VMCSOLVER_H
    #include &lt;armadillo&gt;
    using namespace arma;
    class VMCSolver
    {
    public:
        VMCSolver();
        void runMonteCarloIntegration();
    
    private:
        double waveFunction(const mat &amp;r);
        double localEnergy(const mat &amp;r);
        int nDimensions;
        int charge;
        double stepLength;
        int nParticles;
        double h;
        double h2;
        long idum;
        double alpha;
        int nCycles;
        mat rOld;
        mat rNew;
    };
    #endif // VMCSOLVER_H
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2><span class="section-number">1.29. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, VMCSolver codes, initialize.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &quot;vmcsolver.h&quot;
    #include &quot;lib.h&quot;
    #include &lt;armadillo&gt;
    #include &lt;iostream&gt;
    using namespace arma;
    using namespace std;
    
    VMCSolver::VMCSolver() :
        nDimensions(3),
        charge(2),
        stepLength(1.0),
        nParticles(2),
        h(0.001),
        h2(1000000),
        idum(-1),
        alpha(0.5*charge),
        nCycles(1000000)
    {
    }
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2><span class="section-number">1.30. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, VMCSolver codes.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    void VMCSolver::runMonteCarloIntegration()
    {
        rOld = zeros&lt;mat&gt;(nParticles, nDimensions);
        rNew = zeros&lt;mat&gt;(nParticles, nDimensions);
        double waveFunctionOld = 0;
        double waveFunctionNew = 0;
        double energySum = 0;
        double energySquaredSum = 0;
        double deltaE;
        // initial trial positions
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = 0; j &lt; nDimensions; j++) {
                rOld(i,j) = stepLength * (ran2(&amp;idum) - 0.5);
            }
        }
        rNew = rOld;
        // loop over Monte Carlo cycles
        for(int cycle = 0; cycle &lt; nCycles; cycle++) {
            // Store the current value of the wave function
            waveFunctionOld = waveFunction(rOld);
            // New position to test
            for(int i = 0; i &lt; nParticles; i++) {
                for(int j = 0; j &lt; nDimensions; j++) {
                    rNew(i,j) = rOld(i,j) + stepLength*(ran2(&amp;idum) - 0.5);
                }
                // Recalculate the value of the wave function
                waveFunctionNew = waveFunction(rNew);
                // Check for step acceptance (if yes, update position, if no, reset position)
                if(ran2(&amp;idum) &lt;= (waveFunctionNew*waveFunctionNew) / (waveFunctionOld*waveFunctionOld)) {
                    for(int j = 0; j &lt; nDimensions; j++) {
                        rOld(i,j) = rNew(i,j);
                        waveFunctionOld = waveFunctionNew;
                    }
                } else {
                    for(int j = 0; j &lt; nDimensions; j++) {
                        rNew(i,j) = rOld(i,j);
                    }
                }
                // update energies
                deltaE = localEnergy(rNew);
                energySum += deltaE;
                energySquaredSum += deltaE*deltaE;
            }
        }
        double energy = energySum/(nCycles * nParticles);
        double energySquared = energySquaredSum/(nCycles * nParticles);
        cout &lt;&lt; &quot;Energy: &quot; &lt;&lt; energy &lt;&lt; &quot; Energy (squared sum): &quot; &lt;&lt; energySquared &lt;&lt; endl;
    }
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2><span class="section-number">1.31. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, VMCSolver codes.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    double VMCSolver::localEnergy(const mat &amp;r)
    {
        mat rPlus = zeros&lt;mat&gt;(nParticles, nDimensions);
        mat rMinus = zeros&lt;mat&gt;(nParticles, nDimensions);
        rPlus = rMinus = r;
        double waveFunctionMinus = 0;
        double waveFunctionPlus = 0;
        double waveFunctionCurrent = waveFunction(r);
        // Kinetic energy, brute force derivations
        double kineticEnergy = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = 0; j &lt; nDimensions; j++) {
                rPlus(i,j) += h;
                rMinus(i,j) -= h;
                waveFunctionMinus = waveFunction(rMinus);
                waveFunctionPlus = waveFunction(rPlus);
                kineticEnergy -= (waveFunctionMinus + waveFunctionPlus - 2 * waveFunctionCurrent);
                rPlus(i,j) = r(i,j);
                rMinus(i,j) = r(i,j);
            }
        }
        kineticEnergy = 0.5 * h2 * kineticEnergy / waveFunctionCurrent;
        // Potential energy
        double potentialEnergy = 0;
        double rSingleParticle = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            rSingleParticle = 0;
            for(int j = 0; j &lt; nDimensions; j++) {
                rSingleParticle += r(i,j)*r(i,j);
            }
            potentialEnergy -= charge / sqrt(rSingleParticle);
        }
        // Contribution from electron-electron potential
        double r12 = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = i + 1; j &lt; nParticles; j++) {
                r12 = 0;
                for(int k = 0; k &lt; nDimensions; k++) {
                    r12 += (r(i,k) - r(j,k)) * (r(i,k) - r(j,k));
                }
                potentialEnergy += 1 / sqrt(r12);
            }
        }
        return kineticEnergy + potentialEnergy;
    }
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2><span class="section-number">1.32. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, VMCSolver codes.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    double VMCSolver::waveFunction(const mat &amp;r)
    {
        double argument = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            double rSingleParticle = 0;
            for(int j = 0; j &lt; nDimensions; j++) {
                rSingleParticle += r(i,j) * r(i,j);
            }
            argument += sqrt(rSingleParticle);
        }
        return exp(-argument * alpha);
    }
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2><span class="section-number">1.33. </span>The first attempt at solving the Helium atom<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<p><strong>The c++ code with a VMC Solver class, the VMCSolver header file.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &lt;armadillo&gt;
    #include &lt;iostream&gt;
    using namespace arma;
    using namespace std;
    double ran2(long *);
    
    class VMCSolver
    {
    public:
        VMCSolver();
        void runMonteCarloIntegration();
    
    private:
        double waveFunction(const mat &amp;r);
        double localEnergy(const mat &amp;r);
        int nDimensions;
        int charge;
        double stepLength;
        int nParticles;
        double h;
        double h2;
        long idum;
        double alpha;
        int nCycles;
        mat rOld;
        mat rNew;
    };
    
    VMCSolver::VMCSolver() :
        nDimensions(3),
        charge(2),
        stepLength(1.0),
        nParticles(2),
        h(0.001),
        h2(1000000),
        idum(-1),
        alpha(0.5*charge),
        nCycles(1000000)
    {
    }
    
    void VMCSolver::runMonteCarloIntegration()
    {
        rOld = zeros&lt;mat&gt;(nParticles, nDimensions);
        rNew = zeros&lt;mat&gt;(nParticles, nDimensions);
        double waveFunctionOld = 0;
        double waveFunctionNew = 0;
        double energySum = 0;
        double energySquaredSum = 0;
        double deltaE;
        // initial trial positions
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = 0; j &lt; nDimensions; j++) {
                rOld(i,j) = stepLength * (ran2(&amp;idum) - 0.5);
            }
        }
        rNew = rOld;
        // loop over Monte Carlo cycles
        for(int cycle = 0; cycle &lt; nCycles; cycle++) {
            // Store the current value of the wave function
            waveFunctionOld = waveFunction(rOld);
            // New position to test
            for(int i = 0; i &lt; nParticles; i++) {
                for(int j = 0; j &lt; nDimensions; j++) {
                    rNew(i,j) = rOld(i,j) + stepLength*(ran2(&amp;idum) - 0.5);
                }
                // Recalculate the value of the wave function
                waveFunctionNew = waveFunction(rNew);
                // Check for step acceptance (if yes, update position, if no, reset position)
                if(ran2(&amp;idum) &lt;= (waveFunctionNew*waveFunctionNew) / (waveFunctionOld*waveFunctionOld)) {
                    for(int j = 0; j &lt; nDimensions; j++) {
                        rOld(i,j) = rNew(i,j);
                        waveFunctionOld = waveFunctionNew;
                    }
                } else {
                    for(int j = 0; j &lt; nDimensions; j++) {
                        rNew(i,j) = rOld(i,j);
                    }
                }
                // update energies
                deltaE = localEnergy(rNew);
                energySum += deltaE;
                energySquaredSum += deltaE*deltaE;
            }
        }
        double energy = energySum/(nCycles * nParticles);
        double energySquared = energySquaredSum/(nCycles * nParticles);
        cout &lt;&lt; &quot;Energy: &quot; &lt;&lt; energy &lt;&lt; &quot; Energy (squared sum): &quot; &lt;&lt; energySquared &lt;&lt; endl;
    }
    
    double VMCSolver::localEnergy(const mat &amp;r)
    {
        mat rPlus = zeros&lt;mat&gt;(nParticles, nDimensions);
        mat rMinus = zeros&lt;mat&gt;(nParticles, nDimensions);
        rPlus = rMinus = r;
        double waveFunctionMinus = 0;
        double waveFunctionPlus = 0;
        double waveFunctionCurrent = waveFunction(r);
        // Kinetic energy, brute force derivations
        double kineticEnergy = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = 0; j &lt; nDimensions; j++) {
                rPlus(i,j) += h;
                rMinus(i,j) -= h;
                waveFunctionMinus = waveFunction(rMinus);
                waveFunctionPlus = waveFunction(rPlus);
                kineticEnergy -= (waveFunctionMinus + waveFunctionPlus - 2 * waveFunctionCurrent);
                rPlus(i,j) = r(i,j);
                rMinus(i,j) = r(i,j);
            }
        }
        kineticEnergy = 0.5 * h2 * kineticEnergy / waveFunctionCurrent;
        // Potential energy
        double potentialEnergy = 0;
        double rSingleParticle = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            rSingleParticle = 0;
            for(int j = 0; j &lt; nDimensions; j++) {
                rSingleParticle += r(i,j)*r(i,j);
            }
            potentialEnergy -= charge / sqrt(rSingleParticle);
        }
        // Contribution from electron-electron potential
        double r12 = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = i + 1; j &lt; nParticles; j++) {
                r12 = 0;
                for(int k = 0; k &lt; nDimensions; k++) {
                    r12 += (r(i,k) - r(j,k)) * (r(i,k) - r(j,k));
                }
                potentialEnergy += 1 / sqrt(r12);
            }
        }
        return kineticEnergy + potentialEnergy;
    }
    
    double VMCSolver::waveFunction(const mat &amp;r)
    {
        double argument = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            double rSingleParticle = 0;
            for(int j = 0; j &lt; nDimensions; j++) {
                rSingleParticle += r(i,j) * r(i,j);
            }
            argument += sqrt(rSingleParticle);
        }
        return exp(-argument * alpha);
    }
    
    /*
    ** The function
    **         ran2()
    ** is a long periode (&gt; 2 x 10^18) random number generator of
    ** L&#39;Ecuyer and Bays-Durham shuffle and added safeguards.
    ** Call with idum a negative integer to initialize; thereafter,
    ** do not alter idum between sucessive deviates in a
    ** sequence. RNMX should approximate the largest floating point value
    ** that is less than 1.
    ** The function returns a uniform deviate between 0.0 and 1.0
    ** (exclusive of end-point values).
    */
    
    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)
    
    double ran2(long *idum)
    {
      int            j;
      long           k;
      static long    idum2 = 123456789;
      static long    iy=0;
      static long    iv[NTAB];
      double         temp;
    
      if(*idum &lt;= 0) {
        if(-(*idum) &lt; 1) *idum = 1;
        else             *idum = -(*idum);
        idum2 = (*idum);
        for(j = NTAB + 7; j &gt;= 0; j--) {
          k     = (*idum)/IQ1;
          *idum = IA1*(*idum - k*IQ1) - k*IR1;
          if(*idum &lt; 0) *idum +=  IM1;
          if(j &lt; NTAB)  iv[j]  = *idum;
        }
        iy=iv[0];
      }
      k     = (*idum)/IQ1;
      *idum = IA1*(*idum - k*IQ1) - k*IR1;
      if(*idum &lt; 0) *idum += IM1;
      k     = idum2/IQ2;
      idum2 = IA2*(idum2 - k*IQ2) - k*IR2;
      if(idum2 &lt; 0) idum2 += IM2;
      j     = iy/NDIV;
      iy    = iv[j] - idum2;
      iv[j] = *idum;
      if(iy &lt; 1) iy += IMM1;
      if((temp = AM*iy) &gt; RNMX) return RNMX;
      else return temp;
    }
    #undef IM1
    #undef IM2
    #undef AM
    #undef IMM1
    #undef IA1
    #undef IA2
    #undef IQ1
    #undef IQ2
    #undef IR1
    #undef IR2
    #undef NTAB
    #undef NDIV
    #undef EPS
    #undef RNMX
    
    // End: function ran2()
    
    
    #include &lt;iostream&gt;
    using namespace std;
    
    int main()
    {
        VMCSolver *solver = new VMCSolver();
        solver-&gt;runMonteCarloIntegration();
        return 0;
    }
</pre></div>
</div>
</div>
<div class="section" id="the-metropolis-algorithm">
<h2><span class="section-number">1.34. </span>The Metropolis algorithm<a class="headerlink" href="#the-metropolis-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The Metropolis algorithm , see <a class="reference external" href="http://scitation.aip.org/content/aip/journal/jcp/21/6/10.1063/1.1699114">the original article</a> was invented by Metropolis et. al
and is often simply called the Metropolis algorithm.
It is a method to sample a normalized probability
distribution by a stochastic process. We define <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> to
be the probability for finding the system in the state <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n\)</span>.
The algorithm is then</p>
<ul class="simple">
<li><p>Sample a possible new state <span class="math notranslate nohighlight">\(j\)</span> with some probability <span class="math notranslate nohighlight">\(T_{i\rightarrow j}\)</span>.</p></li>
<li><p>Accept the new state <span class="math notranslate nohighlight">\(j\)</span> with probability <span class="math notranslate nohighlight">\(A_{i \rightarrow j}\)</span> and use it as the next sample. With probability <span class="math notranslate nohighlight">\(1-A_{i\rightarrow j}\)</span> the move is rejected and the original state <span class="math notranslate nohighlight">\(i\)</span> is used again as a sample.</p></li>
</ul>
</div>
<div class="section" id="id27">
<h2><span class="section-number">1.35. </span>The Metropolis algorithm<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<p>We wish to derive the required properties of <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(A\)</span> such that
<span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n\rightarrow \infty)} \rightarrow p_i\)</span> so that starting
from any distribution, the method converges to the correct distribution.
Note that the description here is for a discrete probability distribution.
Replacing probabilities <span class="math notranslate nohighlight">\(p_i\)</span> with expressions like <span class="math notranslate nohighlight">\(p(x_i)dx_i\)</span> will
take all of these over to the corresponding continuum expressions.</p>
</div>
<div class="section" id="id28">
<h2><span class="section-number">1.36. </span>The Metropolis algorithm<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h2>
<p>The dynamical equation for <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> can be written directly from
the description above. The probability of being in the state <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n\)</span>
is given by the probability of being in any state <span class="math notranslate nohighlight">\(j\)</span> at the previous step,
and making an accepted transition to <span class="math notranslate nohighlight">\(i\)</span> added to the probability of
being in the state <span class="math notranslate nohighlight">\(i\)</span>, making a transition to any state <span class="math notranslate nohighlight">\(j\)</span> and
rejecting the move:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \sum_j \left [
\mathbf{P}^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
+\mathbf{P}^{(n-1)}_iT_{i\rightarrow j}\left ( 1- A_{i\rightarrow j} \right)
\right ] \,.
\]</div>
<p>Since the probability of making some transition must be 1,
<span class="math notranslate nohighlight">\(\sum_j T_{i\rightarrow j} = 1\)</span>, and the above equation becomes</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \mathbf{P}^{(n-1)}_i +
 \sum_j \left [
\mathbf{P}^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
-\mathbf{P}^{(n-1)}_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] \,.
\]</div>
</div>
<div class="section" id="id29">
<h2><span class="section-number">1.37. </span>The Metropolis algorithm<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<p>For large <span class="math notranslate nohighlight">\(n\)</span> we require that <span class="math notranslate nohighlight">\(\mathbf{P}^{(n\rightarrow \infty)}_i = p_i\)</span>,
the desired probability distribution. Taking this limit, gives the
balance requirement</p>
<div class="math notranslate nohighlight">
\[
\sum_j \left [
p_jT_{j\rightarrow i} A_{j\rightarrow i}
-p_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] = 0 \,.
\]</div>
<p>The balance requirement is very weak. Typically the much stronger detailed
balance requirement is enforced, that is rather than the sum being
set to zero, we set each term separately to zero and use this
to determine the acceptance probabilities. Rearranging, the result is</p>
<div class="math notranslate nohighlight">
\[
\frac{ A_{j\rightarrow i}}{A_{i\rightarrow j}}
= \frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}} \,.
\]</div>
</div>
<div class="section" id="id30">
<h2><span class="section-number">1.38. </span>The Metropolis algorithm<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>The Metropolis choice is to maximize the <span class="math notranslate nohighlight">\(A\)</span> values, that is</p>
<div class="math notranslate nohighlight">
\[
A_{j \rightarrow i} = \min \left ( 1,
\frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}}\right ).
\]</div>
<p>Other choices are possible, but they all correspond to multilplying
<span class="math notranslate nohighlight">\(A_{i\rightarrow j}\)</span> and <span class="math notranslate nohighlight">\(A_{j\rightarrow i}\)</span> by the same constant
smaller than unity.\footnote{The penalty function method uses just such
a factor to compensate for <span class="math notranslate nohighlight">\(p_i\)</span> that are evaluated stochastically
and are therefore noisy.}</p>
</div>
<div class="section" id="id31">
<h2><span class="section-number">1.39. </span>The Metropolis algorithm<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>Having chosen the acceptance probabilities, we have guaranteed that
if the  <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> has equilibrated, that is if it is equal to <span class="math notranslate nohighlight">\(p_i\)</span>,
it will remain equilibrated. Next we need to find the circumstances for
convergence to equilibrium.</p>
<p>The dynamical equation can be written as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \sum_j M_{ij}\mathbf{P}^{(n-1)}_j
\]</div>
<p>with the matrix <span class="math notranslate nohighlight">\(M\)</span> given by</p>
<div class="math notranslate nohighlight">
\[
M_{ij} = \delta_{ij}\left [ 1 -\sum_k T_{i\rightarrow k} A_{i \rightarrow k}
\right ] + T_{j\rightarrow i} A_{j\rightarrow i} \,.
\]</div>
<p>Summing over <span class="math notranslate nohighlight">\(i\)</span> shows that <span class="math notranslate nohighlight">\(\sum_i M_{ij} = 1\)</span>, and since
<span class="math notranslate nohighlight">\(\sum_k T_{i\rightarrow k} = 1\)</span>, and <span class="math notranslate nohighlight">\(A_{i \rightarrow k} \leq 1\)</span>, the
elements of the matrix satisfy <span class="math notranslate nohighlight">\(M_{ij} \geq 0\)</span>. The matrix <span class="math notranslate nohighlight">\(M\)</span> is therefore
a stochastic matrix.</p>
</div>
<div class="section" id="id32">
<h2><span class="section-number">1.40. </span>The Metropolis algorithm<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h2>
<p>The Metropolis method is simply the power method for computing the
right eigenvector of <span class="math notranslate nohighlight">\(M\)</span> with the largest magnitude eigenvalue.
By construction, the correct probability distribution is a right eigenvector
with eigenvalue 1. Therefore, for the Metropolis method to converge
to this result, we must show that <span class="math notranslate nohighlight">\(M\)</span> has only one eigenvalue with this
magnitude, and all other eigenvalues are smaller.</p>
</div>
<div class="section" id="importance-sampling">
<h2><span class="section-number">1.41. </span>Importance sampling<a class="headerlink" href="#importance-sampling" title="Permalink to this headline">¶</a></h2>
<p>We need to replace the brute force
Metropolis algorithm with a walk in coordinate space biased by the trial wave function.
This approach is based on the Fokker-Planck equation and the Langevin equation for generating a trajectory in coordinate space.  The link between the Fokker-Planck equation and the Langevin equations are explained, only partly, in the slides below.
An excellent reference on topics like Brownian motion, Markov chains, the Fokker-Planck equation and the Langevin equation is the text by  <a class="reference external" href="http://www.elsevier.com/books/stochastic-processes-in-physics-and-chemistry/van-kampen/978-0-444-52965-7">Van Kampen</a>
Here we will focus first on the implementation part first.</p>
<p>For a diffusion process characterized by a time-dependent probability density <span class="math notranslate nohighlight">\(P(x,t)\)</span> in one dimension the Fokker-Planck
equation reads (for one particle /walker)</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial P}{\partial t} = D\frac{\partial }{\partial x}\left(\frac{\partial }{\partial x} -F\right)P(x,t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is a drift term and <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient.</p>
</div>
<div class="section" id="id33">
<h2><span class="section-number">1.42. </span>Importance sampling<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
<p>The new positions in coordinate space are given as the solutions of the Langevin equation using Euler’s method, namely,
we go from the Langevin equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial x(t)}{\partial t} = DF(x(t)) +\eta,
\]</div>
<p>with <span class="math notranslate nohighlight">\(\eta\)</span> a random variable,
yielding a new position</p>
<div class="math notranslate nohighlight">
\[
y = x+DF(x)\Delta t +\xi\sqrt{\Delta t},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\xi\)</span> is gaussian random variable and <span class="math notranslate nohighlight">\(\Delta t\)</span> is a chosen time step.
The quantity <span class="math notranslate nohighlight">\(D\)</span> is, in atomic units, equal to <span class="math notranslate nohighlight">\(1/2\)</span> and comes from the factor <span class="math notranslate nohighlight">\(1/2\)</span> in the kinetic energy operator. Note that <span class="math notranslate nohighlight">\(\Delta t\)</span> is to be viewed as a parameter. Values of <span class="math notranslate nohighlight">\(\Delta t \in [0.001,0.01]\)</span> yield in general rather stable values of the ground state energy.</p>
</div>
<div class="section" id="id34">
<h2><span class="section-number">1.43. </span>Importance sampling<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<p>The process of isotropic diffusion characterized by a time-dependent probability density <span class="math notranslate nohighlight">\(P(\mathbf{x},t)\)</span> obeys (as an approximation) the so-called Fokker-Planck equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial P}{\partial t} = \sum_i D\frac{\partial }{\partial \mathbf{x_i}}\left(\frac{\partial }{\partial \mathbf{x_i}} -\mathbf{F_i}\right)P(\mathbf{x},t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{F_i}\)</span> is the <span class="math notranslate nohighlight">\(i^{th}\)</span> component of the drift term (drift velocity) caused by an external potential, and <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient. The convergence to a stationary probability density can be obtained by setting the left hand side to zero. The resulting equation will be satisfied if and only if all the terms of the sum are equal zero,</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2 P}{\partial {\mathbf{x_i}^2}} = P\frac{\partial}{\partial {\mathbf{x_i}}}\mathbf{F_i} + \mathbf{F_i}\frac{\partial}{\partial {\mathbf{x_i}}}P.
\]</div>
</div>
<div class="section" id="id35">
<h2><span class="section-number">1.44. </span>Importance sampling<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
<p>The drift vector should be of the form <span class="math notranslate nohighlight">\(\mathbf{F} = g(\mathbf{x}) \frac{\partial P}{\partial \mathbf{x}}\)</span>. Then,</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2 P}{\partial {\mathbf{x_i}^2}} = P\frac{\partial g}{\partial P}\left( \frac{\partial P}{\partial {\mathbf{x}_i}}  \right)^2 + P g \frac{\partial ^2 P}{\partial {\mathbf{x}_i^2}}  + g \left( \frac{\partial P}{\partial {\mathbf{x}_i}}  \right)^2.
\]</div>
<p>The condition of stationary density means that the left hand side equals zero. In other words, the terms containing first and second derivatives have to cancel each other. It is possible only if <span class="math notranslate nohighlight">\(g = \frac{1}{P}\)</span>, which yields</p>
<div class="math notranslate nohighlight">
\[
\mathbf{F} = 2\frac{1}{\Psi_T}\nabla\Psi_T,
\]</div>
<p>which is known as the so-called <em>quantum force</em>. This term is responsible for pushing the walker towards regions of configuration space where the trial wave function is large, increasing the efficiency of the simulation in contrast to the Metropolis algorithm where the walker has the same probability of moving in every direction.</p>
</div>
<div class="section" id="id36">
<h2><span class="section-number">1.45. </span>Importance sampling<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
<p>The Fokker-Planck equation yields a (the solution to the equation) transition probability given by the Green’s function</p>
<div class="math notranslate nohighlight">
\[
G(y,x,\Delta t) = \frac{1}{(4\pi D\Delta t)^{3N/2}} \exp{\left(-(y-x-D\Delta t F(x))^2/4D\Delta t\right)}
\]</div>
<p>which in turn means that our brute force Metropolis algorithm</p>
<div class="math notranslate nohighlight">
\[
A(y,x) = \mathrm{min}(1,q(y,x))),
\]</div>
<p>with <span class="math notranslate nohighlight">\(q(y,x) = |\Psi_T(y)|^2/|\Psi_T(x)|^2\)</span> is now replaced by the <a class="reference external" href="http://scitation.aip.org/content/aip/journal/jcp/21/6/10.1063/1.1699114">Metropolis-Hastings algorithm</a> as well as <a class="reference external" href="http://biomet.oxfordjournals.org/content/57/1/97.abstract">Hasting’s article</a>,</p>
<div class="math notranslate nohighlight">
\[
q(y,x) = \frac{G(x,y,\Delta t)|\Psi_T(y)|^2}{G(y,x,\Delta t)|\Psi_T(x)|^2}
\]</div>
</div>
<div class="section" id="importance-sampling-program-elements">
<h2><span class="section-number">1.46. </span>Importance sampling, program elements<a class="headerlink" href="#importance-sampling-program-elements" title="Permalink to this headline">¶</a></h2>
<p>The full code is <a class="reference external" href="https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/pub/vmc/programs/c%2B%2B">this link</a>. Here we include only the parts pertaining to the computation of the quantum force and the Metropolis update. The program is a modfication of our previous c++ program discussed previously. Here we display only the part from the <em>vmcsolver.cpp</em>  file.  Note the usage of the function <em>GaussianDeviate</em>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    void VMCSolver::runMonteCarloIntegration()
    {
      rOld = zeros&lt;mat&gt;(nParticles, nDimensions);
      rNew = zeros&lt;mat&gt;(nParticles, nDimensions);
      QForceOld = zeros&lt;mat&gt;(nParticles, nDimensions);
      QForceNew = zeros&lt;mat&gt;(nParticles, nDimensions);
    
      double waveFunctionOld = 0;
      double waveFunctionNew = 0;
    
      double energySum = 0;
      double energySquaredSum = 0;
    
      double deltaE;
    
      // initial trial positions
      for(int i = 0; i &lt; nParticles; i++) {
        for(int j = 0; j &lt; nDimensions; j++) {
          rOld(i,j) = GaussianDeviate(&amp;idum)*sqrt(timestep);
        }
      }
      rNew = rOld;
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h2><span class="section-number">1.47. </span>Importance sampling, program elements<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      for(int cycle = 0; cycle &lt; nCycles; cycle++) {
    
        // Store the current value of the wave function
        waveFunctionOld = waveFunction(rOld);
        QuantumForce(rOld, QForceOld); QForceOld = QForceOld*h/waveFunctionOld;
        // New position to test
        for(int i = 0; i &lt; nParticles; i++) {
          for(int j = 0; j &lt; nDimensions; j++) {
    	rNew(i,j) = rOld(i,j) + GaussianDeviate(&amp;idum)*sqrt(timestep)+QForceOld(i,j)*timestep*D;
          }
          //  for the other particles we need to set the position to the old position since
          //  we move only one particle at the time
          for (int k = 0; k &lt; nParticles; k++) {
    	if ( k != i) {
    	  for (int j=0; j &lt; nDimensions; j++) {
    	    rNew(k,j) = rOld(k,j);
    	  }
    	} 
          }
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h2><span class="section-number">1.48. </span>Importance sampling, program elements<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      // loop over Monte Carlo cycles
          // Recalculate the value of the wave function and the quantum force
          waveFunctionNew = waveFunction(rNew);
          QuantumForce(rNew,QForceNew) = QForceNew*h/waveFunctionNew;
          //  we compute the log of the ratio of the greens functions to be used in the 
          //  Metropolis-Hastings algorithm
          GreensFunction = 0.0;            
          for (int j=0; j &lt; nDimensions; j++) {
    	GreensFunction += 0.5*(QForceOld(i,j)+QForceNew(i,j))*
    	  (D*timestep*0.5*(QForceOld(i,j)-QForceNew(i,j))-rNew(i,j)+rOld(i,j));
          }
          GreensFunction = exp(GreensFunction);
    
          // The Metropolis test is performed by moving one particle at the time
          if(ran2(&amp;idum) &lt;= GreensFunction*(waveFunctionNew*waveFunctionNew) / (waveFunctionOld*waveFunctionOld)) {
    	for(int j = 0; j &lt; nDimensions; j++) {
    	  rOld(i,j) = rNew(i,j);
    	  QForceOld(i,j) = QForceNew(i,j);
    	  waveFunctionOld = waveFunctionNew;
    	}
          } else {
    	for(int j = 0; j &lt; nDimensions; j++) {
    	  rNew(i,j) = rOld(i,j);
    	  QForceNew(i,j) = QForceOld(i,j);
    	}
          }
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h2><span class="section-number">1.49. </span>Importance sampling, program elements<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<p><strong>Note numerical derivatives.</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    double VMCSolver::QuantumForce(const mat &amp;r, mat &amp;QForce)
    {
        mat rPlus = zeros&lt;mat&gt;(nParticles, nDimensions);
        mat rMinus = zeros&lt;mat&gt;(nParticles, nDimensions);
        rPlus = rMinus = r;
        double waveFunctionMinus = 0;
        double waveFunctionPlus = 0;
        double waveFunctionCurrent = waveFunction(r);
    
        // Kinetic energy
    
        double kineticEnergy = 0;
        for(int i = 0; i &lt; nParticles; i++) {
            for(int j = 0; j &lt; nDimensions; j++) {
                rPlus(i,j) += h;
                rMinus(i,j) -= h;
                waveFunctionMinus = waveFunction(rMinus);
                waveFunctionPlus = waveFunction(rPlus);
                QForce(i,j) =  (waveFunctionPlus-waveFunctionMinus);
                rPlus(i,j) = r(i,j);
                rMinus(i,j) = r(i,j);
            }
        }
    }
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h2><span class="section-number">1.50. </span>Importance sampling, program elements<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
<p>The general derivative formula of the Jastrow factor is (the subscript <span class="math notranslate nohighlight">\(C\)</span> stands for Correlation)</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_k}
\]</div>
<p>However,
with our written in way which can be reused later as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})= \exp{\left\{\sum_{i&lt;j}f(r_{ij})\right\}},
\]</div>
<p>the gradient needed for the quantum force and local energy is easy to compute.<br />
The function <span class="math notranslate nohighlight">\(f(r_{ij})\)</span> will depends on the system under study. In the equations below we will keep this general form.</p>
</div>
<div class="section" id="id41">
<h2><span class="section-number">1.51. </span>Importance sampling, program elements<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<p>In the Metropolis/Hasting algorithm, the <em>acceptance ratio</em> determines the probability for a particle  to be accepted at a new position. The ratio of the trial wave functions evaluated at the new and current positions is given by (<span class="math notranslate nohighlight">\(OB\)</span> for the onebody  part)</p>
<div class="math notranslate nohighlight">
\[
R \equiv \frac{\Psi_{T}^{new}}{\Psi_{T}^{old}} = 
\frac{\Psi_{OB}^{new}}{\Psi_{OB}^{old}}\frac{\Psi_{C}^{new}}{\Psi_{C}^{old}}
\]</div>
<p>Here <span class="math notranslate nohighlight">\(\Psi_{OB}\)</span> is our onebody part (Slater determinant or product of boson single-particle states)  while <span class="math notranslate nohighlight">\(\Psi_{C}\)</span> is our correlation function, or Jastrow factor.
We need to optimize the <span class="math notranslate nohighlight">\(\nabla \Psi_T / \Psi_T\)</span> ratio and the second derivative as well, that is
the <span class="math notranslate nohighlight">\(\mathbf{\nabla}^2 \Psi_T/\Psi_T\)</span> ratio. The first is needed when we compute the so-called quantum force in importance sampling.
The second is needed when we compute the kinetic energy term of the local energy.</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\mathbf{\nabla}}  \Psi}{\Psi}  = \frac{\mathbf{\nabla}  (\Psi_{OB} \, \Psi_{C})}{\Psi_{OB} \, \Psi_{C}}  =  \frac{ \Psi_C \mathbf{\nabla}  \Psi_{OB} + \Psi_{OB} \mathbf{\nabla}  \Psi_{C}}{\Psi_{OB} \Psi_{C}} = \frac{\mathbf{\nabla}  \Psi_{OB}}{\Psi_{OB}} + \frac{\mathbf{\nabla}   \Psi_C}{ \Psi_C}
\]</div>
</div>
<div class="section" id="id42">
<h2><span class="section-number">1.52. </span>Importance sampling<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h2>
<p>The expectation value of the kinetic energy expressed in atomic units for electron <span class="math notranslate nohighlight">\(i\)</span> is</p>
<p>6
3</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\hat{K}_i = -\frac{1}{2}\frac{\mathbf{\nabla}_{i}^{2} \Psi}{\Psi}.
\]</div>
</div>
<div class="section" id="id43">
<h2><span class="section-number">1.53. </span>Importance sampling<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h2>
<p>The second derivative which enters the definition of the local energy is</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}^2 \Psi}{\Psi}=\frac{\mathbf{\nabla}^2 \Psi_{OB}}{\Psi_{OB}} + \frac{\mathbf{\nabla}^2  \Psi_C}{ \Psi_C} + 2 \frac{\mathbf{\nabla}  \Psi_{OB}}{\Psi_{OB}}\cdot\frac{\mathbf{\nabla}   \Psi_C}{ \Psi_C}
\]</div>
<p>We discuss here how to calculate these quantities in an optimal way,</p>
</div>
<div class="section" id="id44">
<h2><span class="section-number">1.54. </span>Importance sampling<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<p>We have defined the correlated function as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})=\prod_{i&lt; j}^Ng(r_{ij})= \prod_{i=1}^N\prod_{j=i+1}^Ng(r_{ij}),
\]</div>
<p>with
<span class="math notranslate nohighlight">\(r_{ij}=|\mathbf{r}_i-\mathbf{r}_j|=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}\)</span> in three dimensions or
<span class="math notranslate nohighlight">\(r_{ij}=|\mathbf{r}_i-\mathbf{r}_j|=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span> if we work with two-dimensional systems.</p>
<p>In our particular case we have</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})=\exp{\left\{\sum_{i&lt;j}f(r_{ij})\right\}}.
\]</div>
</div>
<div class="section" id="id45">
<h2><span class="section-number">1.55. </span>Importance sampling<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h2>
<p>The total number of different relative distances <span class="math notranslate nohighlight">\(r_{ij}\)</span> is <span class="math notranslate nohighlight">\(N(N-1)/2\)</span>. In a matrix storage format, the relative distances  form a strictly upper triangular matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{r} \equiv \begin{pmatrix}
  0 &amp; r_{1,2} &amp; r_{1,3} &amp; \cdots &amp; r_{1,N} \\
  \vdots &amp; 0       &amp; r_{2,3} &amp; \cdots &amp; r_{2,N} \\
  \vdots &amp; \vdots  &amp; 0  &amp; \ddots &amp; \vdots  \\
  \vdots &amp; \vdots  &amp; \vdots  &amp; \ddots  &amp; r_{N-1,N} \\
  0 &amp; 0  &amp; 0  &amp; \cdots  &amp; 0
 \end{pmatrix}.
\end{split}\]</div>
<p>This applies to  <span class="math notranslate nohighlight">\(\mathbf{g} = \mathbf{g}(r_{ij})\)</span> as well.</p>
<p>In our algorithm we will move one particle  at the time, say the <span class="math notranslate nohighlight">\(kth\)</span>-particle.  This sampling will be seen to be particularly efficient when we are going to compute a Slater determinant.</p>
</div>
<div class="section" id="id46">
<h2><span class="section-number">1.56. </span>Importance sampling<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
<p>We have that the ratio between Jastrow factors <span class="math notranslate nohighlight">\(R_C\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
R_{C} = \frac{\Psi_{C}^\mathrm{new}}{\Psi_{C}^\mathrm{cur}} =
\prod_{i=1}^{k-1}\frac{g_{ik}^\mathrm{new}}{g_{ik}^\mathrm{cur}}
\prod_{i=k+1}^{N}\frac{ g_{ki}^\mathrm{new}} {g_{ki}^\mathrm{cur}}.
\]</div>
<p>For the Pade-Jastrow form</p>
<div class="math notranslate nohighlight">
\[
R_{C} = \frac{\Psi_{C}^\mathrm{new}}{\Psi_{C}^\mathrm{cur}} = 
\frac{\exp{U_{new}}}{\exp{U_{cur}}} = \exp{\Delta U},
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\Delta U =
\sum_{i=1}^{k-1}\big(f_{ik}^\mathrm{new}-f_{ik}^\mathrm{cur}\big)
+
\sum_{i=k+1}^{N}\big(f_{ki}^\mathrm{new}-f_{ki}^\mathrm{cur}\big)
\]</div>
</div>
<div class="section" id="id47">
<h2><span class="section-number">1.57. </span>Importance sampling<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h2>
<p>One needs to develop a special algorithm
that runs only through the elements of the upper triangular
matrix <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> and have <span class="math notranslate nohighlight">\(k\)</span> as an index.</p>
<p>The expression to be derived in the following is of interest when computing the quantum force and the kinetic energy. It has the form</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\Psi_C}{\Psi_C} = \frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_i},
\]</div>
<p>for all dimensions and with <span class="math notranslate nohighlight">\(i\)</span> running over all particles.</p>
</div>
<div class="section" id="id48">
<h2><span class="section-number">1.58. </span>Importance sampling<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>For the first derivative only <span class="math notranslate nohighlight">\(N-1\)</span> terms survive the ratio because the <span class="math notranslate nohighlight">\(g\)</span>-terms that are not differentiated cancel with their corresponding ones in the denominator. Then,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{1}{g_{ik}}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\partial g_{ki}}{\partial x_k}.
\]</div>
<p>An equivalent equation is obtained for the exponential form after replacing <span class="math notranslate nohighlight">\(g_{ij}\)</span> by <span class="math notranslate nohighlight">\(\exp(f_{ij})\)</span>, yielding:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_k},
\]</div>
<p>with both expressions scaling as <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>.</p>
</div>
<div class="section" id="id49">
<h2><span class="section-number">1.59. </span>Importance sampling<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
<p>Using the identity</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial}{\partial x_i}g_{ij} = -\frac{\partial}{\partial x_j}g_{ij},
\]</div>
<p>we get expressions where all the derivatives acting on the particle  are represented by the <em>second</em> index of <span class="math notranslate nohighlight">\(g\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{1}{g_{ik}}\frac{\partial g_{ik}}{\partial x_k}
-\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\partial g_{ki}}{\partial x_i},
\]</div>
<p>and for the exponential case:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
-\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}.
\]</div>
</div>
<div class="section" id="id50">
<h2><span class="section-number">1.60. </span>Importance sampling<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
<p>For correlation forms depending only on the scalar distances <span class="math notranslate nohighlight">\(r_{ij}\)</span> we can use the chain rule. Noting that</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial g_{ij}}{\partial x_j} = \frac{\partial g_{ij}}{\partial r_{ij}} \frac{\partial r_{ij}}{\partial x_j} = \frac{x_j - x_i}{r_{ij}} \frac{\partial g_{ij}}{\partial r_{ij}},
\]</div>
<p>we arrive at</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} = 
\sum_{i=1}^{k-1}\frac{1}{g_{ik}} \frac{\mathbf{r_{ik}}}{r_{ik}} \frac{\partial g_{ik}}{\partial r_{ik}}
-\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\mathbf{r_{ki}}}{r_{ki}}\frac{\partial g_{ki}}{\partial r_{ki}}.
\]</div>
</div>
<div class="section" id="id51">
<h2><span class="section-number">1.61. </span>Importance sampling<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
<p>Note that for the Pade-Jastrow form we can set <span class="math notranslate nohighlight">\(g_{ij} \equiv g(r_{ij}) = e^{f(r_{ij})} = e^{f_{ij}}\)</span> and</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial g_{ij}}{\partial r_{ij}} = g_{ij} \frac{\partial f_{ij}}{\partial r_{ij}}.
\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_{C}}\frac{\partial \Psi_{C}}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\mathbf{r_{ik}}}{r_{ik}}\frac{\partial f_{ik}}{\partial r_{ik}}
-\sum_{i=k+1}^{N}\frac{\mathbf{r_{ki}}}{r_{ki}}\frac{\partial f_{ki}}{\partial r_{ki}},
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\mathbf{r}_{ij} = |\mathbf{r}_j - \mathbf{r}_i| = (x_j - x_i)\mathbf{e}_1 + (y_j - y_i)\mathbf{e}_2 + (z_j - z_i)\mathbf{e}_3
\]</div>
<p>is the relative distance.</p>
</div>
<div class="section" id="id52">
<h2><span class="section-number">1.62. </span>Importance sampling<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h2>
<p>The second derivative of the Jastrow factor divided by the Jastrow factor (the way it enters the kinetic energy) is</p>
<div class="math notranslate nohighlight">
\[
\left[\frac{\mathbf{\nabla}^2 \Psi_C}{\Psi_C}\right]_x =\  
2\sum_{k=1}^{N}
\sum_{i=1}^{k-1}\frac{\partial^2 g_{ik}}{\partial x_k^2}\ +\ 
\sum_{k=1}^N
\left(
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k} -
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}
\right)^2
\]</div>
</div>
<div class="section" id="id53">
<h2><span class="section-number">1.63. </span>Importance sampling<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h2>
<p>But we have a simple form for the function, namely</p>
<div class="math notranslate nohighlight">
\[
\Psi_{C}=\prod_{i&lt; j}\exp{f(r_{ij})},
\]</div>
<p>and it is easy to see that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}f'(r_{ki})f'(r_{kj})+
\sum_{j\ne k}\left( f''(r_{kj})+\frac{2}{r_{kj}}f'(r_{kj})\right)
\]</div>
</div>
<div class="section" id="use-the-c-random-class-for-random-number-generations">
<h2><span class="section-number">1.64. </span>Use the <a class="reference external" href="http://www.cplusplus.com/reference/random/">C++ random class for random number generations</a><a class="headerlink" href="#use-the-c-random-class-for-random-number-generations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     // Initialize the seed and call the Mersienne algo
      std::random_device rd;
      std::mt19937_64 gen(rd());
      // Set up the uniform distribution for x \in [[0, 1]
      std::uniform_real_distribution&lt;double&gt; UniformNumberGenerator(0.0,1.0);
      std::normal_distribution&lt;double&gt; Normaldistribution(0.0,1.0);
</pre></div>
</div>
</div>
<div class="section" id="use-the-c-random-class-for-rngs-the-mersenne-twister-class">
<h2><span class="section-number">1.65. </span>Use the C++ random class for RNGs, the Mersenne twister class<a class="headerlink" href="#use-the-c-random-class-for-rngs-the-mersenne-twister-class" title="Permalink to this headline">¶</a></h2>
<p><strong>Finding the new position for importance sampling</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     for (int cycles = 1; cycles &lt;= NumberMCsamples; cycles++){ 
        // new position 
        for (int i = 0; i &lt; NumberParticles; i++) { 
          for (int j = 0; j &lt; Dimension; j++) {
            // gaussian deviate to compute new positions using a given timestep
            NewPosition(i,j) = OldPosition(i,j) + Normaldistribution(gen)*sqrt(timestep)+OldQuantumForce(i,j)*timestep*D;
    
          }  
</pre></div>
</div>
</div>
<div class="section" id="use-the-c-random-class-for-rngs-the-metropolis-test">
<h2><span class="section-number">1.66. </span>Use the C++ random class for RNGs, the Metropolis test<a class="headerlink" href="#use-the-c-random-class-for-rngs-the-metropolis-test" title="Permalink to this headline">¶</a></h2>
<p><strong>Using the uniform distribution for the Metropolis test</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          //  Metropolis-Hastings algorithm
          double GreensFunction = 0.0;            
          for (int j = 0; j &lt; Dimension; j++) {
            GreensFunction += 0.5*(OldQuantumForce(i,j)+NewQuantumForce(i,j))*
              (D*timestep*0.5*(OldQuantumForce(i,j)-NewQuantumForce(i,j))-NewPosition(i,j)+OldPosition(i,j));
          }
          GreensFunction = exp(GreensFunction);
          // The Metropolis test is performed by moving one particle at the time
          if(UniformNumberGenerator(gen) &lt;= GreensFunction*NewWaveFunction*NewWaveFunction/OldWaveFunction/OldWaveFunction ) { 
            for (int  j = 0; j &lt; Dimension; j++) {
              OldPosition(i,j) = NewPosition(i,j);
              OldQuantumForce(i,j) = NewQuantumForce(i,j);
            }
            OldWaveFunction = NewWaveFunction;
          }
</pre></div>
</div>
</div>
<div class="section" id="importance-sampling-fokker-planck-and-langevin-equations">
<h2><span class="section-number">1.67. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#importance-sampling-fokker-planck-and-langevin-equations" title="Permalink to this headline">¶</a></h2>
<p>A stochastic process is simply a function of two variables, one is the time,
the other is a stochastic variable <span class="math notranslate nohighlight">\(X\)</span>, defined by specifying</p>
<ul class="simple">
<li><p>the set <span class="math notranslate nohighlight">\(\left\{x\right\}\)</span> of possible values for <span class="math notranslate nohighlight">\(X\)</span>;</p></li>
<li><p>the probability distribution, <span class="math notranslate nohighlight">\(w_X(x)\)</span>,  over this set, or briefly <span class="math notranslate nohighlight">\(w(x)\)</span></p></li>
</ul>
<p>The set of values <span class="math notranslate nohighlight">\(\left\{x\right\}\)</span> for <span class="math notranslate nohighlight">\(X\)</span>
may be discrete, or continuous. If the set of
values is continuous, then <span class="math notranslate nohighlight">\(w_X (x)\)</span> is a probability density so that
<span class="math notranslate nohighlight">\(w_X (x)dx\)</span>
is the probability that one finds the stochastic variable <span class="math notranslate nohighlight">\(X\)</span> to have values
in the range <span class="math notranslate nohighlight">\([x, x + dx]\)</span> .</p>
</div>
<div class="section" id="id54">
<h2><span class="section-number">1.68. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> An arbitrary number of other stochastic variables may be derived from
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(X\)</span>. For example, any <span class="math notranslate nohighlight">\(Y\)</span> given by a mapping of <span class="math notranslate nohighlight">\(X\)</span>, is also a stochastic
variable. The mapping may also be time-dependent, that is, the mapping
depends on an additional variable <span class="math notranslate nohighlight">\(t\)</span></p>
<div class="math notranslate nohighlight">
\[
Y_X (t) = f (X, t) .
\]</div>
<p>The quantity <span class="math notranslate nohighlight">\(Y_X (t)\)</span> is called a random function, or, since <span class="math notranslate nohighlight">\(t\)</span> often is time,
a stochastic process. A stochastic process is a function of two variables,
one is the time, the other is a stochastic variable <span class="math notranslate nohighlight">\(X\)</span>. Let <span class="math notranslate nohighlight">\(x\)</span> be one of the
possible values of <span class="math notranslate nohighlight">\(X\)</span> then</p>
<div class="math notranslate nohighlight">
\[
y(t) = f (x, t),
\]</div>
<p>is a function of <span class="math notranslate nohighlight">\(t\)</span>, called a sample function or realization of the process.
In physics one considers the stochastic process to be an ensemble of such
sample functions.</p>
</div>
<div class="section" id="id55">
<h2><span class="section-number">1.69. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> For many physical systems initial distributions of a stochastic 
</pre></div>
</div>
<p>variable <span class="math notranslate nohighlight">\(y\)</span> tend to equilibrium distributions: <span class="math notranslate nohighlight">\(w(y, t)\rightarrow w_0(y)\)</span>
as <span class="math notranslate nohighlight">\(t\rightarrow\infty\)</span>. In
equilibrium detailed balance constrains the transition rates</p>
<div class="math notranslate nohighlight">
\[
W(y\rightarrow y')w(y ) = W(y'\rightarrow y)w_0 (y),
\]</div>
<p>where <span class="math notranslate nohighlight">\(W(y'\rightarrow y)\)</span>
is the probability, per unit time, that the system changes
from a state <span class="math notranslate nohighlight">\(|y\rangle\)</span> , characterized by the value <span class="math notranslate nohighlight">\(y\)</span>
for the stochastic variable <span class="math notranslate nohighlight">\(Y\)</span> , to a state <span class="math notranslate nohighlight">\(|y'\rangle\)</span>.</p>
<p>Note that for a system in equilibrium the transition rate
<span class="math notranslate nohighlight">\(W(y'\rightarrow y)\)</span> and
the reverse <span class="math notranslate nohighlight">\(W(y\rightarrow y')\)</span> may be very different.</p>
</div>
<div class="section" id="id56">
<h2><span class="section-number">1.70. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h2>
<p>Consider, for instance, a simple
system that has only two energy levels <span class="math notranslate nohighlight">\(\epsilon_0 = 0\)</span> and
<span class="math notranslate nohighlight">\(\epsilon_1 = \Delta E\)</span>.</p>
<p>For a system governed by the Boltzmann distribution we find (the partition function has been taken out)</p>
<div class="math notranslate nohighlight">
\[
W(0\rightarrow 1)\exp{-(\epsilon_0/kT)} = W(1\rightarrow 0)\exp{-(\epsilon_1/kT)}
\]</div>
<p>We get then</p>
<div class="math notranslate nohighlight">
\[
\frac{W(1\rightarrow 0)}{W(0 \rightarrow 1)}=\exp{-(\Delta E/kT)},
\]</div>
<p>which goes to zero when <span class="math notranslate nohighlight">\(T\)</span> tends to zero.</p>
</div>
<div class="section" id="id57">
<h2><span class="section-number">1.71. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h2>
<p>If we assume a discrete set of events,
our initial probability
distribution function can be  given by</p>
<div class="math notranslate nohighlight">
\[
w_i(0) = \delta_{i,0},
\]</div>
<p>and its time-development after a given time step <span class="math notranslate nohighlight">\(\Delta t=\epsilon\)</span> is</p>
<div class="math notranslate nohighlight">
\[
w_i(t) = \sum_{j}W(j\rightarrow i)w_j(t=0).
\]</div>
<p>The continuous analog to <span class="math notranslate nohighlight">\(w_i(0)\)</span> is</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x})\rightarrow \delta(\mathbf{x}),
\]</div>
<p>where we now have generalized the one-dimensional position <span class="math notranslate nohighlight">\(x\)</span> to a generic-dimensional<br />
vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. The Kroenecker <span class="math notranslate nohighlight">\(\delta\)</span> function is replaced by the <span class="math notranslate nohighlight">\(\delta\)</span> distribution
function <span class="math notranslate nohighlight">\(\delta(\mathbf{x})\)</span> at  <span class="math notranslate nohighlight">\(t=0\)</span>.</p>
</div>
<div class="section" id="id58">
<h2><span class="section-number">1.72. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h2>
<p>The transition from a state <span class="math notranslate nohighlight">\(j\)</span> to a state <span class="math notranslate nohighlight">\(i\)</span> is now replaced by a transition
to a state with position <span class="math notranslate nohighlight">\(\mathbf{y}\)</span> from a state with position <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.
The discrete sum of transition probabilities can then be replaced by an integral
and we obtain the new distribution at a time <span class="math notranslate nohighlight">\(t+\Delta t\)</span> as</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y},t+\Delta t)= \int W(\mathbf{y},t+\Delta t| \mathbf{x},t)w(\mathbf{x},t)d\mathbf{x},
\]</div>
<p>and after <span class="math notranslate nohighlight">\(m\)</span> time steps we have</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y},t+m\Delta t)= \int W(\mathbf{y},t+m\Delta t| \mathbf{x},t)w(\mathbf{x},t)d\mathbf{x}.
\]</div>
<p>When equilibrium is reached we have</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y})= \int W(\mathbf{y}|\mathbf{x}, t)w(\mathbf{x})d\mathbf{x},
\]</div>
<p>that is no time-dependence. Note our change of notation for <span class="math notranslate nohighlight">\(W\)</span></p>
</div>
<div class="section" id="id59">
<h2><span class="section-number">1.73. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h2>
<p>We can solve the equation for <span class="math notranslate nohighlight">\(w(\mathbf{y},t)\)</span> by making a Fourier transform to
momentum space.
The PDF <span class="math notranslate nohighlight">\(w(\mathbf{x},t)\)</span> is related to its Fourier transform
<span class="math notranslate nohighlight">\(\tilde{w}(\mathbf{k},t)\)</span> through</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t) = \int_{-\infty}^{\infty}d\mathbf{k} \exp{(i\mathbf{kx})}\tilde{w}(\mathbf{k},t),
\]</div>
<p>and using the definition of the
<span class="math notranslate nohighlight">\(\delta\)</span>-function</p>
<div class="math notranslate nohighlight">
\[
\delta(\mathbf{x}) = \frac{1}{2\pi} \int_{-\infty}^{\infty}d\mathbf{k} \exp{(i\mathbf{kx})},
\]</div>
<p>we see that</p>
<div class="math notranslate nohighlight">
\[
\tilde{w}(\mathbf{k},0)=1/2\pi.
\]</div>
</div>
<div class="section" id="id60">
<h2><span class="section-number">1.74. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h2>
<p>We can then use the Fourier-transformed diffusion equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \tilde{w}(\mathbf{k},t)}{\partial t} = -D\mathbf{k}^2\tilde{w}(\mathbf{k},t),
\]</div>
<p>with the obvious solution</p>
<div class="math notranslate nohighlight">
\[
\tilde{w}(\mathbf{k},t)=\tilde{w}(\mathbf{k},0)\exp{\left[-(D\mathbf{k}^2t)\right)}=
    \frac{1}{2\pi}\exp{\left[-(D\mathbf{k}^2t)\right]}.
\]</div>
</div>
<div class="section" id="id61">
<h2><span class="section-number">1.75. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h2>
<p>With the Fourier transform we obtain</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)=\int_{-\infty}^{\infty}d\mathbf{k} \exp{\left[i\mathbf{kx}\right]}\frac{1}{2\pi}\exp{\left[-(D\mathbf{k}^2t)\right]}=
    \frac{1}{\sqrt{4\pi Dt}}\exp{\left[-(\mathbf{x}^2/4Dt)\right]},
\]</div>
<p>with the normalization condition</p>
<div class="math notranslate nohighlight">
\[
\int_{-\infty}^{\infty}w(\mathbf{x},t)d\mathbf{x}=1.
\]</div>
</div>
<div class="section" id="id62">
<h2><span class="section-number">1.76. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h2>
<p>The solution represents the probability of finding
our random walker at position <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> at time <span class="math notranslate nohighlight">\(t\)</span> if the initial distribution
was placed at <span class="math notranslate nohighlight">\(\mathbf{x}=0\)</span> at <span class="math notranslate nohighlight">\(t=0\)</span>.</p>
<p>There is another interesting feature worth observing. The discrete transition probability <span class="math notranslate nohighlight">\(W\)</span>
itself is given by a binomial distribution.
The results from the central limit theorem state that
transition probability in the limit <span class="math notranslate nohighlight">\(n\rightarrow \infty\)</span> converges to the normal
distribution. It is then possible to show that</p>
<div class="math notranslate nohighlight">
\[
W(il-jl,n\epsilon)\rightarrow W(\mathbf{y},t+\Delta t|\mathbf{x},t)=
    \frac{1}{\sqrt{4\pi D\Delta t}}\exp{\left[-((\mathbf{y}-\mathbf{x})^2/4D\Delta t)\right]},
\]</div>
<p>and that it satisfies the normalization condition and is itself a solution
to the diffusion equation.</p>
</div>
<div class="section" id="id63">
<h2><span class="section-number">1.77. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h2>
<p>Let us now assume that we have three PDFs for times <span class="math notranslate nohighlight">\(t_0 &lt; t' &lt; t\)</span>, that is
<span class="math notranslate nohighlight">\(w(\mathbf{x}_0,t_0)\)</span>, <span class="math notranslate nohighlight">\(w(\mathbf{x}',t')\)</span> and <span class="math notranslate nohighlight">\(w(\mathbf{x},t)\)</span>.
We have then</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)= \int_{-\infty}^{\infty} W(\mathbf{x}.t|\mathbf{x}'.t')w(\mathbf{x}',t')d\mathbf{x}',
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)= \int_{-\infty}^{\infty} W(\mathbf{x}.t|\mathbf{x}_0.t_0)w(\mathbf{x}_0,t_0)d\mathbf{x}_0,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x}',t')= \int_{-\infty}^{\infty} W(\mathbf{x}'.t'|\mathbf{x}_0,t_0)w(\mathbf{x}_0,t_0)d\mathbf{x}_0.
\]</div>
</div>
<div class="section" id="id64">
<h2><span class="section-number">1.78. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h2>
<p>We can combine these equations and arrive at the famous Einstein-Smoluchenski-Kolmogorov-Chapman (ESKC) relation</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x}t|\mathbf{x}_0t_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},t|\mathbf{x}',t')W(\mathbf{x}',t'|\mathbf{x}_0,t_0)d\mathbf{x}'.
\]</div>
<p>We can replace the spatial dependence with a dependence upon say the velocity
(or momentum), that is we have</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{v},t|\mathbf{v}_0,t_0)  = \int_{-\infty}^{\infty} W(\mathbf{v},t|\mathbf{v}',t')W(\mathbf{v}',t'|\mathbf{v}_0,t_0)d\mathbf{x}'.
\]</div>
</div>
<div class="section" id="id65">
<h2><span class="section-number">1.79. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h2>
<p>We will now derive the Fokker-Planck equation.
We start from the ESKC equation</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},t|\mathbf{x}_0,t_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},t|\mathbf{x}',t')W(\mathbf{x}',t'|\mathbf{x}_0,t_0)d\mathbf{x}'.
\]</div>
<p>Define <span class="math notranslate nohighlight">\(s=t'-t_0\)</span>, <span class="math notranslate nohighlight">\(\tau=t-t'\)</span> and <span class="math notranslate nohighlight">\(t-t_0=s+\tau\)</span>. We have then</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},s+\tau|\mathbf{x}_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},\tau|\mathbf{x}')W(\mathbf{x}',s|\mathbf{x}_0)d\mathbf{x}'.
\]</div>
</div>
<div class="section" id="id66">
<h2><span class="section-number">1.80. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h2>
<p>Assume now that <span class="math notranslate nohighlight">\(\tau\)</span> is very small so that we can make an expansion in terms of a small step <span class="math notranslate nohighlight">\(xi\)</span>, with <span class="math notranslate nohighlight">\(\mathbf{x}'=\mathbf{x}-\xi\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},s|\mathbf{x}_0)+\frac{\partial W}{\partial s}\tau +O(\tau^2) = \int_{-\infty}^{\infty} W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0)d\mathbf{x}'.
\]</div>
<p>We assume that <span class="math notranslate nohighlight">\(W(\mathbf{x},\tau|\mathbf{x}-\xi)\)</span> takes non-negligible values only when <span class="math notranslate nohighlight">\(\xi\)</span> is small. This is just another way of stating the Master equation!!</p>
</div>
<div class="section" id="id67">
<h2><span class="section-number">1.81. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id67" title="Permalink to this headline">¶</a></h2>
<p>We say thus that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> changes only by a small amount in the time interval <span class="math notranslate nohighlight">\(\tau\)</span>.
This means that we can make a Taylor expansion in terms of <span class="math notranslate nohighlight">\(\xi\)</span>, that is we
expand</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0) =
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}\left[W(\mathbf{x}+\xi,\tau|\mathbf{x})W(\mathbf{x},s|\mathbf{x}_0)
\right].
\]</div>
</div>
<div class="section" id="id68">
<h2><span class="section-number">1.82. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h2>
<p>We can then rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W}{\partial s}\tau=-W(\mathbf{x},s|\mathbf{x}_0)+
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi\right].
\]</div>
<p>We have neglected higher powers of <span class="math notranslate nohighlight">\(\tau\)</span> and have used that for <span class="math notranslate nohighlight">\(n=0\)</span>
we get simply <span class="math notranslate nohighlight">\(W(\mathbf{x},s|\mathbf{x}_0)\)</span> due to normalization.</p>
</div>
<div class="section" id="id69">
<h2><span class="section-number">1.83. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h2>
<p>We say thus that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> changes only by a small amount in the time interval <span class="math notranslate nohighlight">\(\tau\)</span>.
This means that we can make a Taylor expansion in terms of <span class="math notranslate nohighlight">\(\xi\)</span>, that is we
expand</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0) =
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}\left[W(\mathbf{x}+\xi,\tau|\mathbf{x})W(\mathbf{x},s|\mathbf{x}_0)
\right].
\]</div>
</div>
<div class="section" id="id70">
<h2><span class="section-number">1.84. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h2>
<p>We can then rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}\tau=-W(\mathbf{x},s|\mathbf{x}_0)+
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi\right].
\]</div>
<p>We have neglected higher powers of <span class="math notranslate nohighlight">\(\tau\)</span> and have used that for <span class="math notranslate nohighlight">\(n=0\)</span>
we get simply <span class="math notranslate nohighlight">\(W(\mathbf{x},s|\mathbf{x}_0)\)</span> due to normalization.</p>
</div>
<div class="section" id="id71">
<h2><span class="section-number">1.85. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h2>
<p>We simplify the above by introducing the moments</p>
<div class="math notranslate nohighlight">
\[
M_n=\frac{1}{\tau}\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi=
\frac{\langle [\Delta x(\tau)]^n\rangle}{\tau},
\]</div>
<p>resulting in</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}=
\sum_{n=1}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)M_n\right].
\]</div>
</div>
<div class="section" id="id72">
<h2><span class="section-number">1.86. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h2>
<p>When <span class="math notranslate nohighlight">\(\tau \rightarrow 0\)</span> we assume that <span class="math notranslate nohighlight">\(\langle [\Delta x(\tau)]^n\rangle \rightarrow 0\)</span> more rapidly than <span class="math notranslate nohighlight">\(\tau\)</span> itself if <span class="math notranslate nohighlight">\(n &gt; 2\)</span>.
When <span class="math notranslate nohighlight">\(\tau\)</span> is much larger than the standard correlation time of
system then <span class="math notranslate nohighlight">\(M_n\)</span> for <span class="math notranslate nohighlight">\(n &gt; 2\)</span> can normally be neglected.
This means that fluctuations become negligible at large time scales.</p>
<p>If we neglect such terms we can rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}=
-\frac{\partial M_1W(\mathbf{x},s|\mathbf{x}_0)}{\partial x}+
\frac{1}{2}\frac{\partial^2 M_2W(\mathbf{x},s|\mathbf{x}_0)}{\partial x^2}.
\]</div>
</div>
<div class="section" id="id73">
<h2><span class="section-number">1.87. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h2>
<p>In a more compact form we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W}{\partial s}=
-\frac{\partial M_1W}{\partial x}+
\frac{1}{2}\frac{\partial^2 M_2W}{\partial x^2},
\]</div>
<p>which is the Fokker-Planck equation!  It is trivial to replace
position with velocity (momentum).</p>
</div>
<div class="section" id="id74">
<h2><span class="section-number">1.88. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>Consider a particle  suspended in a liquid. On its path through the liquid it will continuously collide with the liquid molecules. Because on average the particle  will collide more often on the front side than on the back side, it will experience a systematic force proportional with its velocity, and directed opposite to its velocity. Besides this systematic force the particle  will experience a stochastic force  <span class="math notranslate nohighlight">\(\mathbf{F}(t)\)</span>.
The equations of motion are</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\frac{d\mathbf{r}}{dt}=\mathbf{v}\)</span> and</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{d\mathbf{v}}{dt}=-\xi \mathbf{v}+\mathbf{F}\)</span>.</p></li>
</ul>
</div>
<div class="section" id="id75">
<h2><span class="section-number">1.89. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>From hydrodynamics  we know that the friction constant  <span class="math notranslate nohighlight">\(\xi\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\xi =6\pi \eta a/m
\]</div>
<p>where <span class="math notranslate nohighlight">\(\eta\)</span> is the viscosity  of the solvent and a is the radius of the particle .</p>
<p>Solving the second equation in the previous slide we get</p>
<div class="math notranslate nohighlight">
\[
\mathbf{v}(t)=\mathbf{v}_{0}e^{-\xi t}+\int_{0}^{t}d\tau e^{-\xi (t-\tau )}\mathbf{F }(\tau ).
\]</div>
</div>
<div class="section" id="id76">
<h2><span class="section-number">1.90. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>If we want to get some useful information out of this, we have to average over all possible realizations of
<span class="math notranslate nohighlight">\(\mathbf{F}(t)\)</span>, with the initial velocity as a condition. A useful quantity for example is</p>
<p>1
2
3</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
+\int_{0}^{t}d\tau ^{\prime }\int_{0}^{t}d\tau e^{-\xi (2t-\tau -\tau ^{\prime })}
\langle \mathbf{F}(\tau )\cdot \mathbf{F}(\tau ^{\prime })\rangle_{ \mathbf{v}_{0}}.
\]</div>
</div>
<div class="section" id="id77">
<h2><span class="section-number">1.91. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>In order to continue we have to make some assumptions about the conditional averages of the stochastic forces.
In view of the chaotic character of the stochastic forces the following
assumptions seem to be appropriate</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\rangle=0,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\cdot \mathbf{F}(t^{\prime })\rangle_{\mathbf{v}_{0}}=  C_{\mathbf{v}_{0}}\delta (t-t^{\prime }).
\]</div>
<p>We omit the subscript <span class="math notranslate nohighlight">\(\mathbf{v}_{0}\)</span>, when the quantity of interest turns out to be independent of <span class="math notranslate nohighlight">\(\mathbf{v}_{0}\)</span>. Using the last three equations we get</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{v}(t)\cdot \mathbf{v}(t)\rangle_{\mathbf{v}_{0}}=v_{0}^{2}e^{-2\xi t}+\frac{C_{\mathbf{v}_{0}}}{2\xi }(1-e^{-2\xi t}).
\]</div>
<p>For large t this should be equal to 3kT/m, from which it follows that</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\cdot \mathbf{F}(t^{\prime })\rangle =6\frac{kT}{m}\xi \delta (t-t^{\prime }).
\]</div>
<p>This result is called the fluctuation-dissipation theorem .</p>
</div>
<div class="section" id="id78">
<h2><span class="section-number">1.92. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>Integrating</p>
<div class="math notranslate nohighlight">
\[
\mathbf{v}(t)=\mathbf{v}_{0}e^{-\xi t}+\int_{0}^{t}d\tau e^{-\xi (t-\tau )}\mathbf{F }(\tau ),
\]</div>
<p>we get</p>
<div class="math notranslate nohighlight">
\[
\mathbf{r}(t)=\mathbf{r}_{0}+\mathbf{v}_{0}\frac{1}{\xi }(1-e^{-\xi t})+
\int_0^td\tau \int_0^{\tau}\tau ^{\prime } e^{-\xi (\tau -\tau ^{\prime })}\mathbf{F}(\tau ^{\prime }),
\]</div>
<p>from which we calculate the mean square displacement</p>
<div class="math notranslate nohighlight">
\[
\langle ( \mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle _{\mathbf{v}_{0}}=\frac{v_0^2}{\xi}(1-e^{-\xi t})^{2}+\frac{3kT}{m\xi ^{2}}(2\xi t-3+4e^{-\xi t}-e^{-2\xi t}).
\]</div>
</div>
<div class="section" id="id79">
<h2><span class="section-number">1.93. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#id79" title="Permalink to this headline">¶</a></h2>
<p><strong>Langevin equation.</strong></p>
<p>For very large <span class="math notranslate nohighlight">\(t\)</span> this becomes</p>
<div class="math notranslate nohighlight">
\[
\langle (\mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle =\frac{6kT}{m\xi }t
\]</div>
<p>from which we get the Einstein relation</p>
<div class="math notranslate nohighlight">
\[
D= \frac{kT}{m\xi }
\]</div>
<p>where we have used <span class="math notranslate nohighlight">\(\langle (\mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle =6Dt\)</span>.</p>
</div>
<div class="section" id="code-example-for-two-electrons-in-a-quantum-dots">
<h2><span class="section-number">1.94. </span>Code example for two electrons in a quantum dots<a class="headerlink" href="#code-example-for-two-electrons-in-a-quantum-dots" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span class="c1"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span class="c1"># No energy minimization</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">normalvariate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span><span class="n">njit</span>


<span class="c1">#Read name of output file from command line</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">outfilename</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Error: Name of output file must be given as command line argument.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

<span class="c1"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="n">r12</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span><span class="o">+</span><span class="n">deno</span><span class="p">)</span>

<span class="c1"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">deno2</span> <span class="o">=</span> <span class="n">deno</span><span class="o">*</span><span class="n">deno</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="o">+</span><span class="n">deno2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">r12</span><span class="o">-</span><span class="n">deno2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">deno</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="p">)</span>

<span class="c1"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span class="k">def</span> <span class="nf">QuantumForce</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>

    <span class="n">qforce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span><span class="o">*</span><span class="n">deno</span><span class="o">*</span><span class="n">deno</span><span class="o">/</span><span class="n">r12</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span><span class="o">*</span><span class="n">deno</span><span class="o">*</span><span class="n">deno</span><span class="o">/</span><span class="n">r12</span>
    <span class="k">return</span> <span class="n">qforce</span>
    
<span class="c1"># The Monte Carlo sampling with the Metropolis algo</span>
<span class="c1"># jit decorator tells Numba to compile this function.</span>
<span class="c1"># The argument types will be inferred by Numba when function is called.</span>
<span class="nd">@jit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">MonteCarloSampling</span><span class="p">():</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">100000</span>
    <span class="c1"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TimeStep</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># Quantum force</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="c1"># seed for rng generator </span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="c1"># start variational parameter  loops, two parameters here</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">025</span>
        <span class="n">AlphaValues</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span> 
        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">01</span>
            <span class="n">BetaValues</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1">#Initial position</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span>
            <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

            <span class="c1">#Loop over MC MCcycles</span>
            <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
                <span class="c1">#Trial position moving one particle at the time</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span><span class="o">+</span>\
                                           <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="n">D</span>
                    <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                    <span class="n">GreensFunction</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">GreensFunction</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span>\
	                              <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">-</span>\
                                      <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
      
                    <span class="n">GreensFunction</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">GreensFunction</span><span class="p">)</span>
                    <span class="n">ProbabilityRatio</span> <span class="o">=</span> <span class="n">GreensFunction</span><span class="o">*</span><span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">wfold</span><span class="o">**</span><span class="mi">2</span>
                    <span class="c1">#Metropolis-Hastings test to see whether we accept the move</span>
                    <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ProbabilityRatio</span><span class="p">:</span>
                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                           <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                           <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                       <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
                <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
                <span class="n">energy2</span> <span class="o">+=</span> <span class="n">DeltaE</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1"># We calculate mean, variance and error (no blocking applied)</span>
            <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">energy2</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">-</span> <span class="n">energy</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="o">/</span><span class="n">NumberMCcycles</span><span class="p">)</span>
            <span class="n">Energies</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>    
            <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">energy</span><span class="p">,</span><span class="n">variance</span><span class="p">,</span><span class="n">error</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">MaxVariations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MaxVariations</span><span class="p">,</span><span class="n">MaxVariations</span><span class="p">))</span>
<span class="n">AlphaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="n">BetaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="p">(</span><span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span> <span class="o">=</span> <span class="n">MonteCarloSampling</span><span class="p">()</span>
<span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># Prepare for plots</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="c1"># Plot the surface.</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Energies</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Customize the z axis.</span>
<span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\alpha$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\beta$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle E \rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">LinearLocator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.02f</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="c1"># Add a color bar which maps values to colors.</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="bringing-the-gradient-optmization">
<h2><span class="section-number">1.95. </span>Bringing the gradient optmization<a class="headerlink" href="#bringing-the-gradient-optmization" title="Permalink to this headline">¶</a></h2>
<p>The simple one-particle case in a harmonic oscillator trap</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Gradient descent stepping with analytical derivative</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="k">def</span> <span class="nf">DerivativeE</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">def</span> <span class="nf">Energy</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Niterations</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Niterations</span><span class="p">):</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">DerivativeE</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">-=</span> <span class="n">eta</span><span class="o">*</span><span class="n">gradients</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="and-then-for-the-non-interacting-two-particle-case">
<h2><span class="section-number">1.96. </span>And then for the non-interacting two-particle case<a class="headerlink" href="#and-then-for-the-non-interacting-two-particle-case" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span class="c1"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">normalvariate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>


<span class="c1"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">))</span>

<span class="c1"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span>

<span class="c1"># Derivate of wave function ansatz as function of variational parameters</span>
<span class="k">def</span> <span class="nf">DerivativeWFansatz</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">WfDer</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">WfDer</span>

<span class="c1"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span class="k">def</span> <span class="nf">QuantumForce</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>

    <span class="n">qforce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span>
    <span class="k">return</span> <span class="n">qforce</span>
    
<span class="c1"># Computing the derivative of the energy and the energy </span>
<span class="c1"># jit decorator tells Numba to compile this function.</span>
<span class="c1"># The argument types will be inferred by Numba when function is called.</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">EnergyMinimization</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">1000</span>
    <span class="c1"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TimeStep</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># Quantum force</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="c1"># seed for rng generator </span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">EnergyDer</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DeltaPsi</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DerivativePsiE</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1">#Initial position</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
            <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span>
    <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>

    <span class="c1">#Loop over MC MCcycles</span>
    <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
        <span class="c1">#Trial position moving one particle at the time</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span><span class="o">+</span>\
                                       <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="n">D</span>
            <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">GreensFunction</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                <span class="n">GreensFunction</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span>\
	                              <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">-</span>\
                                      <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
      
            <span class="n">GreensFunction</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">GreensFunction</span><span class="p">)</span>
            <span class="n">ProbabilityRatio</span> <span class="o">=</span> <span class="n">GreensFunction</span><span class="o">*</span><span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">wfold</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#Metropolis-Hastings test to see whether we accept the move</span>
            <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ProbabilityRatio</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
        <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">DeltaPsi</span> <span class="o">=</span> <span class="n">DerivativeWFansatz</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
        <span class="n">DerivativePsiE</span> <span class="o">+=</span> <span class="n">DeltaPsi</span><span class="o">*</span><span class="n">DeltaE</span>
            
    <span class="c1"># We calculate mean, variance and error (no blocking applied)</span>
    <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">DerivativePsiE</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">DeltaPsi</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">EnergyDer</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">DerivativePsiE</span><span class="o">-</span><span class="n">DeltaPsi</span><span class="o">*</span><span class="n">energy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">energy</span><span class="p">,</span> <span class="n">EnergyDer</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># guess for variational parameters</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="c1"># Set up iteration using stochastic gradient method</span>
<span class="n">Energy</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="n">EnergyMinimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span><span class="p">)</span>

<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">Niterations</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Niterations</span><span class="p">):</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">EnergyDer</span>
    <span class="n">x0</span> <span class="o">-=</span> <span class="n">eta</span><span class="o">*</span><span class="n">gradients</span>
    <span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="n">EnergyMinimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="project-2-vmc-for-fermions-efficient-calculation-of-slater-determinants">
<h2><span class="section-number">1.97. </span>Project 2, VMC for fermions: Efficient calculation of Slater determinants<a class="headerlink" href="#project-2-vmc-for-fermions-efficient-calculation-of-slater-determinants" title="Permalink to this headline">¶</a></h2>
<p>The potentially most time-consuming part is the
evaluation of the gradient and the Laplacian of an <span class="math notranslate nohighlight">\(N\)</span>-particle  Slater
determinant.</p>
<p>We have to differentiate the determinant with respect to
all spatial coordinates of all particles. A brute force
differentiation would involve <span class="math notranslate nohighlight">\(N\cdot d\)</span> evaluations of the entire
determinant which would even worsen the already undesirable time
scaling, making it <span class="math notranslate nohighlight">\(Nd\cdot O(N^3)\sim O(d\cdot N^4)\)</span>.</p>
<p>This poses serious hindrances to the overall efficiency of our code.</p>
</div>
<div class="section" id="matrix-elements-of-slater-determinants">
<h2><span class="section-number">1.98. </span>Matrix elements of Slater determinants<a class="headerlink" href="#matrix-elements-of-slater-determinants" title="Permalink to this headline">¶</a></h2>
<p>The efficiency can be improved however if we move only one electron at the time.
The Slater determinant matrix <span class="math notranslate nohighlight">\(\hat{D}\)</span> is defined by the matrix elements</p>
<div class="math notranslate nohighlight">
\[
d_{ij}=\phi_j(x_i)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_j(\mathbf{r}_i)\)</span> is a single particle  wave function.
The columns correspond to the position of a given particle
while the rows stand for the various quantum numbers.</p>
</div>
<div class="section" id="efficient-calculation-of-slater-determinants">
<h2><span class="section-number">1.99. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#efficient-calculation-of-slater-determinants" title="Permalink to this headline">¶</a></h2>
<p>What we need to realize is that when differentiating a Slater
determinant with respect to some given coordinate, only one row of the
corresponding Slater matrix is changed.</p>
<p>Therefore, by recalculating
the whole determinant we risk producing redundant information. The
solution turns out to be an algorithm that requires to keep track of
the <em>inverse</em> of the Slater matrix.</p>
</div>
<div class="section" id="id80">
<h2><span class="section-number">1.100. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h2>
<p>Let the current position in phase space be represented by the <span class="math notranslate nohighlight">\((N\cdot d)\)</span>-element
vector <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{old}}\)</span> and the new suggested
position by the vector <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span>.</p>
<p>The inverse of <span class="math notranslate nohighlight">\(\hat{D}\)</span> can be expressed in terms of its
cofactors <span class="math notranslate nohighlight">\(C_{ij}\)</span> and its determinant (this our notation for a determinant) <span class="math notranslate nohighlight">\(\vert\hat{D}\vert\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_cofactor"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
d_{ij}^{-1} = \frac{C_{ji}}{\vert\hat{D}\vert}
\label{eq:inverse_cofactor} \tag{12}
\end{equation}
\]</div>
<p>Notice that the interchanged indices indicate that the matrix of cofactors is to be transposed.</p>
</div>
<div class="section" id="id81">
<h2><span class="section-number">1.101. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math notranslate nohighlight">\(\hat{D}\)</span> is invertible, then we must obviously have <span class="math notranslate nohighlight">\(\hat{D}^{-1}\hat{D}= \mathbf{1}\)</span>, or explicitly in terms of the individual
elements of <span class="math notranslate nohighlight">\(\hat{D}\)</span> and <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:unity_explicitely"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{k=1}^N d_{ik}^{\phantom X}d_{kj}^{-1} = \delta_{ij}^{\phantom X}
\label{eq:unity_explicitely} \tag{13}
\end{equation}
\]</div>
</div>
<div class="section" id="id82">
<h2><span class="section-number">1.102. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h2>
<p>Consider the ratio, which we shall call <span class="math notranslate nohighlight">\(R\)</span>, between <span class="math notranslate nohighlight">\(\vert\hat{D}(\mathbf{r}^{\mathrm{new}})\vert\)</span> and <span class="math notranslate nohighlight">\(\vert\hat{D}(\mathbf{r}^{\mathrm{old}})\vert\)</span>.
By definition, each of these determinants can
individually be expressed in terms of the <em>i</em>-th row of its cofactor
matrix</p>
<!-- Equation labels as ordinary links -->
<div id="eq:detratio_cofactors"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R\equiv\frac{\vert\hat{D}(\mathbf{r}^{\mathrm{new}})\vert}
{\vert\hat{D}(\mathbf{r}^{\mathrm{old}})\vert} =
\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
C_{ij}(\mathbf{r}^{\mathrm{new}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})}
\label{eq:detratio_cofactors} \tag{14}
\end{equation}
\]</div>
</div>
<div class="section" id="id83">
<h2><span class="section-number">1.103. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h2>
<p>Suppose now that we move only one particle  at a time, meaning that
<span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span> differs from <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{old}}\)</span> by the
position of only one, say the <em>i</em>-th, particle . This means that <span class="math notranslate nohighlight">\(\hat{D}(\mathbf{r}^{\mathrm{new}})\)</span> and <span class="math notranslate nohighlight">\(\hat{D}(\mathbf{r}^{\mathrm{old}})\)</span> differ
only by the entries of the <em>i</em>-th row.  Recall also that the <em>i</em>-th row
of a cofactor matrix <span class="math notranslate nohighlight">\(\hat{C}\)</span> is independent of the entries of the
<em>i</em>-th row of its corresponding matrix <span class="math notranslate nohighlight">\(\hat{D}\)</span>. In this particular
case we therefore get that the <em>i</em>-th row of <span class="math notranslate nohighlight">\(\hat{C}(\mathbf{r}^{\mathrm{new}})\)</span>
and <span class="math notranslate nohighlight">\(\hat{C}(\mathbf{r}^{\mathrm{old}})\)</span> must be
equal. Explicitly, we have:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
C_{ij}(\mathbf{r}^{\mathrm{new}}) = C_{ij}(\mathbf{r}^{\mathrm{old}})\quad
\forall\ j\in\{1,\dots,N\}
\label{_auto5} \tag{15}
\end{equation}
\]</div>
</div>
<div class="section" id="id84">
<h2><span class="section-number">1.104. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h2>
<p>Inserting this into the numerator of eq. (<a class="reference external" href="#eq:detratio_cofactors">14</a>)
and using eq. (<a class="reference external" href="#eq:inverse_cofactor">12</a>) to substitute the cofactors
with the elements of the inverse matrix, we get:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R =\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})} =
\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})}
\label{_auto6} \tag{16}
\end{equation}
\]</div>
</div>
<div class="section" id="id85">
<h2><span class="section-number">1.105. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h2>
<p>Now by eq. (<a class="reference external" href="#eq:unity_explicitely">13</a>) the denominator of the rightmost
expression must be unity, so that we finally arrive at:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:detratio_inverse"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R =
\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}}) = 
\sum_{j=1}^N \phi_j(\mathbf{r}_i^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})
\label{eq:detratio_inverse} \tag{17}
\end{equation}
\]</div>
<p>What this means is that in order to get the ratio when only the <em>i</em>-th
particle  has been moved, we only need to calculate the dot
product of the vector <span class="math notranslate nohighlight">\(\left(\phi_1(\mathbf{r}_i^\mathrm{new}),\,\dots,\,\phi_N(\mathbf{r}_i^\mathrm{new})\right)\)</span> of single particle  wave functions
evaluated at this new position with the <em>i</em>-th column of the inverse
matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> evaluated at the original position. Such
an operation has a time scaling of <span class="math notranslate nohighlight">\(O(N)\)</span>. The only extra thing we
need to do is to maintain the inverse matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{x}^{\mathrm{old}})\)</span>.</p>
</div>
<div class="section" id="id86">
<h2><span class="section-number">1.106. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id86" title="Permalink to this headline">¶</a></h2>
<p>If the new position <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span> is accepted, then the
inverse matrix can by suitably updated by an algorithm having a time
scaling of <span class="math notranslate nohighlight">\(O(N^2)\)</span>.  This algorithm goes as
follows. First we update all but the <em>i</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span>. For each column <span class="math notranslate nohighlight">\(j\neq i\)</span>, we first calculate the quantity:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
S_j =
(\hat{D}(\mathbf{r}^{\mathrm{new}})\times
\hat{D}^{-1}(\mathbf{r}^{\mathrm{old}}))_{ij} =
\sum_{l=1}^N d_{il}(\mathbf{r}^{\mathrm{new}})\,
d^{-1}_{lj}(\mathbf{r}^{\mathrm{old}})
\label{eq:inverse_update_1} \tag{18}
\end{equation}
\]</div>
</div>
<div class="section" id="id87">
<h2><span class="section-number">1.107. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h2>
<p>The new elements of the <em>j</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> are then given
by:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_2"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
d_{kj}^{-1}(\mathbf{r}^{\mathrm{new}}) =
d_{kj}^{-1}(\mathbf{r}^{\mathrm{old}}) -
\frac{S_j}{R}\,d_{ki}^{-1}(\mathbf{r}^{\mathrm{old}})\quad
\begin{array}{ll}
\forall\ \ k\in\{1,\dots,N\}\\j\neq i
\end{array}
\label{eq:inverse_update_2} \tag{19}
\end{equation}
\end{split}\]</div>
</div>
<div class="section" id="id88">
<h2><span class="section-number">1.108. </span>Efficient calculation of Slater determinants<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h2>
<p>Finally the elements of the <em>i</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> are updated
simply as follows:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
d_{ki}^{-1}(\mathbf{r}^{\mathrm{new}}) =
\frac{1}{R}\,d_{ki}^{-1}(\mathbf{r}^{\mathrm{old}})\quad
\forall\ \ k\in\{1,\dots,N\}
\label{eq:inverse_update_3} \tag{20}
\end{equation}
\]</div>
<p>We see from these formulas that the time scaling of an update of
<span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> after changing one row of <span class="math notranslate nohighlight">\(\hat{D}\)</span> is <span class="math notranslate nohighlight">\(O(N^2)\)</span>.</p>
<p>The scheme is also applicable for the calculation of the ratios
involving derivatives. It turns
out that differentiating the Slater determinant with respect
to the coordinates of a single particle  <span class="math notranslate nohighlight">\(\mathbf{r}_i\)</span> changes only the
<em>i</em>-th row of the corresponding Slater matrix.</p>
</div>
<div class="section" id="the-gradient-and-the-laplacian">
<h2><span class="section-number">1.109. </span>The gradient and the Laplacian<a class="headerlink" href="#the-gradient-and-the-laplacian" title="Permalink to this headline">¶</a></h2>
<p>The gradient and the Laplacian can therefore be calculated as follows:</p>
<div class="math notranslate nohighlight">
\[
\frac{\vec\nabla_i\vert\hat{D}(\mathbf{r})\vert}{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \vec\nabla_i d_{ij}(\mathbf{r})d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \vec\nabla_i \phi_j(\mathbf{r}_i)d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_i\vert\hat{D}(\mathbf{r})\vert}{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \nabla^2_i d_{ij}(\mathbf{r})d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \nabla^2_i \phi_j(\mathbf{r}_i)\,d_{ji}^{-1}(\mathbf{r})
\]</div>
</div>
<div class="section" id="how-to-compute-the-derivates-of-the-slater-determinant">
<h2><span class="section-number">1.110. </span>How to compute the derivates of the Slater determinant<a class="headerlink" href="#how-to-compute-the-derivates-of-the-slater-determinant" title="Permalink to this headline">¶</a></h2>
<p>Thus, to calculate all the derivatives of the Slater determinant, we
only need the derivatives of the single particle  wave functions
(<span class="math notranslate nohighlight">\(\vec\nabla_i \phi_j(\mathbf{r}_i)\)</span> and <span class="math notranslate nohighlight">\(\nabla^2_i \phi_j(\mathbf{r}_i)\)</span>)
and the elements of the corresponding inverse Slater matrix (<span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{r}_i)\)</span>). A calculation of a single derivative is by the
above result an <span class="math notranslate nohighlight">\(O(N)\)</span> operation. Since there are <span class="math notranslate nohighlight">\(d\cdot N\)</span>
derivatives, the time scaling of the total evaluation becomes
<span class="math notranslate nohighlight">\(O(d\cdot N^2)\)</span>. With an <span class="math notranslate nohighlight">\(O(N^2)\)</span> updating algorithm for the
inverse matrix, the total scaling is no worse, which is far better
than the brute force approach yielding <span class="math notranslate nohighlight">\(O(d\cdot N^4)\)</span>.</p>
<p><strong>Important note</strong>: In most cases you end with closed form expressions for the single-particle  wave functions. It is then useful to calculate the various derivatives and make separate functions
for them.</p>
</div>
<div class="section" id="the-slater-determinant">
<h2><span class="section-number">1.111. </span>The Slater determinant<a class="headerlink" href="#the-slater-determinant" title="Permalink to this headline">¶</a></h2>
<p>The Slater determinant takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Phi(\mathbf{r}_1,\mathbf{r}_2,,\mathbf{r}_3,\mathbf{r}_4, \alpha,\beta,\gamma,\delta)=\frac{1}{\sqrt{4!}}
\left| \begin{array}{cccc} \psi_{100\uparrow}(\mathbf{r}_1)&amp; \psi_{100\uparrow}(\mathbf{r}_2)&amp; \psi_{100\uparrow}(\mathbf{r}_3)&amp;\psi_{100\uparrow}(\mathbf{r}_4) \\
\psi_{100\downarrow}(\mathbf{r}_1)&amp; \psi_{100\downarrow}(\mathbf{r}_2)&amp; \psi_{100\downarrow}(\mathbf{r}_3)&amp;\psi_{100\downarrow}(\mathbf{r}_4) \\
\psi_{200\uparrow}(\mathbf{r}_1)&amp; \psi_{200\uparrow}(\mathbf{r}_2)&amp; \psi_{200\uparrow}(\mathbf{r}_3)&amp;\psi_{200\uparrow}(\mathbf{r}_4) \\
\psi_{200\downarrow}(\mathbf{r}_1)&amp; \psi_{200\downarrow}(\mathbf{r}_2)&amp; \psi_{200\downarrow}(\mathbf{r}_3)&amp;\psi_{200\downarrow}(\mathbf{r}_4) \end{array} \right|.
\end{split}\]</div>
<p>The Slater determinant as written is zero since the spatial wave functions for the spin up and spin down
states are equal.<br />
But we can rewrite it as the product of two Slater determinants, one for spin up and one for spin down.</p>
</div>
<div class="section" id="rewriting-the-slater-determinant">
<h2><span class="section-number">1.112. </span>Rewriting the Slater determinant<a class="headerlink" href="#rewriting-the-slater-determinant" title="Permalink to this headline">¶</a></h2>
<p>We can rewrite it as</p>
<p>1
4
7</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<p>1
4
8</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
+\det\uparrow(3,4)\det\downarrow(1,2),
\]</div>
<p>where we have defined</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\det\uparrow(1,2)=\frac{1}{\sqrt{2}}\left| \begin{array}{cc} \psi_{100\uparrow}(\mathbf{r}_1)&amp; \psi_{100\uparrow}(\mathbf{r}_2)\\
\psi_{200\uparrow}(\mathbf{r}_1)&amp; \psi_{200\uparrow}(\mathbf{r}_2) \end{array} \right|,
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\det\downarrow(3,4)=\frac{1}{\sqrt{2}}\left| \begin{array}{cc} \psi_{100\downarrow}(\mathbf{r}_3)&amp; \psi_{100\downarrow}(\mathbf{r}_4)\\
\psi_{200\downarrow}(\mathbf{r}_3)&amp; \psi_{200\downarrow}(\mathbf{r}_4) \end{array} \right|.
\end{split}\]</div>
<p>The total determinant is still zero!</p>
</div>
<div class="section" id="splitting-the-slater-determinant">
<h2><span class="section-number">1.113. </span>Splitting the Slater determinant<a class="headerlink" href="#splitting-the-slater-determinant" title="Permalink to this headline">¶</a></h2>
<p>We want to avoid to sum over spin variables, in particular when the interaction does not depend on spin.</p>
<p>It can be shown, see for example Moskowitz and Kalos, <a class="reference external" href="http://onlinelibrary.wiley.com/doi/10.1002/qua.560200508/abstract">Int. J. Quantum Chem. <strong>20</strong> 1107 (1981)</a>, that for the variational energy
we can approximate the Slater determinant as</p>
<div class="math notranslate nohighlight">
\[
\Phi(\mathbf{r}_1,\mathbf{r}_2,,\mathbf{r}_3,\mathbf{r}_4, \alpha,\beta,\gamma,\delta) \propto \det\uparrow(1,2)\det\downarrow(3,4),
\]</div>
<p>or more generally as</p>
<div class="math notranslate nohighlight">
\[
\Phi(\mathbf{r}_1,\mathbf{r}_2,\dots \mathbf{r}_N) \propto \det\uparrow \det\downarrow,
\]</div>
<p>where we have the Slater determinant as the product of a spin up part involving the number of electrons with spin up only (2 for beryllium and 5 for neon) and a spin down part involving the electrons with spin down.</p>
<p>This ansatz is not antisymmetric under the exchange of electrons with  opposite spins but it can be shown (show this) that it gives the same
expectation value for the energy as the full Slater determinant.</p>
<p>As long as the Hamiltonian is spin independent, the above is correct. It is rather straightforward to see this if you go back to the equations for the energy discussed earlier  this semester.</p>
</div>
<div class="section" id="spin-up-and-spin-down-parts">
<h2><span class="section-number">1.114. </span>Spin up and spin down parts<a class="headerlink" href="#spin-up-and-spin-down-parts" title="Permalink to this headline">¶</a></h2>
<p>We will thus
factorize the full determinant <span class="math notranslate nohighlight">\(\vert\hat{D}\vert\)</span> into two smaller ones, where
each can be identified with <span class="math notranslate nohighlight">\(\uparrow\)</span> and <span class="math notranslate nohighlight">\(\downarrow\)</span>
respectively:</p>
<div class="math notranslate nohighlight">
\[
\vert\hat{D}\vert = \vert\hat{D}\vert_\uparrow\cdot \vert\hat{D}\vert_\downarrow
\]</div>
</div>
<div class="section" id="factorization">
<h2><span class="section-number">1.115. </span>Factorization<a class="headerlink" href="#factorization" title="Permalink to this headline">¶</a></h2>
<p>The combined dimensionality of the two smaller determinants equals the
dimensionality of the full determinant. Such a factorization is
advantageous in that it makes it possible to perform the calculation
of the ratio <span class="math notranslate nohighlight">\(R\)</span> and the updating of the inverse matrix separately for
<span class="math notranslate nohighlight">\(\vert\hat{D}\vert_\uparrow\)</span> and <span class="math notranslate nohighlight">\(\vert\hat{D}\vert_\downarrow\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\vert\hat{D}\vert^\mathrm{new}}{\vert\hat{D}\vert^\mathrm{old}} =
\frac{\vert\hat{D}\vert^\mathrm{new}_\uparrow}
{\vert\hat{D}\vert^\mathrm{old}_\uparrow}\cdot
\frac{\vert\hat{D}\vert^\mathrm{new}_\downarrow
}{\vert\hat{D}\vert^\mathrm{old}_\downarrow}
\]</div>
<p>This reduces the calculation time by a constant factor. The maximal
time reduction happens in a system of equal numbers of <span class="math notranslate nohighlight">\(\uparrow\)</span> and
<span class="math notranslate nohighlight">\(\downarrow\)</span> particles, so that the two factorized determinants are
half the size of the original one.</p>
</div>
<div class="section" id="number-of-operations">
<h2><span class="section-number">1.116. </span>Number of operations<a class="headerlink" href="#number-of-operations" title="Permalink to this headline">¶</a></h2>
<p>Consider the case of moving only one particle  at a time which
originally had the following time scaling for one transition:</p>
<div class="math notranslate nohighlight">
\[
O_R(N)+O_\mathrm{inverse}(N^2)
\]</div>
<p>For the factorized determinants one of the two determinants is
obviously unaffected by the change so that it cancels from the ratio
<span class="math notranslate nohighlight">\(R\)</span>.</p>
</div>
<div class="section" id="counting-the-number-of-flops">
<h2><span class="section-number">1.117. </span>Counting the number of FLOPS<a class="headerlink" href="#counting-the-number-of-flops" title="Permalink to this headline">¶</a></h2>
<p>Therefore, only one determinant of size <span class="math notranslate nohighlight">\(N/2\)</span> is involved in each
calculation of <span class="math notranslate nohighlight">\(R\)</span> and update of the inverse matrix. The scaling of
each transition then becomes:</p>
<div class="math notranslate nohighlight">
\[
O_R(N/2)+O_\mathrm{inverse}(N^2/4)
\]</div>
<p>and the time scaling when the transitions for all <span class="math notranslate nohighlight">\(N\)</span> particles are
put together:</p>
<div class="math notranslate nohighlight">
\[
O_R(N^2/2)+O_\mathrm{inverse}(N^3/4)
\]</div>
<p>which gives the same reduction as in the case of moving all particles
at once.</p>
</div>
<div class="section" id="computation-of-ratios">
<h2><span class="section-number">1.118. </span>Computation of ratios<a class="headerlink" href="#computation-of-ratios" title="Permalink to this headline">¶</a></h2>
<p>Computing the ratios discussed above requires that we maintain
the inverse of the Slater matrix evaluated at the current position.
Each time a trial position is accepted, the row number <span class="math notranslate nohighlight">\(i\)</span> of the Slater
matrix changes and updating its inverse has to be carried out.
Getting the inverse of an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix by Gaussian elimination has a
complexity of order of <span class="math notranslate nohighlight">\(\mathcal{O}(N^3)\)</span> operations, a luxury that we
cannot afford for each time a particle  move is accepted.
We will use the expression</p>
<!-- Equation labels as ordinary links -->
<div id="updatingInverse"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\label{updatingInverse} \tag{21}
d^{-1}_{kj}(\mathbf{x^{new}}) = \left\{\begin{array}{l l}
  d^{-1}_{kj}(\mathbf{x^{old}}) - \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{new}})  d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j \neq i$}\nonumber \\ \\
 \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{old}}) d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j=i$}
\end{array} \right.
\end{split}\]</div>
</div>
<div class="section" id="scaling-properties">
<h2><span class="section-number">1.119. </span>Scaling properties<a class="headerlink" href="#scaling-properties" title="Permalink to this headline">¶</a></h2>
<p>This equation scales as <span class="math notranslate nohighlight">\(O(N^2)\)</span>.
The evaluation of the determinant of an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix by standard Gaussian elimination
requires <span class="math notranslate nohighlight">\(\mathbf{O}(N^3)\)</span>
calculations.
As there are <span class="math notranslate nohighlight">\(Nd\)</span> independent coordinates we need to evaluate <span class="math notranslate nohighlight">\(Nd\)</span> Slater determinants
for the gradient (quantum force) and <span class="math notranslate nohighlight">\(Nd\)</span> for the Laplacian (kinetic energy).
With the updating algorithm we need only to invert the Slater
determinant matrix once. This can be done by standard LU decomposition methods.</p>
</div>
<div class="section" id="how-to-get-the-determinant">
<h2><span class="section-number">1.120. </span>How to get the determinant<a class="headerlink" href="#how-to-get-the-determinant" title="Permalink to this headline">¶</a></h2>
<p>Determining a determinant of an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix by
standard Gaussian elimination is of the order of <span class="math notranslate nohighlight">\(\mathbf{O}(N^3)\)</span>
calculations. As there are <span class="math notranslate nohighlight">\(N\cdot d\)</span> independent coordinates we need
to evaluate <span class="math notranslate nohighlight">\(Nd\)</span> Slater determinants for the gradient (quantum force) and
<span class="math notranslate nohighlight">\(N\cdot d\)</span> for the Laplacian (kinetic energy)</p>
<p>With the updating algorithm we need only to invert the Slater determinant matrix once.
This is done by calling standard LU decomposition methods.</p>
<p>If you choose to implement the above recipe for the computation of the Slater determinant,
you need to LU decompose the Slater matrix. This is described in chapter 6 of the lecture notes
from FYS3150.</p>
<p>You need to call the function ludcmp in lib.cpp.
You need to transfer the Slater matrix and its dimension. You get back an LU decomposed matrix.</p>
</div>
<div class="section" id="lu-decomposition-and-determinant">
<h2><span class="section-number">1.121. </span>LU decomposition and determinant<a class="headerlink" href="#lu-decomposition-and-determinant" title="Permalink to this headline">¶</a></h2>
<p>The LU decomposition method means that we can rewrite
this matrix as the product of two matrices <span class="math notranslate nohighlight">\(\hat{B}\)</span> and <span class="math notranslate nohighlight">\(\hat{C}\)</span>
where</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left(\begin{array}{cccc}
                          a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
                          a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
                          a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
                          a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} 
                      \end{array} \right)
                      = \left( \begin{array}{cccc}
                              1  &amp; 0      &amp; 0      &amp; 0 \\
                          b_{21} &amp; 1      &amp; 0      &amp; 0 \\
                          b_{31} &amp; b_{32} &amp; 1      &amp; 0 \\
                          b_{41} &amp; b_{42} &amp; b_{43} &amp; 1 
                      \end{array} \right) 
                        \left( \begin{array}{cccc}
                          c_{11} &amp; c_{12} &amp; c_{13} &amp; c_{14} \\
                               0 &amp; c_{22} &amp; c_{23} &amp; c_{24} \\
                               0 &amp; 0      &amp; c_{33} &amp; c_{34} \\
                               0 &amp; 0      &amp;  0     &amp; c_{44} 
             \end{array} \right).
\end{split}\]</div>
</div>
<div class="section" id="determinant-of-a-matrix">
<h2><span class="section-number">1.122. </span>Determinant of a matrix<a class="headerlink" href="#determinant-of-a-matrix" title="Permalink to this headline">¶</a></h2>
<p>The matrix <span class="math notranslate nohighlight">\(\hat{A}\in \mathbb{R}^{n\times n}\)</span> has an LU factorization if the determinant
is different from zero. If the LU factorization exists and <span class="math notranslate nohighlight">\(\hat{A}\)</span> is non-singular, then the LU factorization
is unique and the determinant is given by</p>
<div class="math notranslate nohighlight">
\[
\vert\hat{A}\vert
  = c_{11}c_{22}\dots c_{nn}.
\]</div>
</div>
<div class="section" id="expectation-value-of-the-kinetic-energy">
<h2><span class="section-number">1.123. </span>Expectation value of the kinetic energy<a class="headerlink" href="#expectation-value-of-the-kinetic-energy" title="Permalink to this headline">¶</a></h2>
<p>The expectation value of the kinetic energy expressed in atomic units for electron <span class="math notranslate nohighlight">\(i\)</span> is</p>
<p>1
6
2</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<p>1
6
3</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2 \Psi}{\Psi}  =  \frac{\nabla^2 ({\Psi_{D} \,  \Psi_C})}{\Psi_{D} \,  \Psi_C} = \frac{\nabla  \cdot [\nabla  {(\Psi_{D} \,  \Psi_C)}]}{\Psi_{D} \,  \Psi_C} = \frac{\nabla  \cdot [ \Psi_C \nabla  \Psi_{D} + \Psi_{D} \nabla   \Psi_C]}{\Psi_{D} \,  \Psi_C}\nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
=  \frac{\nabla   \Psi_C \cdot \nabla  \Psi_{D} +  \Psi_C \nabla^2 \Psi_{D} + \nabla  \Psi_{D} \cdot \nabla   \Psi_C + \Psi_{D} \nabla^2  \Psi_C}{\Psi_{D} \,  \Psi_C}\nonumber
\]</div>
<p>1
6
6</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\nabla^2 \Psi}{\Psi}
 =  \frac{\nabla^2 \Psi_{D}}{\Psi_{D}} + \frac{\nabla^2  \Psi_C}{ \Psi_C} + 2 \frac{\nabla  \Psi_{D}}{\Psi_{D}}\cdot\frac{\nabla   \Psi_C}{ \Psi_C}
\label{_auto8} \tag{24}
\end{equation}
\]</div>
</div>
<div class="section" id="second-derivative-of-the-jastrow-factor">
<h2><span class="section-number">1.124. </span>Second derivative of the Jastrow factor<a class="headerlink" href="#second-derivative-of-the-jastrow-factor" title="Permalink to this headline">¶</a></h2>
<p>The second derivative of the Jastrow factor divided by the Jastrow factor (the way it enters the kinetic energy) is</p>
<div class="math notranslate nohighlight">
\[
\left[\frac{\nabla^2 \Psi_C}{\Psi_C}\right]_x =\  
2\sum_{k=1}^{N}
\sum_{i=1}^{k-1}\frac{\partial^2 g_{ik}}{\partial x_k^2}\ +\ 
\sum_{k=1}^N
\left(
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k} -
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}
\right)^2
\]</div>
</div>
<div class="section" id="functional-form">
<h2><span class="section-number">1.125. </span>Functional form<a class="headerlink" href="#functional-form" title="Permalink to this headline">¶</a></h2>
<p>But we have a simple form for the function, namely</p>
<div class="math notranslate nohighlight">
\[
\Psi_{C}=\prod_{i&lt; j}\exp{f(r_{ij})}= \exp{\left\{\sum_{i&lt;j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>and it is easy to see that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}f'(r_{ki})f'(r_{kj})+
\sum_{j\ne k}\left( f''(r_{kj})+\frac{2}{r_{kj}}f'(r_{kj})\right)
\]</div>
</div>
<div class="section" id="id89">
<h2><span class="section-number">1.126. </span>Second derivative of the Jastrow factor<a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h2>
<p>Using</p>
<div class="math notranslate nohighlight">
\[
f(r_{ij})= \frac{ar_{ij}}{1+\beta r_{ij}},
\]</div>
<p>and <span class="math notranslate nohighlight">\(g'(r_{kj})=dg(r_{kj})/dr_{kj}\)</span> and
<span class="math notranslate nohighlight">\(g''(r_{kj})=d^2g(r_{kj})/dr_{kj}^2\)</span>  we find that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}\frac{a}{(1+\beta r_{ki})^2}
\frac{a}{(1+\beta r_{kj})^2}+
\sum_{j\ne k}\left(\frac{2a}{r_{kj}(1+\beta r_{kj})^2}-\frac{2a\beta}{(1+\beta r_{kj})^3}\right)
\]</div>
</div>
<div class="section" id="gradient-and-laplacian">
<h2><span class="section-number">1.127. </span>Gradient and Laplacian<a class="headerlink" href="#gradient-and-laplacian" title="Permalink to this headline">¶</a></h2>
<p>The gradient and
Laplacian can be calculated as follows:</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \vec\nabla_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \vec\nabla_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \nabla^2_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \nabla^2_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r})
\]</div>
</div>
<div class="section" id="the-gradient-for-the-determinant">
<h2><span class="section-number">1.128. </span>The gradient for the determinant<a class="headerlink" href="#the-gradient-for-the-determinant" title="Permalink to this headline">¶</a></h2>
<p>The gradient for the determinant is</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \mathbf{\nabla}_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \mathbf{\nabla}_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r}).
\]</div>
</div>
<div class="section" id="jastrow-gradient-in-quantum-force">
<h2><span class="section-number">1.129. </span>Jastrow gradient in quantum force<a class="headerlink" href="#jastrow-gradient-in-quantum-force" title="Permalink to this headline">¶</a></h2>
<p>We have</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})= \exp{\left\{\sum_{i&lt;j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>the gradient needed for the quantum force and local energy is easy to compute.<br />
We get for particle  <span class="math notranslate nohighlight">\(k\)</span></p>
<div class="math notranslate nohighlight">
\[
\frac{ \nabla_k \Psi_C}{ \Psi_C }= \sum_{j\ne k}\frac{\mathbf{r}_{kj}}{r_{kj}}\frac{a}{(1+\beta r_{kj})^2},
\]</div>
<p>which is rather easy to code.  Remember to sum over all particles  when you compute the local energy.</p>
</div>
<div class="section" id="metropolis-hastings-part">
<h2><span class="section-number">1.130. </span>Metropolis Hastings part<a class="headerlink" href="#metropolis-hastings-part" title="Permalink to this headline">¶</a></h2>
<p>We need to compute the ratio between wave functions, in particular  for the Slater determinants.</p>
<div class="math notranslate nohighlight">
\[
R =\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}}) = 
\sum_{j=1}^N \phi_j(\mathbf{r}_i^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})
\]</div>
<p>What this means is that in order to get the ratio when only the <em>i</em>-th
particle  has been moved, we only need to calculate the dot
product of the vector <span class="math notranslate nohighlight">\(\left(\phi_1(\mathbf{r}_i^\mathrm{new}),\,\dots,\,
\phi_N(\mathbf{r}_i^\mathrm{new})\right)\)</span> of single particle  wave functions
evaluated at this new position with the <em>i</em>-th column of the inverse
matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> evaluated at the original position. Such
an operation has a time scaling of <span class="math notranslate nohighlight">\(O(N)\)</span>. The only extra thing we
need to do is to maintain the inverse matrix
<span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{x}^{\mathrm{old}})\)</span>.</p>
</div>
<div class="section" id="single-particle-states">
<h2><span class="section-number">1.131. </span>Single-particle states<a class="headerlink" href="#single-particle-states" title="Permalink to this headline">¶</a></h2>
<p>The <span class="math notranslate nohighlight">\(1s\)</span> hydrogen like wave function</p>
<div class="math notranslate nohighlight">
\[
R_{10}(r) =  2\left(\frac{Z}{a_0}\right)^{3/2}\exp{(-Zr/a_0)}= u_{10}/r
\]</div>
<p>The total energy for helium (not the Hartree or Fock terms) from  the direct and the exchange term should give <span class="math notranslate nohighlight">\(5Z/8\)</span>.</p>
<p>The single-particle energy with no interactions should give <span class="math notranslate nohighlight">\(-Z^2/2n^2\)</span>.</p>
</div>
<div class="section" id="id90">
<h2><span class="section-number">1.132. </span>Single-particle states<a class="headerlink" href="#id90" title="Permalink to this headline">¶</a></h2>
<p>The <span class="math notranslate nohighlight">\(2s\)</span> hydrogen-like wave function is</p>
<div class="math notranslate nohighlight">
\[
R_{20}(r) =  2\left(\frac{Z}{2a_0}\right)^{3/2}\left(1-\frac{Zr}{2a_0}\right)\exp{(-Zr/2a_0)}= u_{20}/r
\]</div>
<p>and the <span class="math notranslate nohighlight">\(2p\)</span> hydrogen -like wave function is</p>
<div class="math notranslate nohighlight">
\[
R_{21}(r) =  \frac{1}{\sqrt{3}}\left(\frac{Z}{2a_0}\right)^{3/2}\frac{Zr}{a_0}\exp{(-Zr/2a_0)}= u_{21}/r
\]</div>
<p>We use <span class="math notranslate nohighlight">\(a_0=1\)</span>.</p>
</div>
<div class="section" id="problems-with-neon-states-for-vmc">
<h2><span class="section-number">1.133. </span>Problems with neon states for VMC<a class="headerlink" href="#problems-with-neon-states-for-vmc" title="Permalink to this headline">¶</a></h2>
<p>In the standard textbook case one uses spherical coordinates  in order to get the hydrogen-like wave functions</p>
<p>1
8
2</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
y=rsin\theta sin\phi,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
z=rcos\theta.
\]</div>
</div>
<div class="section" id="id91">
<h2><span class="section-number">1.134. </span>Problems with neon states for VMC<a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h2>
<p>The reason we introduce spherical coordinates is the spherical symmetry of the Coulomb potential</p>
<div class="math notranslate nohighlight">
\[
\frac{e^2}{4\pi\epsilon_0r}=\frac{e^2}{4\pi\epsilon_0\sqrt{x^2+y^2+z^2}},
\]</div>
<p>where we have used <span class="math notranslate nohighlight">\(r=\sqrt{x^2+y^2+z^2}\)</span>.
It is not possible to find a separable solution of the type</p>
<div class="math notranslate nohighlight">
\[
\psi(x,y,z)=\psi(x)\psi(y)\psi(z).
\]</div>
<p>However, with spherical coordinates we can find a solution
of the form</p>
<div class="math notranslate nohighlight">
\[
\psi(r,\theta,\phi)=R(r)P(\theta)F(\phi).
\]</div>
</div>
<div class="section" id="spherical-harmonics">
<h2><span class="section-number">1.135. </span>Spherical harmonics<a class="headerlink" href="#spherical-harmonics" title="Permalink to this headline">¶</a></h2>
<p>The angle-dependent differential equations result in the spherical harmonic functions as
solutions, with quantum numbers <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(m_l\)</span>.
These functions are given by</p>
<div class="math notranslate nohighlight">
\[
Y_{lm_l}(\theta,\phi)=P(\theta)F(\phi)=\sqrt{\frac{(2l+1)(l-m_l)!}{4\pi (l+m_l)!}}
                      P_l^{m_l}(cos(\theta))\exp{(im_l\phi)},
\]</div>
<p>with <span class="math notranslate nohighlight">\(P_l^{m_l}\)</span> being the associated Legendre polynomials
They can be rewritten as</p>
<div class="math notranslate nohighlight">
\[
Y_{lm_l}(\theta,\phi)=sin^{|m_l|}(\theta) \times (\mathrm{polynom}(cos\theta))\exp{(im_l\phi)},
\]</div>
</div>
<div class="section" id="examples-of-spherical-harmonics">
<h2><span class="section-number">1.136. </span>Examples of spherical harmonics<a class="headerlink" href="#examples-of-spherical-harmonics" title="Permalink to this headline">¶</a></h2>
<p>We have the following selected examples</p>
<div class="math notranslate nohighlight">
\[
Y_{00}=\sqrt{\frac{1}{4\pi}},
\]</div>
<p>for <span class="math notranslate nohighlight">\(l=m_l=0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
Y_{10}=\sqrt{\frac{3}{4\pi}}cos(\theta),
\]</div>
<p>for <span class="math notranslate nohighlight">\(l=1\)</span> og <span class="math notranslate nohighlight">\(m_l=0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
Y_{1\pm 1}=\sqrt{\frac{3}{8\pi}}sin(\theta)exp(\pm i\phi),
\]</div>
<p>for  <span class="math notranslate nohighlight">\(l=1\)</span> og <span class="math notranslate nohighlight">\(m_l=\pm 1\)</span>.</p>
</div>
<div class="section" id="problems-with-spherical-harmonics">
<h2><span class="section-number">1.137. </span>Problems with spherical harmonics<a class="headerlink" href="#problems-with-spherical-harmonics" title="Permalink to this headline">¶</a></h2>
<p>A problem with the spherical harmonics is that they are complex. The introduction of <em>solid harmonics</em> allows the use
of real orbital wave-functions for a wide range of applications. The
complex solid harmonics <span class="math notranslate nohighlight">\(\mathbf{Y}_{lm_l}(\mathbf{r})\)</span> are related to
the spherical harmonics  <span class="math notranslate nohighlight">\(Y_{lm_l}(\mathbf{r})\)</span> through</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Y}_{lm_l}(\mathbf{r}) = r^l Y_{lm_l}(\mathbf{r}).
\]</div>
<p>By factoring out the leading <span class="math notranslate nohighlight">\(r\)</span>-dependency of the radial-function</p>
<div class="math notranslate nohighlight">
\[
\mathbf{R}_{nl}(\mathbf{r}) = r^{-l} R_{nl}(\mathbf{r}),
\]</div>
<p>we obtain</p>
<!-- Equation labels as ordinary links -->
<div id="totalSolidHydrogenWavefunction"></div>
<div class="math notranslate nohighlight">
\[
\Psi_{nlm_l}(r,\theta, \phi) %=R_{nl}(r) \cdot Y_{lm_l}(\theta,\phi)
  = \mathbf{R}_{nl}(\mathbf{r})\cdot\mathbf{Y}_{lm_l}(\mathbf{r}).
%\label{totalSolidHydrogenWavefunction} \tag{25}
\]</div>
</div>
<div class="section" id="real-solid-harmonics">
<h2><span class="section-number">1.138. </span>Real solid harmonics<a class="headerlink" href="#real-solid-harmonics" title="Permalink to this headline">¶</a></h2>
<p>For the theoretical development of the <em>real solid harmonics</em> we first
express the complex solid harmonics, <span class="math notranslate nohighlight">\(C_{lm_l}\)</span>, by (complex) Cartesian
coordinates, and arrive at the real solid harmonics, <span class="math notranslate nohighlight">\(S_{lm_l}\)</span>, through
the unitary transformation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left( \begin{split} &amp;\phantom{i} S_{lm_l} \\ 
    &amp;S_{l,-m_l} \end{split} \right) 
  = \frac{1}{\sqrt{2}} \left(        \begin{split}
    (-1)^m_l \phantom{a} &amp; \phantom{aa} 1 \\ 
    -(-1)^m_l i &amp; \phantom{aa} i       \end{split} \right)  
  \left( \begin{split} &amp;\phantom{i} C_{lm_l} \\ 
    &amp;C_{l,-m_l} \end{split} \right).
\end{split}\]</div>
</div>
<div class="section" id="solid-harmonics">
<h2><span class="section-number">1.139. </span>Solid harmonics<a class="headerlink" href="#solid-harmonics" title="Permalink to this headline">¶</a></h2>
<p>This transformation will not alter any physical quantities that are
degenerate in the subspace consisting of opposite magnetic quantum
numbers (the angular momentum <span class="math notranslate nohighlight">\(l\)</span> is equal for both these cases). This
means for example that the above transformation does not alter the
energies, unless an external magnetic field is applied to the
system. Henceforth, we will use the solid harmonics, and note that
changing the spherical potential beyond the Coulomb potential will not
alter the solid harmonics.</p>
</div>
<div class="section" id="relation-between-solid-harmonics-and-spherical-harmonics">
<h2><span class="section-number">1.140. </span>Relation between solid harmonics and spherical harmonics<a class="headerlink" href="#relation-between-solid-harmonics-and-spherical-harmonics" title="Permalink to this headline">¶</a></h2>
<p>We have defined</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Y}_{lm_l}(\mathbf{r}) = r^l Y_{lm_l}(\mathbf{r}).
\]</div>
<p>The real-valued spherical harmonics are defined as</p>
<p>1
9
8</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<p>1
9
9</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
S_{lm_l} =  (-1)^{m_l}\sqrt{\frac{8\pi}{2l+1}} \mathrm{Im}\mathbf{Y}_{l0}(\mathbf{r}),
\]</div>
<p>for <span class="math notranslate nohighlight">\(m_l&gt; 0\)</span>.</p>
</div>
<div class="section" id="the-lowest-order-real-solid-harmonics">
<h2><span class="section-number">1.141. </span>The lowest-order real solid harmonics<a class="headerlink" href="#the-lowest-order-real-solid-harmonics" title="Permalink to this headline">¶</a></h2>
<table border="1">
<thead>
<tr><th align="center">$m_l\backslash l$</th> <th align="center">0</th> <th align="center"> 1 </th> <th align="center">              2               </th> <th align="center">                    3                     </th> </tr>
</thead>
<tbody>
<tr><td align="center">   +3                   </td> <td align="center">        </td> <td align="center">          </td> <td align="center">                                     </td> <td align="center">   $\frac{1}{2}\sqrt{\frac{5}{2}}(x^2-3y^2)x$    </td> </tr>
<tr><td align="center">   +2                   </td> <td align="center">        </td> <td align="center">          </td> <td align="center">   $\frac{1}{2}\sqrt{3}(x^2-y^2)$    </td> <td align="center">   $\frac{1}{2}\sqrt{15}(x^2-y^2)z$              </td> </tr>
<tr><td align="center">   +1                   </td> <td align="center">        </td> <td align="center">   $x$    </td> <td align="center">   $\sqrt{3}xz$                      </td> <td align="center">   $\frac{1}{2}\sqrt{\frac{3}{2}}(5z^2-r^2)x$    </td> </tr>
<tr><td align="center">   0                    </td> <td align="center">        </td> <td align="center">   $y$    </td> <td align="center">   $\frac{1}{2}(3z^2-r^2)$           </td> <td align="center">   $\frac{1}{2}(5z^2-3r^2)x$                     </td> </tr>
<tr><td align="center">   -1                   </td> <td align="center">        </td> <td align="center">   $z$    </td> <td align="center">   $\sqrt{3}yz$                      </td> <td align="center">   $\frac{1}{2}\sqrt{\frac{3}{2}}(5z^2-r^2)y$    </td> </tr>
<tr><td align="center">   -2                   </td> <td align="center">        </td> <td align="center">          </td> <td align="center">   $\sqrt{3}xy$                      </td> <td align="center">   $\sqrt{15}xyz$                                </td> </tr>
<tr><td align="center">   -3                   </td> <td align="center">        </td> <td align="center">          </td> <td align="center">                                     </td> <td align="center">   $\frac{1}{2}\sqrt{\frac{5}{2}}(3x^2-y^2)y$    </td> </tr>
</tbody>
</table>
</div>
<div class="section" id="proof-for-updating-algorithm-for-slater-determinant">
<h2><span class="section-number">1.142. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#proof-for-updating-algorithm-for-slater-determinant" title="Permalink to this headline">¶</a></h2>
<p>As a starting point we may consider that each time a new position is suggested in the Metropolis algorithm, a row of the current Slater matrix experiences some kind of perturbation. Hence, the Slater matrix with its orbitals evaluated at the new position equals the old Slater matrix plus a perturbation matrix,</p>
<!-- Equation labels as ordinary links -->
<div id="oldSM"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{oldSM} \tag{26}
d_{jk}(\mathbf{x^{new}}) = d_{jk}(\mathbf{x^{old}}) + \Delta_{jk},
\end{equation}
\]</div>
<p>where</p>
<!-- Equation labels as ordinary links -->
<div id="pertMatrix"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{pertMatrix} \tag{27}
\Delta_{jk} = \delta_{ik}[\phi_j(\mathbf{x_{i}^{new}}) - \phi_j(\mathbf{x_{i}^{old}})] = \delta_{ik}(\Delta\phi)_j .
\end{equation}
\]</div>
</div>
<div class="section" id="id92">
<h2><span class="section-number">1.143. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id92" title="Permalink to this headline">¶</a></h2>
<p>Computing the inverse of the transposed matrix we arrive at</p>
<!-- Equation labels as ordinary links -->
<div id="invDkj"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{invDkj} \tag{28}
 d_{kj}(\mathbf{x^{new}})^{-1} = [d_{kj}(\mathbf{x^{old}}) + \Delta_{kj}]^{-1}.
\end{equation}
\]</div>
</div>
<div class="section" id="id93">
<h2><span class="section-number">1.144. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id93" title="Permalink to this headline">¶</a></h2>
<p>The evaluation of the right hand side (rhs) term above is carried out by applying the identity <span class="math notranslate nohighlight">\((A +  B)^{-1} = A^{-1} - (A + B)^{-1} B A^{-1}\)</span>. In compact notation it yields</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray*}
 [\mathbf{D}^{T}(\mathbf{x^{new}})]^{-1} &amp; = &amp; [\mathbf{D}^{T}(\mathbf{x^{old}}) + \Delta^T]^{-1}\\
&amp; = &amp; [\mathbf{D}^{T}(\mathbf{x^{old}})]^{-1} - [\mathbf{D}^{T}(\mathbf{x^{old}}) + \Delta^T]^{-1} \Delta^T [\mathbf{D}^{T}(\mathbf{x^{old}})]^{-1}\\
&amp; = &amp; [\mathbf{D}^{T}(\mathbf{x^{old}})]^{-1} - \underbrace{{[\mathbf{D}^{T}(\mathbf{x^{new}})]^{-1}}}_{\text{By Eq.}{\ref{invDkj}}}  \Delta^T [\mathbf{D}^{T}(\mathbf{x^{old}})]^{-1}.
\end{eqnarray*}
\end{split}\]</div>
</div>
<div class="section" id="id94">
<h2><span class="section-number">1.145. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id94" title="Permalink to this headline">¶</a></h2>
<p>Using index notation, the last result may be expanded by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray*}
d^{-1}_{kj}(\mathbf{x^{new}}) &amp; = &amp; d^{-1}_{kj}(\mathbf{x^{old}}) -  \sum_{l} \sum_{m} d^{-1}_{km}(\mathbf{x^{new}}) \Delta^{T}_{ml}  d^{-1}_{lj}(\mathbf{x^{old}})\\
&amp; = &amp; d^{-1}_{kj}(\mathbf{x^{old}}) -  \sum_{l} \sum_{m} d^{-1}_{km}(\mathbf{x^{new}}) \Delta_{lm}  d^{-1}_{lj}(\mathbf{x^{cur}})\\
&amp; = &amp; d^{-1}_{kj}(\mathbf{x^{old}}) -  \sum_{l} \sum_{m} d^{-1}_{km}(\mathbf{x^{new}}) \delta_{im} (\Delta \phi)_{l} d^{-1}_{lj}(\mathbf{x^{old}})\\
&amp; = &amp; d^{-1}_{kj}(\mathbf{x^{old}}) - d^{-1}_{ki}(\mathbf{x^{new}}) \sum_{l=1}^{N}(\Delta \phi)_{l}  d^{-1}_{lj}(\mathbf{x^{old}})\\
&amp; = &amp; d^{-1}_{kj}(\mathbf{x^{old}}) - d^{-1}_{ki}(\mathbf{x^{new}}) \sum_{l=1}^{N}[\phi_{l}(\mathbf{r_{i}^{new}}) - \phi_{l}(\mathbf{r_{i}^{old}})]  D^{-1}_{lj}(\mathbf{x^{old}}).
\end{eqnarray*}
\end{split}\]</div>
</div>
<div class="section" id="id95">
<h2><span class="section-number">1.146. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h2>
<p>Using
$<span class="math notranslate nohighlight">\(\mathbf{D}^{-1}(\mathbf{x^{old}}) = \frac{adj \mathbf{D}}{|\mathbf{D}(\mathbf{x^{old}})|} \, \quad \text{and} \, \quad \mathbf{D}^{-1}(\mathbf{x^{new}}) = \frac{adj \mathbf{D}}{|\mathbf{D}(\mathbf{x^{new}})|},\)</span><span class="math notranslate nohighlight">\(
and dividing these two equations we get
\)</span><span class="math notranslate nohighlight">\(\frac{\mathbf{D}^{-1}(\mathbf{x^{old}})}{\mathbf{D}^{-1}(\mathbf{x^{new}})} = \frac{|\mathbf{D}(\mathbf{x^{new}})|}{|\mathbf{D}(\mathbf{x^{old}})|} = R \Rightarrow d^{-1}_{ki}(\mathbf{x^{new}}) = \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R}.\)</span>$</p>
</div>
<div class="section" id="id96">
<h2><span class="section-number">1.147. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id96" title="Permalink to this headline">¶</a></h2>
<p>We have $<span class="math notranslate nohighlight">\(d^{-1}_{kj}(\mathbf{x^{new}})  =  d^{-1}_{kj}(\mathbf{x^{old}}) - \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N}[\phi_{l}(\mathbf{r_{i}^{new}}) - \phi_{l}(\mathbf{r_{i}^{old}})]  d^{-1}_{lj}(\mathbf{x^{old}}),\)</span>$
or</p>
<div class="math notranslate nohighlight">
\[
d^{-1}_{kj}(\mathbf{x^{new}})  =  d^{-1}_{kj}(\mathbf{x^{old}}) \qquad  -  \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N}\phi_{l}(\mathbf{r_{i}^{new}})  d^{-1}_{lj}(\mathbf{x^{old}}) \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
+   \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N}\phi_{l}(\mathbf{r_{i}^{old}})  d^{-1}_{lj}(\mathbf{x^{old}})\nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
=  d^{-1}_{kj}(\mathbf{x^{old}}) \qquad  -  \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{new}})  d^{-1}_{lj}(\mathbf{x^{old}}) \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
+   \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{old}}) d^{-1}_{lj}(\mathbf{x^{old}}).\nonumber
\]</div>
</div>
<div class="section" id="id97">
<h2><span class="section-number">1.148. </span>Proof for updating algorithm for Slater determinant<a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h2>
<p>In this equation, the first line becomes zero for <span class="math notranslate nohighlight">\(j=i\)</span> and the second for <span class="math notranslate nohighlight">\(j \neq i\)</span>. Therefore, the update of the inverse for the new Slater matrix is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
\boxed{d^{-1}_{kj}(\mathbf{x^{new}})  = \left\{ 
\begin{array}{l l}
  d^{-1}_{kj}(\mathbf{x^{old}}) - \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{new}})  d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j \neq i$}\nonumber \\ \\
 \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{old}}) d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j=i$}
\end{array} \right.}
\end{eqnarray}
\end{split}\]</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="mbpt.html" title="previous page"><span class="section-number">4. </span>Many-body perturbation theory</a>
    <a class='right-next' id="next-link" href="gradientmethods.html" title="next page"><span class="section-number">2. </span>Gradient Methods</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Morten Hjorth-Jensen<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>