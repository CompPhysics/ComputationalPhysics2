
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5. Variational Monte Carlo methods &#8212; Advanced Topics in Computational Physics</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Gradient Methods" href="gradientmethods.html" />
    <link rel="prev" title="4. Many-body perturbation theory" href="mbpt.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Advanced Topics in Computational Physics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Advanced Topics in Computational Physics: Computational Quantum Mechanics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Schedule
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Instructor information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks and practicalities
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basic Many-Body Physics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicmanybody.html">
   1. Many-body Hamiltonians, basic linear algebra and Second Quantization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hartreefocktheory.html">
   2. Hartree-Fock methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fcitheory.html">
   3. Full configuration interaction theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mbpt.html">
   4. Many-body perturbation theory
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Stochastic Methods
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   5. Variational Monte Carlo methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="gradientmethods.html">
   6. Gradient Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="resamplingmethods.html">
   7. Resampling Techniques, Bootstrap and Blocking
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Computational Aspects
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vectorization.html">
   8. Optimization and Vectorization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallelization.html">
   9. Parallelization with MPI and OpenMPI
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Deep Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="linearregression.html">
   10. Linear Regression and more Advanced Regression Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="logisticregression.html">
   11. Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="supportvectormachines.html">
   12. Support Vector Machines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="neuralnetworks.html">
   13. Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boltzmannmachines.html">
   14. Boltzmann Machines
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Quantum Computing and Quantum Machine Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicquantumcomputing.html">
   15. Quantum Computing
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/vmcdmc.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-motivation">
   5.1. Quantum Monte Carlo Motivation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#quantum-monte-carlo-hydrogen-atom">
     5.1.1. Quantum Monte Carlo: hydrogen atom
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions">
     5.1.2. A simple Python code that solves the two-boson or two-fermion case in two-dimensions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-the-helium-atom">
   5.2. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-metropolis-algorithm">
   5.3. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling">
   5.4. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-program-elements">
   5.5. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-fokker-planck-and-langevin-equations">
   5.6. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-example-for-two-electrons-in-a-quantum-dots">
   5.7. Code example for two electrons in a quantum dots
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bringing-the-gradient-optmization">
     5.7.1. Bringing the gradient optmization
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vmc-for-fermions-efficient-calculation-of-slater-determinants">
   5.8. VMC for fermions: Efficient calculation of Slater determinants
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-gradient-and-the-laplacian">
     5.8.1. The gradient and the Laplacian
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#expectation-value-of-the-kinetic-energy">
     5.8.2. Expectation value of the kinetic energy
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Variational Monte Carlo methods</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-motivation">
   5.1. Quantum Monte Carlo Motivation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#quantum-monte-carlo-hydrogen-atom">
     5.1.1. Quantum Monte Carlo: hydrogen atom
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions">
     5.1.2. A simple Python code that solves the two-boson or two-fermion case in two-dimensions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quantum-monte-carlo-the-helium-atom">
   5.2. Quantum Monte Carlo: the helium atom
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-metropolis-algorithm">
   5.3. The Metropolis algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling">
   5.4. Importance sampling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-program-elements">
   5.5. Importance sampling, program elements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#importance-sampling-fokker-planck-and-langevin-equations">
   5.6. Importance sampling, Fokker-Planck and Langevin equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-example-for-two-electrons-in-a-quantum-dots">
   5.7. Code example for two electrons in a quantum dots
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bringing-the-gradient-optmization">
     5.7.1. Bringing the gradient optmization
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vmc-for-fermions-efficient-calculation-of-slater-determinants">
   5.8. VMC for fermions: Efficient calculation of Slater determinants
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-gradient-and-the-laplacian">
     5.8.1. The gradient and the Laplacian
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#expectation-value-of-the-kinetic-energy">
     5.8.2. Expectation value of the kinetic energy
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <!-- HTML file automatically generated from DocOnce source (https://github.com/doconce/doconce/)
doconce format html vmcdmc.do.txt  --><div class="tex2jax_ignore mathjax_ignore section" id="variational-monte-carlo-methods">
<h1><span class="section-number">5. </span>Variational Monte Carlo methods<a class="headerlink" href="#variational-monte-carlo-methods" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quantum-monte-carlo-motivation">
<h2><span class="section-number">5.1. </span>Quantum Monte Carlo Motivation<a class="headerlink" href="#quantum-monte-carlo-motivation" title="Permalink to this headline">¶</a></h2>
<p>We start with the variational principle.
Given a hamiltonian <span class="math notranslate nohighlight">\(H\)</span> and a trial wave function <span class="math notranslate nohighlight">\(\Psi_T\)</span>, the variational principle states that the expectation value of <span class="math notranslate nohighlight">\(\langle H \rangle\)</span>, defined through</p>
<div class="math notranslate nohighlight">
\[
E[H]= \langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
\]</div>
<p>is an upper bound to the ground state energy <span class="math notranslate nohighlight">\(E_0\)</span> of the hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
E_0 \le \langle H \rangle .
\]</div>
<p>In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.</p>
<p>The trial wave function can be expanded in the eigenstates of the hamiltonian since they form a complete set, viz.,</p>
<div class="math notranslate nohighlight">
\[
\Psi_T(\boldsymbol{R})=\sum_i a_i\Psi_i(\boldsymbol{R}),
\]</div>
<p>and assuming the set of eigenfunctions to be normalized one obtains</p>
<div class="math notranslate nohighlight">
\[
\frac{\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})H(\boldsymbol{R})\Psi_n(\boldsymbol{R})}
        {\sum_{nm}a^*_ma_n \int d\boldsymbol{R}\Psi^{\ast}_m(\boldsymbol{R})\Psi_n(\boldsymbol{R})} =\frac{\sum_{n}a^2_n E_n}
        {\sum_{n}a^2_n} \ge E_0,
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(H(\boldsymbol{R})\Psi_n(\boldsymbol{R})=E_n\Psi_n(\boldsymbol{R})\)</span>.
In general, the integrals involved in the calculation of various  expectation
values  are multi-dimensional ones.
The variational principle yields the lowest state of a given symmetry.</p>
<p>In most cases, a wave function has only small values in large parts of
configuration space, and a straightforward procedure which uses
homogenously distributed random points in configuration space
will most likely lead to poor results. This may suggest that some kind
of importance sampling combined with e.g., the Metropolis algorithm
may be  a more efficient way of obtaining the ground state energy.
The hope is then that those regions of configurations space where
the wave function assumes appreciable values are sampled more
efficiently.</p>
<p>The tedious part in a VMC calculation is the search for the variational
minimum. A good knowledge of the system is required in order to carry out
reasonable VMC calculations. This is not always the case,
and often VMC calculations
serve rather as the starting
point for so-called diffusion Monte Carlo calculations (DMC). DMC is a way of
solving exactly the many-body Schroedinger equation by means of
a stochastic procedure. A good guess on the binding energy
and its wave function is however necessary.
A carefully performed VMC calculation can aid in this context.</p>
<p>The basic recipe in a VMC calculation consists of the following elements:</p>
<ul class="simple">
<li><p>Construct first a trial wave function <span class="math notranslate nohighlight">\(\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\)</span>,  for a many-body system consisting of <span class="math notranslate nohighlight">\(N\)</span> particles located at positions  <span class="math notranslate nohighlight">\(\boldsymbol{R}=(\boldsymbol{R}_1,\dots ,\boldsymbol{R}_N)\)</span>. The trial wave function depends on <span class="math notranslate nohighlight">\(\alpha\)</span> variational parameters <span class="math notranslate nohighlight">\(\boldsymbol{\alpha}=(\alpha_1,\dots ,\alpha_M)\)</span>.</p></li>
<li><p>Then we evaluate the expectation value of the hamiltonian <span class="math notranslate nohighlight">\(H\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[
E[H]=\langle H \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_{T}(\boldsymbol{R},\boldsymbol{\alpha})\Psi_{T}(\boldsymbol{R},\boldsymbol{\alpha})}.
\]</div>
<ul class="simple">
<li><p>Thereafter we vary <span class="math notranslate nohighlight">\(\alpha\)</span> according to some minimization algorithm and return to the first step.</p></li>
</ul>
<p>With a trial wave function <span class="math notranslate nohighlight">\(\psi_T(\boldsymbol{R})\)</span> we can in turn construct the quantum mechanical probability distribution</p>
<div class="math notranslate nohighlight">
\[
P(\boldsymbol{R})= \frac{\left|\psi_T(\boldsymbol{R})\right|^2}{\int \left|\psi_T(\boldsymbol{R})\right|^2d\boldsymbol{R}}.
\]</div>
<p>This is our new probability distribution function  (PDF).
The approximation to the expectation value of the Hamiltonian is now</p>
<div class="math notranslate nohighlight">
\[
E[H(\boldsymbol{\alpha})] = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
\]</div>
<p>Define a new quantity</p>
<!-- Equation labels as ordinary links -->
<div id="eq:locale1"></div>
<div class="math notranslate nohighlight">
\[
E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
\label{eq:locale1} \tag{1}
\]</div>
<p>called the local energy, which, together with our trial PDF yields</p>
<!-- Equation labels as ordinary links -->
<div id="eq:vmc1"></div>
<div class="math notranslate nohighlight">
\[
E[H(\boldsymbol{\alpha})]=\int P(\boldsymbol{R})E_L(\boldsymbol{R}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^NP(\boldsymbol{R_i},\boldsymbol{\alpha})E_L(\boldsymbol{R_i},\boldsymbol{\alpha})
\label{eq:vmc1} \tag{2}
\]</div>
<p>with <span class="math notranslate nohighlight">\(N\)</span> being the number of Monte Carlo samples.</p>
<p>The Algorithm for performing a variational Monte Carlo calculations runs thus as this</p>
<ul class="simple">
<li><p>Initialisation: Fix the number of Monte Carlo steps. Choose an initial <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> and variational parameters <span class="math notranslate nohighlight">\(\alpha\)</span> and calculate <span class="math notranslate nohighlight">\(\left|\psi_T^{\alpha}(\boldsymbol{R})\right|^2\)</span>.</p></li>
<li><p>Initialise the energy and the variance and start the Monte Carlo calculation.</p>
<ul>
<li><p>Calculate  a trial position  <span class="math notranslate nohighlight">\(\boldsymbol{R}_p=\boldsymbol{R}+r*step\)</span> where <span class="math notranslate nohighlight">\(r\)</span> is a random variable <span class="math notranslate nohighlight">\(r \in [0,1]\)</span>.</p></li>
<li><p>Metropolis algorithm to accept or reject this move  <span class="math notranslate nohighlight">\(w = P(\boldsymbol{R}_p)/P(\boldsymbol{R})\)</span>.</p></li>
<li><p>If the step is accepted, then we set <span class="math notranslate nohighlight">\(\boldsymbol{R}=\boldsymbol{R}_p\)</span>.</p></li>
<li><p>Update averages</p></li>
</ul>
</li>
<li><p>Finish and compute final averages.</p></li>
</ul>
<p>Observe that the jumping in space is governed by the variable <em>step</em>. This is Called brute-force sampling.
Need importance sampling to get more relevant sampling, see lectures below.</p>
<div class="section" id="quantum-monte-carlo-hydrogen-atom">
<h3><span class="section-number">5.1.1. </span>Quantum Monte Carlo: hydrogen atom<a class="headerlink" href="#quantum-monte-carlo-hydrogen-atom" title="Permalink to this headline">¶</a></h3>
<p>The radial Schroedinger equation for the hydrogen atom can be
written as</p>
<div class="math notranslate nohighlight">
\[
-\frac{\hbar^2}{2m}\frac{\partial^2 u(r)}{\partial r^2}-
\left(\frac{ke^2}{r}-\frac{\hbar^2l(l+1)}{2mr^2}\right)u(r)=Eu(r),
\]</div>
<p>or with dimensionless variables</p>
<!-- Equation labels as ordinary links -->
<div id="eq:hydrodimless1"></div>
<div class="math notranslate nohighlight">
\[
-\frac{1}{2}\frac{\partial^2 u(\rho)}{\partial \rho^2}-
\frac{u(\rho)}{\rho}+\frac{l(l+1)}{2\rho^2}u(\rho)-\lambda u(\rho)=0,
\label{eq:hydrodimless1} \tag{3}
\]</div>
<p>with the hamiltonian</p>
<div class="math notranslate nohighlight">
\[
H=-\frac{1}{2}\frac{\partial^2 }{\partial \rho^2}-
\frac{1}{\rho}+\frac{l(l+1)}{2\rho^2}.
\]</div>
<p>Use variational parameter <span class="math notranslate nohighlight">\(\alpha\)</span> in the trial
wave function</p>
<!-- Equation labels as ordinary links -->
<div id="eq:trialhydrogen"></div>
<div class="math notranslate nohighlight">
\[
u_T^{\alpha}(\rho)=\alpha\rho e^{-\alpha\rho}. 
\label{eq:trialhydrogen} \tag{4}
\]</div>
<p>Inserting this wave function into the expression for the
local energy <span class="math notranslate nohighlight">\(E_L\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
E_L(\rho)=-\frac{1}{\rho}-
              \frac{\alpha}{2}\left(\alpha-\frac{2}{\rho}\right).
\]</div>
<p>A simple variational Monte Carlo calculation results in</p>
<table class="dotable" border="1">
<thead>
<tr><th align="center">  $\alpha$ </th> <th align="center">$\langle H \rangle $</th> <th align="center"> $\sigma^2$</th> <th align="center">$\sigma/\sqrt{N}$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   7.00000E-01    </td> <td align="center">   -4.57759E-01            </td> <td align="center">   4.51201E-02    </td> <td align="center">   6.71715E-04          </td> </tr>
<tr><td align="center">   8.00000E-01    </td> <td align="center">   -4.81461E-01            </td> <td align="center">   3.05736E-02    </td> <td align="center">   5.52934E-04          </td> </tr>
<tr><td align="center">   9.00000E-01    </td> <td align="center">   -4.95899E-01            </td> <td align="center">   8.20497E-03    </td> <td align="center">   2.86443E-04          </td> </tr>
<tr><td align="center">   1.00000E-00    </td> <td align="center">   -5.00000E-01            </td> <td align="center">   0.00000E+00    </td> <td align="center">   0.00000E+00          </td> </tr>
<tr><td align="center">   1.10000E+00    </td> <td align="center">   -4.93738E-01            </td> <td align="center">   1.16989E-02    </td> <td align="center">   3.42036E-04          </td> </tr>
<tr><td align="center">   1.20000E+00    </td> <td align="center">   -4.75563E-01            </td> <td align="center">   8.85899E-02    </td> <td align="center">   9.41222E-04          </td> </tr>
<tr><td align="center">   1.30000E+00    </td> <td align="center">   -4.54341E-01            </td> <td align="center">   1.45171E-01    </td> <td align="center">   1.20487E-03          </td> </tr>
</tbody>
</table>
<p>We note that at <span class="math notranslate nohighlight">\(\alpha=1\)</span> we obtain the exact
result, and the variance is zero, as it should. The reason is that
we then have the exact wave function, and the action of the hamiltionan
on the wave function</p>
<div class="math notranslate nohighlight">
\[
H\psi = \mathrm{constant}\times \psi,
\]</div>
<p>yields just a constant. The integral which defines various
expectation values involving moments of the hamiltonian becomes then</p>
<div class="math notranslate nohighlight">
\[
\langle H^n \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H^n(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=
\mathrm{constant}\times\frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})}=\mathrm{constant}.
\]</div>
<p><strong>This gives an important information: the exact wave function leads to zero variance!</strong>
Variation is then performed by minimizing both the energy and the variance.</p>
<p>For bosons in a harmonic oscillator-like  trap we will use is a spherical (S)
or an elliptical (E) harmonic trap in one, two and finally three
dimensions, with the latter given by</p>
<!-- Equation labels as ordinary links -->
<div id="trap_eqn"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
 V_{ext}(\mathbf{r}) = \Bigg\{
 \begin{array}{ll}
	 \frac{1}{2}m\omega_{ho}^2r^2 &amp; (S)\\
 \strut
	 \frac{1}{2}m[\omega_{ho}^2(x^2+y^2) + \omega_z^2z^2] &amp; (E)
\label{trap_eqn} \tag{5}
 \end{array}
 \end{equation}
\end{split}\]</div>
<p>where (S) stands for symmetric and</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
     \hat{H} = \sum_i^N \left(
	 \frac{-\hbar^2}{2m}
	 { \bigtriangledown }_{i}^2 +
	 V_{ext}({\bf{r}}_i)\right)  +
	 \sum_{i&lt;j}^{N} V_{int}({\bf{r}}_i,{\bf{r}}_j),
\label{_auto1} \tag{6}
\end{equation}
\]</div>
<p>as the two-body Hamiltonian of the system.</p>
<p>We will represent the inter-boson interaction by a pairwise, repulsive potential</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
 V_{int}(|\mathbf{r}_i-\mathbf{r}_j|) =  \Bigg\{
 \begin{array}{ll}
	 \infty &amp; {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 0 &amp; {|\mathbf{r}_i-\mathbf{r}_j|} &gt; {a}
 \end{array}
\label{_auto2} \tag{7}
\end{equation}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> is the so-called hard-core diameter of the bosons.
Clearly, <span class="math notranslate nohighlight">\(V_{int}(|\mathbf{r}_i-\mathbf{r}_j|)\)</span> is zero if the bosons are
separated by a distance <span class="math notranslate nohighlight">\(|\mathbf{r}_i-\mathbf{r}_j|\)</span> greater than <span class="math notranslate nohighlight">\(a\)</span> but
infinite if they attempt to come within a distance <span class="math notranslate nohighlight">\(|\mathbf{r}_i-\mathbf{r}_j| \leq a\)</span>.</p>
<p>Our trial wave function for the ground state with <span class="math notranslate nohighlight">\(N\)</span> atoms is given by</p>
<!-- Equation labels as ordinary links -->
<div id="eq:trialwf"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
 \Psi_T(\mathbf{R})=\Psi_T(\mathbf{r}_1, \mathbf{r}_2, \dots \mathbf{r}_N,\alpha,\beta)=\prod_i g(\alpha,\beta,\mathbf{r}_i)\prod_{i&lt;j}f(a,|\mathbf{r}_i-\mathbf{r}_j|),
\label{eq:trialwf} \tag{8}
 \end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are variational parameters. The
single-particle wave function is proportional to the harmonic
oscillator function for the ground state</p>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
    g(\alpha,\beta,\mathbf{r}_i)= \exp{[-\alpha(x_i^2+y_i^2+\beta z_i^2)]}.
\label{_auto3} \tag{9}
\end{equation}
\]</div>
<p>For spherical traps we have <span class="math notranslate nohighlight">\(\beta = 1\)</span> and for non-interacting
bosons (<span class="math notranslate nohighlight">\(a=0\)</span>) we have <span class="math notranslate nohighlight">\(\alpha = 1/2a_{ho}^2\)</span>.  The correlation wave
function is</p>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
    f(a,|\mathbf{r}_i-\mathbf{r}_j|)=\Bigg\{
 \begin{array}{ll}
	 0 &amp; {|\mathbf{r}_i-\mathbf{r}_j|} \leq {a}\\
	 (1-\frac{a}{|\mathbf{r}_i-\mathbf{r}_j|}) &amp; {|\mathbf{r}_i-\mathbf{r}_j|} &gt; {a}.
 \end{array}
\label{_auto4} \tag{10}
\end{equation}
\end{split}\]</div>
</div>
<div class="section" id="a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions">
<h3><span class="section-number">5.1.2. </span>A simple Python code that solves the two-boson or two-fermion case in two-dimensions<a class="headerlink" href="#a-simple-python-code-that-solves-the-two-boson-or-two-fermion-case-in-two-dimensions" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># Importing various packages</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#Trial wave function for quantum dots in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="n">r12</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span><span class="o">+</span><span class="n">deno</span><span class="p">)</span>

<span class="c1">#Local energy  for quantum dots in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">deno2</span> <span class="o">=</span> <span class="n">deno</span><span class="o">*</span><span class="n">deno</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="o">+</span><span class="n">deno2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">r12</span><span class="o">-</span><span class="n">deno2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">deno</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="p">)</span>

<span class="c1"># The Monte Carlo sampling with the Metropolis algo</span>
<span class="k">def</span> <span class="nf">MonteCarloSampling</span><span class="p">():</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">100000</span>
    <span class="n">StepSize</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># seed for rng generator</span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="c1"># start variational parameter</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="mf">.025</span>
        <span class="n">AlphaValues</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span> 
        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">+=</span> <span class="mf">.01</span>
            <span class="n">BetaValues</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1">#Initial position</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">.5</span><span class="p">)</span>
            <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

            <span class="c1">#Loop over MC MCcycles</span>
            <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
                <span class="c1">#Trial position</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">StepSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">.5</span><span class="p">)</span>
                <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

                <span class="c1">#Metropolis test to see whether we accept the move</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">wfold</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                   <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                   <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
                   <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
                <span class="n">energy2</span> <span class="o">+=</span> <span class="n">DeltaE</span><span class="o">**</span><span class="mi">2</span>

            <span class="c1">#We calculate mean, variance and error ...</span>
            <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">energy2</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">-</span> <span class="n">energy</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="o">/</span><span class="n">NumberMCcycles</span><span class="p">)</span>
            <span class="n">Energies</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>    
    <span class="k">return</span> <span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">MaxVariations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MaxVariations</span><span class="p">,</span><span class="n">MaxVariations</span><span class="p">))</span>
<span class="n">AlphaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="n">BetaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="p">(</span><span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span> <span class="o">=</span> <span class="n">MonteCarloSampling</span><span class="p">()</span>

<span class="c1"># Prepare for plots</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="c1"># Plot the surface.</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Energies</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Customize the z axis.</span>
<span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\alpha$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\beta$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle E \rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">LinearLocator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.02f</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="c1"># Add a color bar which maps values to colors.</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyboardInterrupt</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">161</span><span class="n">f25e018f3</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">     </span><span class="mi">88</span> <span class="n">AlphaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">89</span> <span class="n">BetaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">90</span> <span class="p">(</span><span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span> <span class="o">=</span> <span class="n">MonteCarloSampling</span><span class="p">()</span>
<span class="g g-Whitespace">     </span><span class="mi">91</span> 
<span class="g g-Whitespace">     </span><span class="mi">92</span> <span class="c1"># Prepare for plots</span>

<span class="nn">&lt;ipython-input-1-161f25e018f3&gt;</span> in <span class="ni">MonteCarloSampling</span><span class="nt">()</span>
<span class="g g-Whitespace">     </span><span class="mi">68</span>                    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="g g-Whitespace">     </span><span class="mi">69</span>                    <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
<span class="ne">---&gt; </span><span class="mi">70</span>                    <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">71</span>                 <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
<span class="g g-Whitespace">     </span><span class="mi">72</span>                 <span class="n">energy2</span> <span class="o">+=</span> <span class="n">DeltaE</span><span class="o">**</span><span class="mi">2</span>

<span class="nn">&lt;ipython-input-1-161f25e018f3&gt;</span> in <span class="ni">LocalEnergy</span><span class="nt">(r, alpha, beta)</span>
<span class="g g-Whitespace">     </span><span class="mi">27</span>     <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">28</span>     <span class="n">deno2</span> <span class="o">=</span> <span class="n">deno</span><span class="o">*</span><span class="n">deno</span>
<span class="ne">---&gt; </span><span class="mi">29</span>     <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="o">+</span><span class="n">deno2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">r12</span><span class="o">-</span><span class="n">deno2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">deno</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">30</span> 
<span class="g g-Whitespace">     </span><span class="mi">31</span> <span class="c1"># The Monte Carlo sampling with the Metropolis algo</span>

<span class="ne">KeyboardInterrupt</span>: 
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="quantum-monte-carlo-the-helium-atom">
<h2><span class="section-number">5.2. </span>Quantum Monte Carlo: the helium atom<a class="headerlink" href="#quantum-monte-carlo-the-helium-atom" title="Permalink to this headline">¶</a></h2>
<p>The helium atom consists of two electrons and a nucleus with
charge <span class="math notranslate nohighlight">\(Z=2\)</span>.
The contribution<br />
to the potential energy due to the attraction from the nucleus is</p>
<div class="math notranslate nohighlight">
\[
-\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2},
\]</div>
<p>and if we add the repulsion arising from the two
interacting electrons, we obtain the potential energy</p>
<div class="math notranslate nohighlight">
\[
V(r_1, r_2)=-\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2}+
               \frac{ke^2}{r_{12}},
\]</div>
<p>with the electrons separated at a distance
<span class="math notranslate nohighlight">\(r_{12}=|\boldsymbol{r}_1-\boldsymbol{r}_2|\)</span>.</p>
<p>The hamiltonian becomes then</p>
<div class="math notranslate nohighlight">
\[
\hat{H}=-\frac{\hbar^2\nabla_1^2}{2m}-\frac{\hbar^2\nabla_2^2}{2m}
          -\frac{2ke^2}{r_1}-\frac{2ke^2}{r_2}+
               \frac{ke^2}{r_{12}},
\]</div>
<p>and  Schroedingers equation reads</p>
<div class="math notranslate nohighlight">
\[
\hat{H}\psi=E\psi.
\]</div>
<p>All observables are evaluated with respect to the probability distribution</p>
<div class="math notranslate nohighlight">
\[
P(\boldsymbol{R})= \frac{\left|\psi_T(\boldsymbol{R})\right|^2}{\int \left|\psi_T(\boldsymbol{R})\right|^2d\boldsymbol{R}}.
\]</div>
<p>generated by the trial wave function.<br />
The trial wave function must approximate an exact
eigenstate in order that accurate results are to be obtained.</p>
<p>Choice of trial wave function for Helium:
Assume <span class="math notranslate nohighlight">\(r_1 \rightarrow 0\)</span>.</p>
<div class="math notranslate nohighlight">
\[
E_L(\boldsymbol{R})=\frac{1}{\psi_T(\boldsymbol{R})}H\psi_T(\boldsymbol{R})=
     \frac{1}{\psi_T(\boldsymbol{R})}\left(-\frac{1}{2}\nabla^2_1
     -\frac{Z}{r_1}\right)\psi_T(\boldsymbol{R}) + \mathrm{finite \hspace{0.1cm}terms}.
\]</div>
<div class="math notranslate nohighlight">
\[
E_L(R)=
    \frac{1}{\mathbf{R}_T(r_1)}\left(-\frac{1}{2}\frac{d^2}{dr_1^2}-
     \frac{1}{r_1}\frac{d}{dr_1}
     -\frac{Z}{r_1}\right)\mathbf{R}_T(r_1) + \mathrm{finite\hspace{0.1cm} terms}
\]</div>
<p>For small values of <span class="math notranslate nohighlight">\(r_1\)</span>, the terms which dominate are</p>
<div class="math notranslate nohighlight">
\[
\lim_{r_1 \rightarrow 0}E_L(R)=
    \frac{1}{\mathbf{R}_T(r_1)}\left(-
     \frac{1}{r_1}\frac{d}{dr_1}
     -\frac{Z}{r_1}\right)\mathbf{R}_T(r_1),
\]</div>
<p>since the second derivative does not diverge due to the finiteness of  <span class="math notranslate nohighlight">\(\Psi\)</span> at the origin.</p>
<p>This results in</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\mathbf{R}_T(r_1)}\frac{d \mathbf{R}_T(r_1)}{dr_1}=-Z,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\mathbf{R}_T(r_1)\propto e^{-Zr_1}.
\]</div>
<p>A similar condition applies to electron 2 as well.
For orbital momenta <span class="math notranslate nohighlight">\(l &gt; 0\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\mathbf{R}_T(r)}\frac{d \mathbf{R}_T(r)}{dr}=-\frac{Z}{l+1}.
\]</div>
<p>Similarly, studying the case <span class="math notranslate nohighlight">\(r_{12}\rightarrow 0\)</span> we can write
a possible trial wave function as</p>
<!-- Equation labels as ordinary links -->
<div id="eq:wavehelium2"></div>
<div class="math notranslate nohighlight">
\[
\psi_T(\boldsymbol{R})=e^{-\alpha(r_1+r_2)}e^{\beta r_{12}}.
\label{eq:wavehelium2} \tag{11}
\]</div>
<p>The last equation can be generalized to</p>
<div class="math notranslate nohighlight">
\[
\psi_T(\boldsymbol{R})=\phi(\boldsymbol{r}_1)\phi(\boldsymbol{r}_2)\dots\phi(\boldsymbol{r}_N)
                   \prod_{i &lt; j}f(r_{ij}),
\]</div>
<p>for a system with <span class="math notranslate nohighlight">\(N\)</span> electrons or particles.</p>
<p>During the development of our code we need to make several checks. It is also very instructive to compute a closed form expression for the local energy. Since our wave function is rather simple  it is straightforward
to find an analytic expressions.  Consider first the case of the simple helium function</p>
<div class="math notranslate nohighlight">
\[
\Psi_T(\boldsymbol{r}_1,\boldsymbol{r}_2) = e^{-\alpha(r_1+r_2)}
\]</div>
<p>The local energy is for this case</p>
<div class="math notranslate nohighlight">
\[
E_{L1} = \left(\alpha-Z\right)\left(\frac{1}{r_1}+\frac{1}{r_2}\right)+\frac{1}{r_{12}}-\alpha^2
\]</div>
<p>which gives an expectation value for the local energy given by</p>
<div class="math notranslate nohighlight">
\[
\langle E_{L1} \rangle = \alpha^2-2\alpha\left(Z-\frac{5}{16}\right)
\]</div>
<p>With closed form formulae we  can speed up the computation of the correlation. In our case
we write it as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C= \exp{\left\{\sum_{i &lt; j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>which means that the gradient needed for the so-called quantum force and local energy
can be calculated analytically.
This will speed up your code since the computation of the correlation part and the Slater determinant are the most
time consuming parts in your code.</p>
<p>We will refer to this correlation function as <span class="math notranslate nohighlight">\(\Psi_C\)</span> or the <em>linear Pade-Jastrow</em>.</p>
<p>We can test this by computing the local energy for our helium wave function</p>
<div class="math notranslate nohighlight">
\[
\psi_{T}(\boldsymbol{r}_1,\boldsymbol{r}_2) = 
   \exp{\left(-\alpha(r_1+r_2)\right)}
   \exp{\left(\frac{r_{12}}{2(1+\beta r_{12})}\right)},
\]</div>
<p>with <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> as variational parameters.</p>
<p>The local energy is for this case</p>
<div class="math notranslate nohighlight">
\[
E_{L2} = E_{L1}+\frac{1}{2(1+\beta r_{12})^2}\left\{\frac{\alpha(r_1+r_2)}{r_{12}}(1-\frac{\boldsymbol{r}_1\boldsymbol{r}_2}{r_1r_2})-\frac{1}{2(1+\beta r_{12})^2}-\frac{2}{r_{12}}+\frac{2\beta}{1+\beta r_{12}}\right\}
\]</div>
<p>It is very useful to test your code against these expressions. It means also that you don’t need to
compute a derivative numerically as discussed in the code example below.</p>
<p>For the computation of various derivatives with different types of wave functions, you will find it useful to use python with symbolic python, that is sympy, see <a class="reference external" href="http://docs.sympy.org/latest/index.html">online manual</a>.  Using sympy allows you autogenerate both Latex code as well c++, python or Fortran codes. Here you will find some simple examples. We choose
the <span class="math notranslate nohighlight">\(2s\)</span> hydrogen-orbital  (not normalized) as an example</p>
<div class="math notranslate nohighlight">
\[
\phi_{2s}(\boldsymbol{r}) = (Zr - 2)\exp{-(\frac{1}{2}Zr)},
\]</div>
<p>with <span class="math notranslate nohighlight">\( r^2 = x^2 + y^2 + z^2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">r</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">phi</span>
<span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This doesn’t look very nice, but sympy provides several functions that allow for improving and simplifying the output.</p>
<p>We can improve our output by factorizing and substituting expressions</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">printing</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#Creates a symbolic equivalent of r</span>
<span class="c1">#print latex and c++ code</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We can in turn look at second derivatives</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">printing</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z Z&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#Creates a symbolic equivalent of r</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="c1"># Collect the Z values</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="c1"># Factorize also the r**2 terms</span>
<span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">((</span><span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>With some practice this allows one to be able to check one’s own calculation and translate automatically into code lines.</p>
</div>
<div class="section" id="the-metropolis-algorithm">
<h2><span class="section-number">5.3. </span>The Metropolis algorithm<a class="headerlink" href="#the-metropolis-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The Metropolis algorithm , see <a class="reference external" href="http://scitation.aip.org/content/aip/journal/jcp/21/6/10.1063/1.1699114">the original article</a> was invented by Metropolis et. al
and is often simply called the Metropolis algorithm.
It is a method to sample a normalized probability
distribution by a stochastic process. We define <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> to
be the probability for finding the system in the state <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n\)</span>.
The algorithm is then</p>
<ul class="simple">
<li><p>Sample a possible new state <span class="math notranslate nohighlight">\(j\)</span> with some probability <span class="math notranslate nohighlight">\(T_{i\rightarrow j}\)</span>.</p></li>
<li><p>Accept the new state <span class="math notranslate nohighlight">\(j\)</span> with probability <span class="math notranslate nohighlight">\(A_{i \rightarrow j}\)</span> and use it as the next sample. With probability <span class="math notranslate nohighlight">\(1-A_{i\rightarrow j}\)</span> the move is rejected and the original state <span class="math notranslate nohighlight">\(i\)</span> is used again as a sample.</p></li>
</ul>
<p>We wish to derive the required properties of <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(A\)</span> such that
<span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n\rightarrow \infty)} \rightarrow p_i\)</span> so that starting
from any distribution, the method converges to the correct distribution.
Note that the description here is for a discrete probability distribution.
Replacing probabilities <span class="math notranslate nohighlight">\(p_i\)</span> with expressions like <span class="math notranslate nohighlight">\(p(x_i)dx_i\)</span> will
take all of these over to the corresponding continuum expressions.</p>
<p>The dynamical equation for <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> can be written directly from
the description above. The probability of being in the state <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n\)</span>
is given by the probability of being in any state <span class="math notranslate nohighlight">\(j\)</span> at the previous step,
and making an accepted transition to <span class="math notranslate nohighlight">\(i\)</span> added to the probability of
being in the state <span class="math notranslate nohighlight">\(i\)</span>, making a transition to any state <span class="math notranslate nohighlight">\(j\)</span> and
rejecting the move:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \sum_j \left [
\mathbf{P}^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
+\mathbf{P}^{(n-1)}_iT_{i\rightarrow j}\left ( 1- A_{i\rightarrow j} \right)
\right ] \,.
\]</div>
<p>Since the probability of making some transition must be 1,
<span class="math notranslate nohighlight">\(\sum_j T_{i\rightarrow j} = 1\)</span>, and the above equation becomes</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \mathbf{P}^{(n-1)}_i +
 \sum_j \left [
\mathbf{P}^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
-\mathbf{P}^{(n-1)}_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] \,.
\]</div>
<p>For large <span class="math notranslate nohighlight">\(n\)</span> we require that <span class="math notranslate nohighlight">\(\mathbf{P}^{(n\rightarrow \infty)}_i = p_i\)</span>,
the desired probability distribution. Taking this limit, gives the
balance requirement</p>
<div class="math notranslate nohighlight">
\[
\sum_j \left [
p_jT_{j\rightarrow i} A_{j\rightarrow i}
-p_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] = 0 \,.
\]</div>
<p>The balance requirement is very weak. Typically the much stronger detailed
balance requirement is enforced, that is rather than the sum being
set to zero, we set each term separately to zero and use this
to determine the acceptance probabilities. Rearranging, the result is</p>
<div class="math notranslate nohighlight">
\[
\frac{ A_{j\rightarrow i}}{A_{i\rightarrow j}}
= \frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}} \,.
\]</div>
<p>The Metropolis choice is to maximize the <span class="math notranslate nohighlight">\(A\)</span> values, that is</p>
<div class="math notranslate nohighlight">
\[
A_{j \rightarrow i} = \min \left ( 1,
\frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}}\right ).
\]</div>
<p>Other choices are possible, but they all correspond to multilplying
<span class="math notranslate nohighlight">\(A_{i\rightarrow j}\)</span> and <span class="math notranslate nohighlight">\(A_{j\rightarrow i}\)</span> by the same constant
smaller than unity.\footnote{The penalty function method uses just such
a factor to compensate for <span class="math notranslate nohighlight">\(p_i\)</span> that are evaluated stochastically
and are therefore noisy.}</p>
<p>Having chosen the acceptance probabilities, we have guaranteed that
if the  <span class="math notranslate nohighlight">\(\mathbf{P}_i^{(n)}\)</span> has equilibrated, that is if it is equal to <span class="math notranslate nohighlight">\(p_i\)</span>,
it will remain equilibrated. Next we need to find the circumstances for
convergence to equilibrium.</p>
<p>The dynamical equation can be written as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}^{(n)}_i = \sum_j M_{ij}\mathbf{P}^{(n-1)}_j
\]</div>
<p>with the matrix <span class="math notranslate nohighlight">\(M\)</span> given by</p>
<div class="math notranslate nohighlight">
\[
M_{ij} = \delta_{ij}\left [ 1 -\sum_k T_{i\rightarrow k} A_{i \rightarrow k}
\right ] + T_{j\rightarrow i} A_{j\rightarrow i} \,.
\]</div>
<p>Summing over <span class="math notranslate nohighlight">\(i\)</span> shows that <span class="math notranslate nohighlight">\(\sum_i M_{ij} = 1\)</span>, and since
<span class="math notranslate nohighlight">\(\sum_k T_{i\rightarrow k} = 1\)</span>, and <span class="math notranslate nohighlight">\(A_{i \rightarrow k} \leq 1\)</span>, the
elements of the matrix satisfy <span class="math notranslate nohighlight">\(M_{ij} \geq 0\)</span>. The matrix <span class="math notranslate nohighlight">\(M\)</span> is therefore
a stochastic matrix.</p>
<p>The Metropolis method is simply the power method for computing the
right eigenvector of <span class="math notranslate nohighlight">\(M\)</span> with the largest magnitude eigenvalue.
By construction, the correct probability distribution is a right eigenvector
with eigenvalue 1. Therefore, for the Metropolis method to converge
to this result, we must show that <span class="math notranslate nohighlight">\(M\)</span> has only one eigenvalue with this
magnitude, and all other eigenvalues are smaller.</p>
</div>
<div class="section" id="importance-sampling">
<h2><span class="section-number">5.4. </span>Importance sampling<a class="headerlink" href="#importance-sampling" title="Permalink to this headline">¶</a></h2>
<p>We need to replace the brute force
Metropolis algorithm with a walk in coordinate space biased by the trial wave function.
This approach is based on the Fokker-Planck equation and the Langevin equation for generating a trajectory in coordinate space.  The link between the Fokker-Planck equation and the Langevin equations are explained, only partly, in the slides below.
An excellent reference on topics like Brownian motion, Markov chains, the Fokker-Planck equation and the Langevin equation is the text by  <a class="reference external" href="http://www.elsevier.com/books/stochastic-processes-in-physics-and-chemistry/van-kampen/978-0-444-52965-7">Van Kampen</a>
Here we will focus first on the implementation part first.</p>
<p>For a diffusion process characterized by a time-dependent probability density <span class="math notranslate nohighlight">\(P(x,t)\)</span> in one dimension the Fokker-Planck
equation reads (for one particle /walker)</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial P}{\partial t} = D\frac{\partial }{\partial x}\left(\frac{\partial }{\partial x} -F\right)P(x,t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is a drift term and <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient.</p>
<p>The new positions in coordinate space are given as the solutions of the Langevin equation using Euler’s method, namely,
we go from the Langevin equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial x(t)}{\partial t} = DF(x(t)) +\eta,
\]</div>
<p>with <span class="math notranslate nohighlight">\(\eta\)</span> a random variable,
yielding a new position</p>
<div class="math notranslate nohighlight">
\[
y = x+DF(x)\Delta t +\xi\sqrt{\Delta t},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\xi\)</span> is gaussian random variable and <span class="math notranslate nohighlight">\(\Delta t\)</span> is a chosen time step.
The quantity <span class="math notranslate nohighlight">\(D\)</span> is, in atomic units, equal to <span class="math notranslate nohighlight">\(1/2\)</span> and comes from the factor <span class="math notranslate nohighlight">\(1/2\)</span> in the kinetic energy operator. Note that <span class="math notranslate nohighlight">\(\Delta t\)</span> is to be viewed as a parameter. Values of <span class="math notranslate nohighlight">\(\Delta t \in [0.001,0.01]\)</span> yield in general rather stable values of the ground state energy.</p>
<p>The process of isotropic diffusion characterized by a time-dependent probability density <span class="math notranslate nohighlight">\(P(\mathbf{x},t)\)</span> obeys (as an approximation) the so-called Fokker-Planck equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial P}{\partial t} = \sum_i D\frac{\partial }{\partial \mathbf{x_i}}\left(\frac{\partial }{\partial \mathbf{x_i}} -\mathbf{F_i}\right)P(\mathbf{x},t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{F_i}\)</span> is the <span class="math notranslate nohighlight">\(i^{th}\)</span> component of the drift term (drift velocity) caused by an external potential, and <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient. The convergence to a stationary probability density can be obtained by setting the left hand side to zero. The resulting equation will be satisfied if and only if all the terms of the sum are equal zero,</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2 P}{\partial {\mathbf{x_i}^2}} = P\frac{\partial}{\partial {\mathbf{x_i}}}\mathbf{F_i} + \mathbf{F_i}\frac{\partial}{\partial {\mathbf{x_i}}}P.
\]</div>
<p>The drift vector should be of the form <span class="math notranslate nohighlight">\(\mathbf{F} = g(\mathbf{x}) \frac{\partial P}{\partial \mathbf{x}}\)</span>. Then,</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2 P}{\partial {\mathbf{x_i}^2}} = P\frac{\partial g}{\partial P}\left( \frac{\partial P}{\partial {\mathbf{x}_i}}  \right)^2 + P g \frac{\partial ^2 P}{\partial {\mathbf{x}_i^2}}  + g \left( \frac{\partial P}{\partial {\mathbf{x}_i}}  \right)^2.
\]</div>
<p>The condition of stationary density means that the left hand side equals zero. In other words, the terms containing first and second derivatives have to cancel each other. It is possible only if <span class="math notranslate nohighlight">\(g = \frac{1}{P}\)</span>, which yields</p>
<div class="math notranslate nohighlight">
\[
\mathbf{F} = 2\frac{1}{\Psi_T}\nabla\Psi_T,
\]</div>
<p>which is known as the so-called <em>quantum force</em>. This term is responsible for pushing the walker towards regions of configuration space where the trial wave function is large, increasing the efficiency of the simulation in contrast to the Metropolis algorithm where the walker has the same probability of moving in every direction.</p>
<p>The Fokker-Planck equation yields a (the solution to the equation) transition probability given by the Green’s function</p>
<div class="math notranslate nohighlight">
\[
G(y,x,\Delta t) = \frac{1}{(4\pi D\Delta t)^{3N/2}} \exp{\left(-(y-x-D\Delta t F(x))^2/4D\Delta t\right)}
\]</div>
<p>which in turn means that our brute force Metropolis algorithm</p>
<div class="math notranslate nohighlight">
\[
A(y,x) = \mathrm{min}(1,q(y,x))),
\]</div>
<p>with <span class="math notranslate nohighlight">\(q(y,x) = |\Psi_T(y)|^2/|\Psi_T(x)|^2\)</span> is now replaced by the <a class="reference external" href="http://scitation.aip.org/content/aip/journal/jcp/21/6/10.1063/1.1699114">Metropolis-Hastings algorithm</a> as well as <a class="reference external" href="http://biomet.oxfordjournals.org/content/57/1/97.abstract">Hasting’s article</a>,</p>
<div class="math notranslate nohighlight">
\[
q(y,x) = \frac{G(x,y,\Delta t)|\Psi_T(y)|^2}{G(y,x,\Delta t)|\Psi_T(x)|^2}
\]</div>
</div>
<div class="section" id="importance-sampling-program-elements">
<h2><span class="section-number">5.5. </span>Importance sampling, program elements<a class="headerlink" href="#importance-sampling-program-elements" title="Permalink to this headline">¶</a></h2>
<p>The general derivative formula of the Jastrow factor is (the subscript <span class="math notranslate nohighlight">\(C\)</span> stands for Correlation)</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_k}
\]</div>
<p>However,
with our written in way which can be reused later as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})= \exp{\left\{\sum_{i&lt;j}f(r_{ij})\right\}},
\]</div>
<p>the gradient needed for the quantum force and local energy is easy to compute.<br />
The function <span class="math notranslate nohighlight">\(f(r_{ij})\)</span> will depends on the system under study. In the equations below we will keep this general form.</p>
<p>In the Metropolis/Hasting algorithm, the <em>acceptance ratio</em> determines the probability for a particle  to be accepted at a new position. The ratio of the trial wave functions evaluated at the new and current positions is given by (<span class="math notranslate nohighlight">\(OB\)</span> for the onebody  part)</p>
<div class="math notranslate nohighlight">
\[
R \equiv \frac{\Psi_{T}^{new}}{\Psi_{T}^{old}} = 
\frac{\Psi_{OB}^{new}}{\Psi_{OB}^{old}}\frac{\Psi_{C}^{new}}{\Psi_{C}^{old}}
\]</div>
<p>Here <span class="math notranslate nohighlight">\(\Psi_{OB}\)</span> is our onebody part (Slater determinant or product of boson single-particle states)  while <span class="math notranslate nohighlight">\(\Psi_{C}\)</span> is our correlation function, or Jastrow factor.
We need to optimize the <span class="math notranslate nohighlight">\(\nabla \Psi_T / \Psi_T\)</span> ratio and the second derivative as well, that is
the <span class="math notranslate nohighlight">\(\mathbf{\nabla}^2 \Psi_T/\Psi_T\)</span> ratio. The first is needed when we compute the so-called quantum force in importance sampling.
The second is needed when we compute the kinetic energy term of the local energy.</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\mathbf{\nabla}}  \Psi}{\Psi}  = \frac{\mathbf{\nabla}  (\Psi_{OB} \, \Psi_{C})}{\Psi_{OB} \, \Psi_{C}}  =  \frac{ \Psi_C \mathbf{\nabla}  \Psi_{OB} + \Psi_{OB} \mathbf{\nabla}  \Psi_{C}}{\Psi_{OB} \Psi_{C}} = \frac{\mathbf{\nabla}  \Psi_{OB}}{\Psi_{OB}} + \frac{\mathbf{\nabla}   \Psi_C}{ \Psi_C}
\]</div>
<p>The expectation value of the kinetic energy expressed in atomic units for electron <span class="math notranslate nohighlight">\(i\)</span> is</p>
<div class="math notranslate nohighlight">
\[
\langle \hat{K}_i \rangle = -\frac{1}{2}\frac{\langle\Psi|\mathbf{\nabla}_{i}^2|\Psi \rangle}{\langle\Psi|\Psi \rangle},
\]</div>
<div class="math notranslate nohighlight">
\[
\hat{K}_i = -\frac{1}{2}\frac{\mathbf{\nabla}_{i}^{2} \Psi}{\Psi}.
\]</div>
<p>The second derivative which enters the definition of the local energy is</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}^2 \Psi}{\Psi}=\frac{\mathbf{\nabla}^2 \Psi_{OB}}{\Psi_{OB}} + \frac{\mathbf{\nabla}^2  \Psi_C}{ \Psi_C} + 2 \frac{\mathbf{\nabla}  \Psi_{OB}}{\Psi_{OB}}\cdot\frac{\mathbf{\nabla}   \Psi_C}{ \Psi_C}
\]</div>
<p>We discuss here how to calculate these quantities in an optimal way,</p>
<p>We have defined the correlated function as</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})=\prod_{i&lt; j}^Ng(r_{ij})= \prod_{i=1}^N\prod_{j=i+1}^Ng(r_{ij}),
\]</div>
<p>with
<span class="math notranslate nohighlight">\(r_{ij}=|\mathbf{r}_i-\mathbf{r}_j|=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}\)</span> in three dimensions or
<span class="math notranslate nohighlight">\(r_{ij}=|\mathbf{r}_i-\mathbf{r}_j|=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span> if we work with two-dimensional systems.</p>
<p>In our particular case we have</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})=\exp{\left\{\sum_{i&lt;j}f(r_{ij})\right\}}.
\]</div>
<p>The total number of different relative distances <span class="math notranslate nohighlight">\(r_{ij}\)</span> is <span class="math notranslate nohighlight">\(N(N-1)/2\)</span>. In a matrix storage format, the relative distances  form a strictly upper triangular matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{r} \equiv \begin{pmatrix}
  0 &amp; r_{1,2} &amp; r_{1,3} &amp; \cdots &amp; r_{1,N} \\
  \vdots &amp; 0       &amp; r_{2,3} &amp; \cdots &amp; r_{2,N} \\
  \vdots &amp; \vdots  &amp; 0  &amp; \ddots &amp; \vdots  \\
  \vdots &amp; \vdots  &amp; \vdots  &amp; \ddots  &amp; r_{N-1,N} \\
  0 &amp; 0  &amp; 0  &amp; \cdots  &amp; 0
 \end{pmatrix}.
\end{split}\]</div>
<p>This applies to  <span class="math notranslate nohighlight">\(\mathbf{g} = \mathbf{g}(r_{ij})\)</span> as well.</p>
<p>In our algorithm we will move one particle  at the time, say the <span class="math notranslate nohighlight">\(kth\)</span>-particle.  This sampling will be seen to be particularly efficient when we are going to compute a Slater determinant.</p>
<p>We have that the ratio between Jastrow factors <span class="math notranslate nohighlight">\(R_C\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
R_{C} = \frac{\Psi_{C}^\mathrm{new}}{\Psi_{C}^\mathrm{cur}} =
\prod_{i=1}^{k-1}\frac{g_{ik}^\mathrm{new}}{g_{ik}^\mathrm{cur}}
\prod_{i=k+1}^{N}\frac{ g_{ki}^\mathrm{new}} {g_{ki}^\mathrm{cur}}.
\]</div>
<p>For the Pade-Jastrow form</p>
<div class="math notranslate nohighlight">
\[
R_{C} = \frac{\Psi_{C}^\mathrm{new}}{\Psi_{C}^\mathrm{cur}} = 
\frac{\exp{U_{new}}}{\exp{U_{cur}}} = \exp{\Delta U},
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\Delta U =
\sum_{i=1}^{k-1}\big(f_{ik}^\mathrm{new}-f_{ik}^\mathrm{cur}\big)
+
\sum_{i=k+1}^{N}\big(f_{ki}^\mathrm{new}-f_{ki}^\mathrm{cur}\big)
\]</div>
<p>One needs to develop a special algorithm
that runs only through the elements of the upper triangular
matrix <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> and have <span class="math notranslate nohighlight">\(k\)</span> as an index.</p>
<p>The expression to be derived in the following is of interest when computing the quantum force and the kinetic energy. It has the form</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\Psi_C}{\Psi_C} = \frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_i},
\]</div>
<p>for all dimensions and with <span class="math notranslate nohighlight">\(i\)</span> running over all particles.</p>
<p>For the first derivative only <span class="math notranslate nohighlight">\(N-1\)</span> terms survive the ratio because the <span class="math notranslate nohighlight">\(g\)</span>-terms that are not differentiated cancel with their corresponding ones in the denominator. Then,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{1}{g_{ik}}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\partial g_{ki}}{\partial x_k}.
\]</div>
<p>An equivalent equation is obtained for the exponential form after replacing <span class="math notranslate nohighlight">\(g_{ij}\)</span> by <span class="math notranslate nohighlight">\(\exp(f_{ij})\)</span>, yielding:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
+
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_k},
\]</div>
<p>with both expressions scaling as <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>.</p>
<p>Using the identity</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial}{\partial x_i}g_{ij} = -\frac{\partial}{\partial x_j}g_{ij},
\]</div>
<p>we get expressions where all the derivatives acting on the particle  are represented by the <em>second</em> index of <span class="math notranslate nohighlight">\(g\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{1}{g_{ik}}\frac{\partial g_{ik}}{\partial x_k}
-\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\partial g_{ki}}{\partial x_i},
\]</div>
<p>and for the exponential case:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k}
-\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}.
\]</div>
<p>For correlation forms depending only on the scalar distances <span class="math notranslate nohighlight">\(r_{ij}\)</span> we can use the chain rule. Noting that</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial g_{ij}}{\partial x_j} = \frac{\partial g_{ij}}{\partial r_{ij}} \frac{\partial r_{ij}}{\partial x_j} = \frac{x_j - x_i}{r_{ij}} \frac{\partial g_{ij}}{\partial r_{ij}},
\]</div>
<p>we arrive at</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_C}\frac{\partial \Psi_C}{\partial x_k} = 
\sum_{i=1}^{k-1}\frac{1}{g_{ik}} \frac{\mathbf{r_{ik}}}{r_{ik}} \frac{\partial g_{ik}}{\partial r_{ik}}
-\sum_{i=k+1}^{N}\frac{1}{g_{ki}}\frac{\mathbf{r_{ki}}}{r_{ki}}\frac{\partial g_{ki}}{\partial r_{ki}}.
\]</div>
<p>Note that for the Pade-Jastrow form we can set <span class="math notranslate nohighlight">\(g_{ij} \equiv g(r_{ij}) = e^{f(r_{ij})} = e^{f_{ij}}\)</span> and</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial g_{ij}}{\partial r_{ij}} = g_{ij} \frac{\partial f_{ij}}{\partial r_{ij}}.
\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Psi_{C}}\frac{\partial \Psi_{C}}{\partial x_k} =
\sum_{i=1}^{k-1}\frac{\mathbf{r_{ik}}}{r_{ik}}\frac{\partial f_{ik}}{\partial r_{ik}}
-\sum_{i=k+1}^{N}\frac{\mathbf{r_{ki}}}{r_{ki}}\frac{\partial f_{ki}}{\partial r_{ki}},
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\mathbf{r}_{ij} = |\mathbf{r}_j - \mathbf{r}_i| = (x_j - x_i)\mathbf{e}_1 + (y_j - y_i)\mathbf{e}_2 + (z_j - z_i)\mathbf{e}_3
\]</div>
<p>is the relative distance.</p>
<p>The second derivative of the Jastrow factor divided by the Jastrow factor (the way it enters the kinetic energy) is</p>
<div class="math notranslate nohighlight">
\[
\left[\frac{\mathbf{\nabla}^2 \Psi_C}{\Psi_C}\right]_x =\  
2\sum_{k=1}^{N}
\sum_{i=1}^{k-1}\frac{\partial^2 g_{ik}}{\partial x_k^2}\ +\ 
\sum_{k=1}^N
\left(
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k} -
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}
\right)^2
\]</div>
<p>But we have a simple form for the function, namely</p>
<div class="math notranslate nohighlight">
\[
\Psi_{C}=\prod_{i&lt; j}\exp{f(r_{ij})},
\]</div>
<p>and it is easy to see that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}f'(r_{ki})f'(r_{kj})+
\sum_{j\ne k}\left( f''(r_{kj})+\frac{2}{r_{kj}}f'(r_{kj})\right)
\]</div>
</div>
<div class="section" id="importance-sampling-fokker-planck-and-langevin-equations">
<h2><span class="section-number">5.6. </span>Importance sampling, Fokker-Planck and Langevin equations<a class="headerlink" href="#importance-sampling-fokker-planck-and-langevin-equations" title="Permalink to this headline">¶</a></h2>
<p>A stochastic process is simply a function of two variables, one is the time,
the other is a stochastic variable <span class="math notranslate nohighlight">\(X\)</span>, defined by specifying</p>
<ul class="simple">
<li><p>the set <span class="math notranslate nohighlight">\(\left\{x\right\}\)</span> of possible values for <span class="math notranslate nohighlight">\(X\)</span>;</p></li>
<li><p>the probability distribution, <span class="math notranslate nohighlight">\(w_X(x)\)</span>,  over this set, or briefly <span class="math notranslate nohighlight">\(w(x)\)</span></p></li>
</ul>
<p>The set of values <span class="math notranslate nohighlight">\(\left\{x\right\}\)</span> for <span class="math notranslate nohighlight">\(X\)</span>
may be discrete, or continuous. If the set of
values is continuous, then <span class="math notranslate nohighlight">\(w_X (x)\)</span> is a probability density so that
<span class="math notranslate nohighlight">\(w_X (x)dx\)</span>
is the probability that one finds the stochastic variable <span class="math notranslate nohighlight">\(X\)</span> to have values
in the range <span class="math notranslate nohighlight">\([x, x + dx]\)</span> .</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> An arbitrary number of other stochastic variables may be derived from
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(X\)</span>. For example, any <span class="math notranslate nohighlight">\(Y\)</span> given by a mapping of <span class="math notranslate nohighlight">\(X\)</span>, is also a stochastic
variable. The mapping may also be time-dependent, that is, the mapping
depends on an additional variable <span class="math notranslate nohighlight">\(t\)</span></p>
<div class="math notranslate nohighlight">
\[
Y_X (t) = f (X, t) .
\]</div>
<p>The quantity <span class="math notranslate nohighlight">\(Y_X (t)\)</span> is called a random function, or, since <span class="math notranslate nohighlight">\(t\)</span> often is time,
a stochastic process. A stochastic process is a function of two variables,
one is the time, the other is a stochastic variable <span class="math notranslate nohighlight">\(X\)</span>. Let <span class="math notranslate nohighlight">\(x\)</span> be one of the
possible values of <span class="math notranslate nohighlight">\(X\)</span> then</p>
<div class="math notranslate nohighlight">
\[
y(t) = f (x, t),
\]</div>
<p>is a function of <span class="math notranslate nohighlight">\(t\)</span>, called a sample function or realization of the process.
In physics one considers the stochastic process to be an ensemble of such
sample functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> For many physical systems initial distributions of a stochastic 
</pre></div>
</div>
<p>variable <span class="math notranslate nohighlight">\(y\)</span> tend to equilibrium distributions: <span class="math notranslate nohighlight">\(w(y, t)\rightarrow w_0(y)\)</span>
as <span class="math notranslate nohighlight">\(t\rightarrow\infty\)</span>. In
equilibrium detailed balance constrains the transition rates</p>
<div class="math notranslate nohighlight">
\[
W(y\rightarrow y')w(y ) = W(y'\rightarrow y)w_0 (y),
\]</div>
<p>where <span class="math notranslate nohighlight">\(W(y'\rightarrow y)\)</span>
is the probability, per unit time, that the system changes
from a state <span class="math notranslate nohighlight">\(|y\rangle\)</span> , characterized by the value <span class="math notranslate nohighlight">\(y\)</span>
for the stochastic variable <span class="math notranslate nohighlight">\(Y\)</span> , to a state <span class="math notranslate nohighlight">\(|y'\rangle\)</span>.</p>
<p>Note that for a system in equilibrium the transition rate
<span class="math notranslate nohighlight">\(W(y'\rightarrow y)\)</span> and
the reverse <span class="math notranslate nohighlight">\(W(y\rightarrow y')\)</span> may be very different.</p>
<p>Consider, for instance, a simple
system that has only two energy levels <span class="math notranslate nohighlight">\(\epsilon_0 = 0\)</span> and
<span class="math notranslate nohighlight">\(\epsilon_1 = \Delta E\)</span>.</p>
<p>For a system governed by the Boltzmann distribution we find (the partition function has been taken out)</p>
<div class="math notranslate nohighlight">
\[
W(0\rightarrow 1)\exp{-(\epsilon_0/kT)} = W(1\rightarrow 0)\exp{-(\epsilon_1/kT)}
\]</div>
<p>We get then</p>
<div class="math notranslate nohighlight">
\[
\frac{W(1\rightarrow 0)}{W(0 \rightarrow 1)}=\exp{-(\Delta E/kT)},
\]</div>
<p>which goes to zero when <span class="math notranslate nohighlight">\(T\)</span> tends to zero.</p>
<p>If we assume a discrete set of events,
our initial probability
distribution function can be  given by</p>
<div class="math notranslate nohighlight">
\[
w_i(0) = \delta_{i,0},
\]</div>
<p>and its time-development after a given time step <span class="math notranslate nohighlight">\(\Delta t=\epsilon\)</span> is</p>
<div class="math notranslate nohighlight">
\[
w_i(t) = \sum_{j}W(j\rightarrow i)w_j(t=0).
\]</div>
<p>The continuous analog to <span class="math notranslate nohighlight">\(w_i(0)\)</span> is</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x})\rightarrow \delta(\mathbf{x}),
\]</div>
<p>where we now have generalized the one-dimensional position <span class="math notranslate nohighlight">\(x\)</span> to a generic-dimensional<br />
vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. The Kroenecker <span class="math notranslate nohighlight">\(\delta\)</span> function is replaced by the <span class="math notranslate nohighlight">\(\delta\)</span> distribution
function <span class="math notranslate nohighlight">\(\delta(\mathbf{x})\)</span> at  <span class="math notranslate nohighlight">\(t=0\)</span>.</p>
<p>The transition from a state <span class="math notranslate nohighlight">\(j\)</span> to a state <span class="math notranslate nohighlight">\(i\)</span> is now replaced by a transition
to a state with position <span class="math notranslate nohighlight">\(\mathbf{y}\)</span> from a state with position <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.
The discrete sum of transition probabilities can then be replaced by an integral
and we obtain the new distribution at a time <span class="math notranslate nohighlight">\(t+\Delta t\)</span> as</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y},t+\Delta t)= \int W(\mathbf{y},t+\Delta t| \mathbf{x},t)w(\mathbf{x},t)d\mathbf{x},
\]</div>
<p>and after <span class="math notranslate nohighlight">\(m\)</span> time steps we have</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y},t+m\Delta t)= \int W(\mathbf{y},t+m\Delta t| \mathbf{x},t)w(\mathbf{x},t)d\mathbf{x}.
\]</div>
<p>When equilibrium is reached we have</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{y})= \int W(\mathbf{y}|\mathbf{x}, t)w(\mathbf{x})d\mathbf{x},
\]</div>
<p>that is no time-dependence. Note our change of notation for <span class="math notranslate nohighlight">\(W\)</span></p>
<p>We can solve the equation for <span class="math notranslate nohighlight">\(w(\mathbf{y},t)\)</span> by making a Fourier transform to
momentum space.
The PDF <span class="math notranslate nohighlight">\(w(\mathbf{x},t)\)</span> is related to its Fourier transform
<span class="math notranslate nohighlight">\(\tilde{w}(\mathbf{k},t)\)</span> through</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t) = \int_{-\infty}^{\infty}d\mathbf{k} \exp{(i\mathbf{kx})}\tilde{w}(\mathbf{k},t),
\]</div>
<p>and using the definition of the
<span class="math notranslate nohighlight">\(\delta\)</span>-function</p>
<div class="math notranslate nohighlight">
\[
\delta(\mathbf{x}) = \frac{1}{2\pi} \int_{-\infty}^{\infty}d\mathbf{k} \exp{(i\mathbf{kx})},
\]</div>
<p>we see that</p>
<div class="math notranslate nohighlight">
\[
\tilde{w}(\mathbf{k},0)=1/2\pi.
\]</div>
<p>We can then use the Fourier-transformed diffusion equation</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \tilde{w}(\mathbf{k},t)}{\partial t} = -D\mathbf{k}^2\tilde{w}(\mathbf{k},t),
\]</div>
<p>with the obvious solution</p>
<div class="math notranslate nohighlight">
\[
\tilde{w}(\mathbf{k},t)=\tilde{w}(\mathbf{k},0)\exp{\left[-(D\mathbf{k}^2t)\right)}=
    \frac{1}{2\pi}\exp{\left[-(D\mathbf{k}^2t)\right]}.
\]</div>
<p>With the Fourier transform we obtain</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)=\int_{-\infty}^{\infty}d\mathbf{k} \exp{\left[i\mathbf{kx}\right]}\frac{1}{2\pi}\exp{\left[-(D\mathbf{k}^2t)\right]}=
    \frac{1}{\sqrt{4\pi Dt}}\exp{\left[-(\mathbf{x}^2/4Dt)\right]},
\]</div>
<p>with the normalization condition</p>
<div class="math notranslate nohighlight">
\[
\int_{-\infty}^{\infty}w(\mathbf{x},t)d\mathbf{x}=1.
\]</div>
<p>The solution represents the probability of finding
our random walker at position <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> at time <span class="math notranslate nohighlight">\(t\)</span> if the initial distribution
was placed at <span class="math notranslate nohighlight">\(\mathbf{x}=0\)</span> at <span class="math notranslate nohighlight">\(t=0\)</span>.</p>
<p>There is another interesting feature worth observing. The discrete transition probability <span class="math notranslate nohighlight">\(W\)</span>
itself is given by a binomial distribution.
The results from the central limit theorem state that
transition probability in the limit <span class="math notranslate nohighlight">\(n\rightarrow \infty\)</span> converges to the normal
distribution. It is then possible to show that</p>
<div class="math notranslate nohighlight">
\[
W(il-jl,n\epsilon)\rightarrow W(\mathbf{y},t+\Delta t|\mathbf{x},t)=
    \frac{1}{\sqrt{4\pi D\Delta t}}\exp{\left[-((\mathbf{y}-\mathbf{x})^2/4D\Delta t)\right]},
\]</div>
<p>and that it satisfies the normalization condition and is itself a solution
to the diffusion equation.</p>
<p>Let us now assume that we have three PDFs for times <span class="math notranslate nohighlight">\(t_0 &lt; t' &lt; t\)</span>, that is
<span class="math notranslate nohighlight">\(w(\mathbf{x}_0,t_0)\)</span>, <span class="math notranslate nohighlight">\(w(\mathbf{x}',t')\)</span> and <span class="math notranslate nohighlight">\(w(\mathbf{x},t)\)</span>.
We have then</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)= \int_{-\infty}^{\infty} W(\mathbf{x}.t|\mathbf{x}'.t')w(\mathbf{x}',t')d\mathbf{x}',
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x},t)= \int_{-\infty}^{\infty} W(\mathbf{x}.t|\mathbf{x}_0.t_0)w(\mathbf{x}_0,t_0)d\mathbf{x}_0,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
w(\mathbf{x}',t')= \int_{-\infty}^{\infty} W(\mathbf{x}'.t'|\mathbf{x}_0,t_0)w(\mathbf{x}_0,t_0)d\mathbf{x}_0.
\]</div>
<p>We can combine these equations and arrive at the famous Einstein-Smoluchenski-Kolmogorov-Chapman (ESKC) relation</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x}t|\mathbf{x}_0t_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},t|\mathbf{x}',t')W(\mathbf{x}',t'|\mathbf{x}_0,t_0)d\mathbf{x}'.
\]</div>
<p>We can replace the spatial dependence with a dependence upon say the velocity
(or momentum), that is we have</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{v},t|\mathbf{v}_0,t_0)  = \int_{-\infty}^{\infty} W(\mathbf{v},t|\mathbf{v}',t')W(\mathbf{v}',t'|\mathbf{v}_0,t_0)d\mathbf{x}'.
\]</div>
<p>We will now derive the Fokker-Planck equation.
We start from the ESKC equation</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},t|\mathbf{x}_0,t_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},t|\mathbf{x}',t')W(\mathbf{x}',t'|\mathbf{x}_0,t_0)d\mathbf{x}'.
\]</div>
<p>Define <span class="math notranslate nohighlight">\(s=t'-t_0\)</span>, <span class="math notranslate nohighlight">\(\tau=t-t'\)</span> and <span class="math notranslate nohighlight">\(t-t_0=s+\tau\)</span>. We have then</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},s+\tau|\mathbf{x}_0)  = \int_{-\infty}^{\infty} W(\mathbf{x},\tau|\mathbf{x}')W(\mathbf{x}',s|\mathbf{x}_0)d\mathbf{x}'.
\]</div>
<p>Assume now that <span class="math notranslate nohighlight">\(\tau\)</span> is very small so that we can make an expansion in terms of a small step <span class="math notranslate nohighlight">\(xi\)</span>, with <span class="math notranslate nohighlight">\(\mathbf{x}'=\mathbf{x}-\xi\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},s|\mathbf{x}_0)+\frac{\partial W}{\partial s}\tau +O(\tau^2) = \int_{-\infty}^{\infty} W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0)d\mathbf{x}'.
\]</div>
<p>We assume that <span class="math notranslate nohighlight">\(W(\mathbf{x},\tau|\mathbf{x}-\xi)\)</span> takes non-negligible values only when <span class="math notranslate nohighlight">\(\xi\)</span> is small. This is just another way of stating the Master equation!!</p>
<p>We say thus that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> changes only by a small amount in the time interval <span class="math notranslate nohighlight">\(\tau\)</span>.
This means that we can make a Taylor expansion in terms of <span class="math notranslate nohighlight">\(\xi\)</span>, that is we
expand</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0) =
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}\left[W(\mathbf{x}+\xi,\tau|\mathbf{x})W(\mathbf{x},s|\mathbf{x}_0)
\right].
\]</div>
<p>We can then rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W}{\partial s}\tau=-W(\mathbf{x},s|\mathbf{x}_0)+
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi\right].
\]</div>
<p>We have neglected higher powers of <span class="math notranslate nohighlight">\(\tau\)</span> and have used that for <span class="math notranslate nohighlight">\(n=0\)</span>
we get simply <span class="math notranslate nohighlight">\(W(\mathbf{x},s|\mathbf{x}_0)\)</span> due to normalization.</p>
<p>We say thus that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> changes only by a small amount in the time interval <span class="math notranslate nohighlight">\(\tau\)</span>.
This means that we can make a Taylor expansion in terms of <span class="math notranslate nohighlight">\(\xi\)</span>, that is we
expand</p>
<div class="math notranslate nohighlight">
\[
W(\mathbf{x},\tau|\mathbf{x}-\xi)W(\mathbf{x}-\xi,s|\mathbf{x}_0) =
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}\left[W(\mathbf{x}+\xi,\tau|\mathbf{x})W(\mathbf{x},s|\mathbf{x}_0)
\right].
\]</div>
<p>We can then rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}\tau=-W(\mathbf{x},s|\mathbf{x}_0)+
\sum_{n=0}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi\right].
\]</div>
<p>We have neglected higher powers of <span class="math notranslate nohighlight">\(\tau\)</span> and have used that for <span class="math notranslate nohighlight">\(n=0\)</span>
we get simply <span class="math notranslate nohighlight">\(W(\mathbf{x},s|\mathbf{x}_0)\)</span> due to normalization.</p>
<p>We simplify the above by introducing the moments</p>
<div class="math notranslate nohighlight">
\[
M_n=\frac{1}{\tau}\int_{-\infty}^{\infty} \xi^nW(\mathbf{x}+\xi,\tau|\mathbf{x})d\xi=
\frac{\langle [\Delta x(\tau)]^n\rangle}{\tau},
\]</div>
<p>resulting in</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}=
\sum_{n=1}^{\infty}\frac{(-\xi)^n}{n!}\frac{\partial^n}{\partial x^n}
\left[W(\mathbf{x},s|\mathbf{x}_0)M_n\right].
\]</div>
<p>When <span class="math notranslate nohighlight">\(\tau \rightarrow 0\)</span> we assume that <span class="math notranslate nohighlight">\(\langle [\Delta x(\tau)]^n\rangle \rightarrow 0\)</span> more rapidly than <span class="math notranslate nohighlight">\(\tau\)</span> itself if <span class="math notranslate nohighlight">\(n &gt; 2\)</span>.
When <span class="math notranslate nohighlight">\(\tau\)</span> is much larger than the standard correlation time of
system then <span class="math notranslate nohighlight">\(M_n\)</span> for <span class="math notranslate nohighlight">\(n &gt; 2\)</span> can normally be neglected.
This means that fluctuations become negligible at large time scales.</p>
<p>If we neglect such terms we can rewrite the ESKC equation as</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W(\mathbf{x},s|\mathbf{x}_0)}{\partial s}=
-\frac{\partial M_1W(\mathbf{x},s|\mathbf{x}_0)}{\partial x}+
\frac{1}{2}\frac{\partial^2 M_2W(\mathbf{x},s|\mathbf{x}_0)}{\partial x^2}.
\]</div>
<p>In a more compact form we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial W}{\partial s}=
-\frac{\partial M_1W}{\partial x}+
\frac{1}{2}\frac{\partial^2 M_2W}{\partial x^2},
\]</div>
<p>which is the Fokker-Planck equation!  It is trivial to replace
position with velocity (momentum).</p>
<p>Consider a particle  suspended in a liquid. On its path through the liquid it will continuously collide with the liquid molecules. Because on average the particle  will collide more often on the front side than on the back side, it will experience a systematic force proportional with its velocity, and directed opposite to its velocity. Besides this systematic force the particle  will experience a stochastic force  <span class="math notranslate nohighlight">\(\mathbf{F}(t)\)</span>.
The equations of motion are</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\frac{d\mathbf{r}}{dt}=\mathbf{v}\)</span> and</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{d\mathbf{v}}{dt}=-\xi \mathbf{v}+\mathbf{F}\)</span>.</p></li>
</ul>
<p>From hydrodynamics  we know that the friction constant  <span class="math notranslate nohighlight">\(\xi\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\xi =6\pi \eta a/m
\]</div>
<p>where <span class="math notranslate nohighlight">\(\eta\)</span> is the viscosity  of the solvent and a is the radius of the particle .</p>
<p>Solving the second equation in the previous slide we get</p>
<div class="math notranslate nohighlight">
\[
\mathbf{v}(t)=\mathbf{v}_{0}e^{-\xi t}+\int_{0}^{t}d\tau e^{-\xi (t-\tau )}\mathbf{F }(\tau ).
\]</div>
<p>If we want to get some useful information out of this, we have to average over all possible realizations of
<span class="math notranslate nohighlight">\(\mathbf{F}(t)\)</span>, with the initial velocity as a condition. A useful quantity for example is</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{v}(t)\cdot \mathbf{v}(t)\rangle_{\mathbf{v}_{0}}=v_{0}^{-\xi 2t}
+2\int_{0}^{t}d\tau e^{-\xi (2t-\tau)}\mathbf{v}_{0}\cdot \langle \mathbf{F}(\tau )\rangle_{\mathbf{v}_{0}}
\]</div>
<div class="math notranslate nohighlight">
\[
+\int_{0}^{t}d\tau ^{\prime }\int_{0}^{t}d\tau e^{-\xi (2t-\tau -\tau ^{\prime })}
\langle \mathbf{F}(\tau )\cdot \mathbf{F}(\tau ^{\prime })\rangle_{ \mathbf{v}_{0}}.
\]</div>
<p>In order to continue we have to make some assumptions about the conditional averages of the stochastic forces.
In view of the chaotic character of the stochastic forces the following
assumptions seem to be appropriate</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\rangle=0,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\cdot \mathbf{F}(t^{\prime })\rangle_{\mathbf{v}_{0}}=  C_{\mathbf{v}_{0}}\delta (t-t^{\prime }).
\]</div>
<p>We omit the subscript <span class="math notranslate nohighlight">\(\mathbf{v}_{0}\)</span>, when the quantity of interest turns out to be independent of <span class="math notranslate nohighlight">\(\mathbf{v}_{0}\)</span>. Using the last three equations we get</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{v}(t)\cdot \mathbf{v}(t)\rangle_{\mathbf{v}_{0}}=v_{0}^{2}e^{-2\xi t}+\frac{C_{\mathbf{v}_{0}}}{2\xi }(1-e^{-2\xi t}).
\]</div>
<p>For large t this should be equal to 3kT/m, from which it follows that</p>
<div class="math notranslate nohighlight">
\[
\langle \mathbf{F}(t)\cdot \mathbf{F}(t^{\prime })\rangle =6\frac{kT}{m}\xi \delta (t-t^{\prime }).
\]</div>
<p>This result is called the fluctuation-dissipation theorem .</p>
<p>Integrating</p>
<div class="math notranslate nohighlight">
\[
\mathbf{v}(t)=\mathbf{v}_{0}e^{-\xi t}+\int_{0}^{t}d\tau e^{-\xi (t-\tau )}\mathbf{F }(\tau ),
\]</div>
<p>we get</p>
<div class="math notranslate nohighlight">
\[
\mathbf{r}(t)=\mathbf{r}_{0}+\mathbf{v}_{0}\frac{1}{\xi }(1-e^{-\xi t})+
\int_0^td\tau \int_0^{\tau}\tau ^{\prime } e^{-\xi (\tau -\tau ^{\prime })}\mathbf{F}(\tau ^{\prime }),
\]</div>
<p>from which we calculate the mean square displacement</p>
<div class="math notranslate nohighlight">
\[
\langle ( \mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle _{\mathbf{v}_{0}}=\frac{v_0^2}{\xi}(1-e^{-\xi t})^{2}+\frac{3kT}{m\xi ^{2}}(2\xi t-3+4e^{-\xi t}-e^{-2\xi t}).
\]</div>
<p>For very large <span class="math notranslate nohighlight">\(t\)</span> this becomes</p>
<div class="math notranslate nohighlight">
\[
\langle (\mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle =\frac{6kT}{m\xi }t
\]</div>
<p>from which we get the Einstein relation</p>
<div class="math notranslate nohighlight">
\[
D= \frac{kT}{m\xi }
\]</div>
<p>where we have used <span class="math notranslate nohighlight">\(\langle (\mathbf{r}(t)-\mathbf{r}_{0})^{2}\rangle =6Dt\)</span>.</p>
</div>
<div class="section" id="code-example-for-two-electrons-in-a-quantum-dots">
<h2><span class="section-number">5.7. </span>Code example for two electrons in a quantum dots<a class="headerlink" href="#code-example-for-two-electrons-in-a-quantum-dots" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span class="c1"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span class="c1"># No energy minimization</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">normalvariate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span><span class="n">njit</span>


<span class="c1">#Read name of output file from command line</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">outfilename</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Error: Name of output file must be given as command line argument.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

<span class="c1"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="n">r12</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span><span class="o">+</span><span class="n">deno</span><span class="p">)</span>

<span class="c1"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">deno2</span> <span class="o">=</span> <span class="n">deno</span><span class="o">*</span><span class="n">deno</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="o">+</span><span class="n">deno2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">r12</span><span class="o">-</span><span class="n">deno2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">deno</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">r12</span><span class="p">)</span>

<span class="c1"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span class="k">def</span> <span class="nf">QuantumForce</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>

    <span class="n">qforce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">r12</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">deno</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span><span class="o">*</span><span class="n">deno</span><span class="o">*</span><span class="n">deno</span><span class="o">/</span><span class="n">r12</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span><span class="o">*</span><span class="n">deno</span><span class="o">*</span><span class="n">deno</span><span class="o">/</span><span class="n">r12</span>
    <span class="k">return</span> <span class="n">qforce</span>
    
<span class="c1"># The Monte Carlo sampling with the Metropolis algo</span>
<span class="c1"># jit decorator tells Numba to compile this function.</span>
<span class="c1"># The argument types will be inferred by Numba when function is called.</span>
<span class="nd">@jit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">MonteCarloSampling</span><span class="p">():</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">100000</span>
    <span class="c1"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TimeStep</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># Quantum force</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="c1"># seed for rng generator </span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="c1"># start variational parameter  loops, two parameters here</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="mf">.025</span>
        <span class="n">AlphaValues</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span> 
        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">+=</span> <span class="mf">.01</span>
            <span class="n">BetaValues</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1">#Initial position</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span>
            <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

            <span class="c1">#Loop over MC MCcycles</span>
            <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
                <span class="c1">#Trial position moving one particle at the time</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span><span class="o">+</span>\
                                           <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="n">D</span>
                    <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                    <span class="n">GreensFunction</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                        <span class="n">GreensFunction</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span>\
	                              <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">-</span>\
                                      <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
      
                    <span class="n">GreensFunction</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">GreensFunction</span><span class="p">)</span>
                    <span class="n">ProbabilityRatio</span> <span class="o">=</span> <span class="n">GreensFunction</span><span class="o">*</span><span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">wfold</span><span class="o">**</span><span class="mi">2</span>
                    <span class="c1">#Metropolis-Hastings test to see whether we accept the move</span>
                    <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ProbabilityRatio</span><span class="p">:</span>
                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                           <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                           <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                       <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
                <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
                <span class="n">energy2</span> <span class="o">+=</span> <span class="n">DeltaE</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1"># We calculate mean, variance and error (no blocking applied)</span>
            <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">energy2</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">energy2</span> <span class="o">-</span> <span class="n">energy</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="o">/</span><span class="n">NumberMCcycles</span><span class="p">)</span>
            <span class="n">Energies</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>    
            <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">energy</span><span class="p">,</span><span class="n">variance</span><span class="p">,</span><span class="n">error</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">MaxVariations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MaxVariations</span><span class="p">,</span><span class="n">MaxVariations</span><span class="p">))</span>
<span class="n">AlphaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="n">BetaValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MaxVariations</span><span class="p">)</span>
<span class="p">(</span><span class="n">Energies</span><span class="p">,</span> <span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span> <span class="o">=</span> <span class="n">MonteCarloSampling</span><span class="p">()</span>
<span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># Prepare for plots</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="c1"># Plot the surface.</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">AlphaValues</span><span class="p">,</span> <span class="n">BetaValues</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Energies</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Customize the z axis.</span>
<span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Energies</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\alpha$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\beta$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle E \rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">LinearLocator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.02f</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="c1"># Add a color bar which maps values to colors.</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bringing-the-gradient-optmization">
<h3><span class="section-number">5.7.1. </span>Bringing the gradient optmization<a class="headerlink" href="#bringing-the-gradient-optmization" title="Permalink to this headline">¶</a></h3>
<p>The simple one-particle case in a harmonic oscillator trap</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Gradient descent stepping with analytical derivative</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="k">def</span> <span class="nf">DerivativeE</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">def</span> <span class="nf">Energy</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Niterations</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Niterations</span><span class="p">):</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">DerivativeE</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">-=</span> <span class="n">eta</span><span class="o">*</span><span class="n">gradients</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span class="c1"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">normalvariate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>


<span class="c1"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span class="k">def</span> <span class="nf">WaveFunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">))</span>

<span class="c1"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span class="k">def</span> <span class="nf">LocalEnergy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">alpha</span>

<span class="c1"># Derivate of wave function ansatz as function of variational parameters</span>
<span class="k">def</span> <span class="nf">DerivativeWFansatz</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">WfDer</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">WfDer</span>

<span class="c1"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span class="k">def</span> <span class="nf">QuantumForce</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>

    <span class="n">qforce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span>
    <span class="n">qforce</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">alpha</span>
    <span class="k">return</span> <span class="n">qforce</span>
    
<span class="c1"># Computing the derivative of the energy and the energy </span>
<span class="c1"># jit decorator tells Numba to compile this function.</span>
<span class="c1"># The argument types will be inferred by Numba when function is called.</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">EnergyMinimization</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>

    <span class="n">NumberMCcycles</span><span class="o">=</span> <span class="mi">1000</span>
    <span class="c1"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TimeStep</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="c1"># positions</span>
    <span class="n">PositionOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">PositionNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># Quantum force</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NumberParticles</span><span class="p">,</span><span class="n">Dimension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="c1"># seed for rng generator </span>
    <span class="n">seed</span><span class="p">()</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DeltaE</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">EnergyDer</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DeltaPsi</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">DerivativePsiE</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1">#Initial position</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
            <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span>
    <span class="n">wfold</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">QuantumForceOld</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>

    <span class="c1">#Loop over MC MCcycles</span>
    <span class="k">for</span> <span class="n">MCcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberMCcycles</span><span class="p">):</span>
        <span class="c1">#Trial position moving one particle at the time</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumberParticles</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">normalvariate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TimeStep</span><span class="p">)</span><span class="o">+</span>\
                                       <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="n">D</span>
            <span class="n">wfnew</span> <span class="o">=</span> <span class="n">WaveFunction</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">QuantumForceNew</span> <span class="o">=</span> <span class="n">QuantumForce</span><span class="p">(</span><span class="n">PositionNew</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">GreensFunction</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                <span class="n">GreensFunction</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span>\
	                              <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">TimeStep</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">-</span>\
                                      <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
      
            <span class="n">GreensFunction</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">GreensFunction</span><span class="p">)</span>
            <span class="n">ProbabilityRatio</span> <span class="o">=</span> <span class="n">GreensFunction</span><span class="o">*</span><span class="n">wfnew</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">wfold</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#Metropolis-Hastings test to see whether we accept the move</span>
            <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ProbabilityRatio</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dimension</span><span class="p">):</span>
                    <span class="n">PositionOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PositionNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">QuantumForceOld</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantumForceNew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">wfold</span> <span class="o">=</span> <span class="n">wfnew</span>
        <span class="n">DeltaE</span> <span class="o">=</span> <span class="n">LocalEnergy</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">DeltaPsi</span> <span class="o">=</span> <span class="n">DerivativeWFansatz</span><span class="p">(</span><span class="n">PositionOld</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="n">DeltaE</span>
        <span class="n">DerivativePsiE</span> <span class="o">+=</span> <span class="n">DeltaPsi</span><span class="o">*</span><span class="n">DeltaE</span>
            
    <span class="c1"># We calculate mean, variance and error (no blocking applied)</span>
    <span class="n">energy</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">DerivativePsiE</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">DeltaPsi</span> <span class="o">/=</span> <span class="n">NumberMCcycles</span>
    <span class="n">EnergyDer</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">DerivativePsiE</span><span class="o">-</span><span class="n">DeltaPsi</span><span class="o">*</span><span class="n">energy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">energy</span><span class="p">,</span> <span class="n">EnergyDer</span>


<span class="c1">#Here starts the main program with variable declarations</span>
<span class="n">NumberParticles</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Dimension</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># guess for variational parameters</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="c1"># Set up iteration using stochastic gradient method</span>
<span class="n">Energy</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="n">EnergyMinimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span><span class="p">)</span>

<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">Niterations</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Niterations</span><span class="p">):</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">EnergyDer</span>
    <span class="n">x0</span> <span class="o">-=</span> <span class="n">eta</span><span class="o">*</span><span class="n">gradients</span>
    <span class="n">Energy</span><span class="p">,</span> <span class="n">EnergyDer</span> <span class="o">=</span> <span class="n">EnergyMinimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="vmc-for-fermions-efficient-calculation-of-slater-determinants">
<h2><span class="section-number">5.8. </span>VMC for fermions: Efficient calculation of Slater determinants<a class="headerlink" href="#vmc-for-fermions-efficient-calculation-of-slater-determinants" title="Permalink to this headline">¶</a></h2>
<p>The potentially most time-consuming part is the
evaluation of the gradient and the Laplacian of an <span class="math notranslate nohighlight">\(N\)</span>-particle  Slater
determinant.</p>
<p>We have to differentiate the determinant with respect to
all spatial coordinates of all particles. A brute force
differentiation would involve <span class="math notranslate nohighlight">\(N\cdot d\)</span> evaluations of the entire
determinant which would even worsen the already undesirable time
scaling, making it <span class="math notranslate nohighlight">\(Nd\cdot O(N^3)\sim O(d\cdot N^4)\)</span>.</p>
<p>This poses serious hindrances to the overall efficiency of our code.</p>
<p>The efficiency can be improved however if we move only one electron at the time.
The Slater determinant matrix <span class="math notranslate nohighlight">\(\hat{D}\)</span> is defined by the matrix elements</p>
<div class="math notranslate nohighlight">
\[
d_{ij}=\phi_j(x_i)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_j(\mathbf{r}_i)\)</span> is a single particle  wave function.
The columns correspond to the position of a given particle
while the rows stand for the various quantum numbers.</p>
<p>What we need to realize is that when differentiating a Slater
determinant with respect to some given coordinate, only one row of the
corresponding Slater matrix is changed.</p>
<p>Therefore, by recalculating
the whole determinant we risk producing redundant information. The
solution turns out to be an algorithm that requires to keep track of
the <em>inverse</em> of the Slater matrix.</p>
<p>Let the current position in phase space be represented by the <span class="math notranslate nohighlight">\((N\cdot d)\)</span>-element
vector <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{old}}\)</span> and the new suggested
position by the vector <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span>.</p>
<p>The inverse of <span class="math notranslate nohighlight">\(\hat{D}\)</span> can be expressed in terms of its
cofactors <span class="math notranslate nohighlight">\(C_{ij}\)</span> and its determinant (this our notation for a determinant) <span class="math notranslate nohighlight">\(\vert\hat{D}\vert\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_cofactor"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
d_{ij}^{-1} = \frac{C_{ji}}{\vert\hat{D}\vert}
\label{eq:inverse_cofactor} \tag{12}
\end{equation}
\]</div>
<p>Notice that the interchanged indices indicate that the matrix of cofactors is to be transposed.</p>
<p>If <span class="math notranslate nohighlight">\(\hat{D}\)</span> is invertible, then we must obviously have <span class="math notranslate nohighlight">\(\hat{D}^{-1}\hat{D}= \mathbf{1}\)</span>, or explicitly in terms of the individual
elements of <span class="math notranslate nohighlight">\(\hat{D}\)</span> and <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:unity_explicitely"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{k=1}^N d_{ik}^{\phantom X}d_{kj}^{-1} = \delta_{ij}^{\phantom X}
\label{eq:unity_explicitely} \tag{13}
\end{equation}
\]</div>
<p>Consider the ratio, which we shall call <span class="math notranslate nohighlight">\(R\)</span>, between <span class="math notranslate nohighlight">\(\vert\hat{D}(\mathbf{r}^{\mathrm{new}})\vert\)</span> and <span class="math notranslate nohighlight">\(\vert\hat{D}(\mathbf{r}^{\mathrm{old}})\vert\)</span>.
By definition, each of these determinants can
individually be expressed in terms of the <em>i</em>-th row of its cofactor
matrix</p>
<!-- Equation labels as ordinary links -->
<div id="eq:detratio_cofactors"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R\equiv\frac{\vert\hat{D}(\mathbf{r}^{\mathrm{new}})\vert}
{\vert\hat{D}(\mathbf{r}^{\mathrm{old}})\vert} =
\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
C_{ij}(\mathbf{r}^{\mathrm{new}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})}
\label{eq:detratio_cofactors} \tag{14}
\end{equation}
\]</div>
<p>Suppose now that we move only one particle  at a time, meaning that
<span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span> differs from <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{old}}\)</span> by the
position of only one, say the <em>i</em>-th, particle . This means that <span class="math notranslate nohighlight">\(\hat{D}(\mathbf{r}^{\mathrm{new}})\)</span> and <span class="math notranslate nohighlight">\(\hat{D}(\mathbf{r}^{\mathrm{old}})\)</span> differ
only by the entries of the <em>i</em>-th row.  Recall also that the <em>i</em>-th row
of a cofactor matrix <span class="math notranslate nohighlight">\(\hat{C}\)</span> is independent of the entries of the
<em>i</em>-th row of its corresponding matrix <span class="math notranslate nohighlight">\(\hat{D}\)</span>. In this particular
case we therefore get that the <em>i</em>-th row of <span class="math notranslate nohighlight">\(\hat{C}(\mathbf{r}^{\mathrm{new}})\)</span>
and <span class="math notranslate nohighlight">\(\hat{C}(\mathbf{r}^{\mathrm{old}})\)</span> must be
equal. Explicitly, we have:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
C_{ij}(\mathbf{r}^{\mathrm{new}}) = C_{ij}(\mathbf{r}^{\mathrm{old}})\quad
\forall\ j\in\{1,\dots,N\}
\label{_auto5} \tag{15}
\end{equation}
\]</div>
<p>Inserting this into the numerator of eq. (<a class="reference external" href="#eq:detratio_cofactors">14</a>)
and using eq. (<a class="reference external" href="#eq:inverse_cofactor">12</a>) to substitute the cofactors
with the elements of the inverse matrix, we get:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R =\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
C_{ij}(\mathbf{r}^{\mathrm{old}})} =
\frac{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})}
{\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{old}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})}
\label{_auto6} \tag{16}
\end{equation}
\]</div>
<p>Now by eq. (<a class="reference external" href="#eq:unity_explicitely">13</a>) the denominator of the rightmost
expression must be unity, so that we finally arrive at:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:detratio_inverse"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
R =
\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}}) = 
\sum_{j=1}^N \phi_j(\mathbf{r}_i^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})
\label{eq:detratio_inverse} \tag{17}
\end{equation}
\]</div>
<p>What this means is that in order to get the ratio when only the <em>i</em>-th
particle  has been moved, we only need to calculate the dot
product of the vector <span class="math notranslate nohighlight">\(\left(\phi_1(\mathbf{r}_i^\mathrm{new}),\,\dots,\,\phi_N(\mathbf{r}_i^\mathrm{new})\right)\)</span> of single particle  wave functions
evaluated at this new position with the <em>i</em>-th column of the inverse
matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> evaluated at the original position. Such
an operation has a time scaling of <span class="math notranslate nohighlight">\(O(N)\)</span>. The only extra thing we
need to do is to maintain the inverse matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{x}^{\mathrm{old}})\)</span>.</p>
<p>If the new position <span class="math notranslate nohighlight">\(\mathbf{r}^{\mathrm{new}}\)</span> is accepted, then the
inverse matrix can by suitably updated by an algorithm having a time
scaling of <span class="math notranslate nohighlight">\(O(N^2)\)</span>.  This algorithm goes as
follows. First we update all but the <em>i</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span>. For each column <span class="math notranslate nohighlight">\(j\neq i\)</span>, we first calculate the quantity:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
S_j =
(\hat{D}(\mathbf{r}^{\mathrm{new}})\times
\hat{D}^{-1}(\mathbf{r}^{\mathrm{old}}))_{ij} =
\sum_{l=1}^N d_{il}(\mathbf{r}^{\mathrm{new}})\,
d^{-1}_{lj}(\mathbf{r}^{\mathrm{old}})
\label{eq:inverse_update_1} \tag{18}
\end{equation}
\]</div>
<p>The new elements of the <em>j</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> are then given
by:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_2"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
d_{kj}^{-1}(\mathbf{r}^{\mathrm{new}}) =
d_{kj}^{-1}(\mathbf{r}^{\mathrm{old}}) -
\frac{S_j}{R}\,d_{ki}^{-1}(\mathbf{r}^{\mathrm{old}})\quad
\begin{array}{ll}
\forall\ \ k\in\{1,\dots,N\}\\j\neq i
\end{array}
\label{eq:inverse_update_2} \tag{19}
\end{equation}
\end{split}\]</div>
<p>Finally the elements of the <em>i</em>-th column of <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> are updated
simply as follows:</p>
<!-- Equation labels as ordinary links -->
<div id="eq:inverse_update_3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
d_{ki}^{-1}(\mathbf{r}^{\mathrm{new}}) =
\frac{1}{R}\,d_{ki}^{-1}(\mathbf{r}^{\mathrm{old}})\quad
\forall\ \ k\in\{1,\dots,N\}
\label{eq:inverse_update_3} \tag{20}
\end{equation}
\]</div>
<p>We see from these formulas that the time scaling of an update of
<span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> after changing one row of <span class="math notranslate nohighlight">\(\hat{D}\)</span> is <span class="math notranslate nohighlight">\(O(N^2)\)</span>.</p>
<p>The scheme is also applicable for the calculation of the ratios
involving derivatives. It turns
out that differentiating the Slater determinant with respect
to the coordinates of a single particle  <span class="math notranslate nohighlight">\(\mathbf{r}_i\)</span> changes only the
<em>i</em>-th row of the corresponding Slater matrix.</p>
<div class="section" id="the-gradient-and-the-laplacian">
<h3><span class="section-number">5.8.1. </span>The gradient and the Laplacian<a class="headerlink" href="#the-gradient-and-the-laplacian" title="Permalink to this headline">¶</a></h3>
<p>The gradient and the Laplacian can therefore be calculated as follows:</p>
<div class="math notranslate nohighlight">
\[
\frac{\vec\nabla_i\vert\hat{D}(\mathbf{r})\vert}{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \vec\nabla_i d_{ij}(\mathbf{r})d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \vec\nabla_i \phi_j(\mathbf{r}_i)d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_i\vert\hat{D}(\mathbf{r})\vert}{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \nabla^2_i d_{ij}(\mathbf{r})d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \nabla^2_i \phi_j(\mathbf{r}_i)\,d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>Thus, to calculate all the derivatives of the Slater determinant, we
only need the derivatives of the single particle  wave functions
(<span class="math notranslate nohighlight">\(\vec\nabla_i \phi_j(\mathbf{r}_i)\)</span> and <span class="math notranslate nohighlight">\(\nabla^2_i \phi_j(\mathbf{r}_i)\)</span>)
and the elements of the corresponding inverse Slater matrix (<span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{r}_i)\)</span>). A calculation of a single derivative is by the
above result an <span class="math notranslate nohighlight">\(O(N)\)</span> operation. Since there are <span class="math notranslate nohighlight">\(d\cdot N\)</span>
derivatives, the time scaling of the total evaluation becomes
<span class="math notranslate nohighlight">\(O(d\cdot N^2)\)</span>. With an <span class="math notranslate nohighlight">\(O(N^2)\)</span> updating algorithm for the
inverse matrix, the total scaling is no worse, which is far better
than the brute force approach yielding <span class="math notranslate nohighlight">\(O(d\cdot N^4)\)</span>.</p>
<p><strong>Important note</strong>: In most cases you end with closed form expressions for the single-particle  wave functions. It is then useful to calculate the various derivatives and make separate functions
for them.</p>
<p>The Slater determinant takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Phi(\mathbf{r}_1,\mathbf{r}_2,,\mathbf{r}_3,\mathbf{r}_4, \alpha,\beta,\gamma,\delta)=\frac{1}{\sqrt{4!}}
\left| \begin{array}{cccc} \psi_{100\uparrow}(\mathbf{r}_1)&amp; \psi_{100\uparrow}(\mathbf{r}_2)&amp; \psi_{100\uparrow}(\mathbf{r}_3)&amp;\psi_{100\uparrow}(\mathbf{r}_4) \\
\psi_{100\downarrow}(\mathbf{r}_1)&amp; \psi_{100\downarrow}(\mathbf{r}_2)&amp; \psi_{100\downarrow}(\mathbf{r}_3)&amp;\psi_{100\downarrow}(\mathbf{r}_4) \\
\psi_{200\uparrow}(\mathbf{r}_1)&amp; \psi_{200\uparrow}(\mathbf{r}_2)&amp; \psi_{200\uparrow}(\mathbf{r}_3)&amp;\psi_{200\uparrow}(\mathbf{r}_4) \\
\psi_{200\downarrow}(\mathbf{r}_1)&amp; \psi_{200\downarrow}(\mathbf{r}_2)&amp; \psi_{200\downarrow}(\mathbf{r}_3)&amp;\psi_{200\downarrow}(\mathbf{r}_4) \end{array} \right|.
\end{split}\]</div>
<p>The Slater determinant as written is zero since the spatial wave functions for the spin up and spin down
states are equal.<br />
But we can rewrite it as the product of two Slater determinants, one for spin up and one for spin down.</p>
<p>We can rewrite it as</p>
<div class="math notranslate nohighlight">
\[
\Phi(\mathbf{r}_1,\mathbf{r}_2,,\mathbf{r}_3,\mathbf{r}_4, \alpha,\beta,\gamma,\delta)=\det\uparrow(1,2)\det\downarrow(3,4)-\det\uparrow(1,3)\det\downarrow(2,4)
\]</div>
<div class="math notranslate nohighlight">
\[
-\det\uparrow(1,4)\det\downarrow(3,2)+\det\uparrow(2,3)\det\downarrow(1,4)-\det\uparrow(2,4)\det\downarrow(1,3)
\]</div>
<div class="math notranslate nohighlight">
\[
+\det\uparrow(3,4)\det\downarrow(1,2),
\]</div>
<p>where we have defined</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\det\uparrow(1,2)=\frac{1}{\sqrt{2}}\left| \begin{array}{cc} \psi_{100\uparrow}(\mathbf{r}_1)&amp; \psi_{100\uparrow}(\mathbf{r}_2)\\
\psi_{200\uparrow}(\mathbf{r}_1)&amp; \psi_{200\uparrow}(\mathbf{r}_2) \end{array} \right|,
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\det\downarrow(3,4)=\frac{1}{\sqrt{2}}\left| \begin{array}{cc} \psi_{100\downarrow}(\mathbf{r}_3)&amp; \psi_{100\downarrow}(\mathbf{r}_4)\\
\psi_{200\downarrow}(\mathbf{r}_3)&amp; \psi_{200\downarrow}(\mathbf{r}_4) \end{array} \right|.
\end{split}\]</div>
<p>We want to avoid to sum over spin variables, in particular when the interaction does not depend on spin.</p>
<p>It can be shown, see for example Moskowitz and Kalos, <a class="reference external" href="http://onlinelibrary.wiley.com/doi/10.1002/qua.560200508/abstract">Int. J. Quantum Chem. <strong>20</strong> 1107 (1981)</a>, that for the variational energy
we can approximate the Slater determinant as</p>
<div class="math notranslate nohighlight">
\[
\Phi(\mathbf{r}_1,\mathbf{r}_2,,\mathbf{r}_3,\mathbf{r}_4, \alpha,\beta,\gamma,\delta) \propto \det\uparrow(1,2)\det\downarrow(3,4),
\]</div>
<p>or more generally as</p>
<div class="math notranslate nohighlight">
\[
\Phi(\mathbf{r}_1,\mathbf{r}_2,\dots \mathbf{r}_N) \propto \det\uparrow \det\downarrow,
\]</div>
<p>where we have the Slater determinant as the product of a spin up part involving the number of electrons with spin up only (2 for beryllium and 5 for neon) and a spin down part involving the electrons with spin down.</p>
<p>This ansatz is not antisymmetric under the exchange of electrons with  opposite spins but it can be shown (show this) that it gives the same
expectation value for the energy as the full Slater determinant.</p>
<p>As long as the Hamiltonian is spin independent, the above is correct. It is rather straightforward to see this if you go back to the equations for the energy discussed earlier  this semester.</p>
<p>We will thus
factorize the full determinant <span class="math notranslate nohighlight">\(\vert\hat{D}\vert\)</span> into two smaller ones, where
each can be identified with <span class="math notranslate nohighlight">\(\uparrow\)</span> and <span class="math notranslate nohighlight">\(\downarrow\)</span>
respectively:</p>
<div class="math notranslate nohighlight">
\[
\vert\hat{D}\vert = \vert\hat{D}\vert_\uparrow\cdot \vert\hat{D}\vert_\downarrow
\]</div>
<p>The combined dimensionality of the two smaller determinants equals the
dimensionality of the full determinant. Such a factorization is
advantageous in that it makes it possible to perform the calculation
of the ratio <span class="math notranslate nohighlight">\(R\)</span> and the updating of the inverse matrix separately for
<span class="math notranslate nohighlight">\(\vert\hat{D}\vert_\uparrow\)</span> and <span class="math notranslate nohighlight">\(\vert\hat{D}\vert_\downarrow\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\vert\hat{D}\vert^\mathrm{new}}{\vert\hat{D}\vert^\mathrm{old}} =
\frac{\vert\hat{D}\vert^\mathrm{new}_\uparrow}
{\vert\hat{D}\vert^\mathrm{old}_\uparrow}\cdot
\frac{\vert\hat{D}\vert^\mathrm{new}_\downarrow
}{\vert\hat{D}\vert^\mathrm{old}_\downarrow}
\]</div>
<p>This reduces the calculation time by a constant factor. The maximal
time reduction happens in a system of equal numbers of <span class="math notranslate nohighlight">\(\uparrow\)</span> and
<span class="math notranslate nohighlight">\(\downarrow\)</span> particles, so that the two factorized determinants are
half the size of the original one.</p>
<p>Consider the case of moving only one particle  at a time which
originally had the following time scaling for one transition:</p>
<div class="math notranslate nohighlight">
\[
O_R(N)+O_\mathrm{inverse}(N^2)
\]</div>
<p>For the factorized determinants one of the two determinants is
obviously unaffected by the change so that it cancels from the ratio
<span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>Therefore, only one determinant of size <span class="math notranslate nohighlight">\(N/2\)</span> is involved in each
calculation of <span class="math notranslate nohighlight">\(R\)</span> and update of the inverse matrix. The scaling of
each transition then becomes:</p>
<div class="math notranslate nohighlight">
\[
O_R(N/2)+O_\mathrm{inverse}(N^2/4)
\]</div>
<p>and the time scaling when the transitions for all <span class="math notranslate nohighlight">\(N\)</span> particles are
put together:</p>
<div class="math notranslate nohighlight">
\[
O_R(N^2/2)+O_\mathrm{inverse}(N^3/4)
\]</div>
<p>which gives the same reduction as in the case of moving all particles
at once.</p>
<p>Computing the ratios discussed above requires that we maintain
the inverse of the Slater matrix evaluated at the current position.
Each time a trial position is accepted, the row number <span class="math notranslate nohighlight">\(i\)</span> of the Slater
matrix changes and updating its inverse has to be carried out.
Getting the inverse of an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix by Gaussian elimination has a
complexity of order of <span class="math notranslate nohighlight">\(\mathcal{O}(N^3)\)</span> operations, a luxury that we
cannot afford for each time a particle  move is accepted.
We will use the expression</p>
<!-- Equation labels as ordinary links -->
<div id="updatingInverse"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\label{updatingInverse} \tag{21}
d^{-1}_{kj}(\mathbf{x^{new}}) = \left\{\begin{array}{l l}
  d^{-1}_{kj}(\mathbf{x^{old}}) - \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{new}})  d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j \neq i$}\nonumber \\ \\
 \frac{d^{-1}_{ki}(\mathbf{x^{old}})}{R} \sum_{l=1}^{N} d_{il}(\mathbf{x^{old}}) d^{-1}_{lj}(\mathbf{x^{old}}) &amp; \mbox{if $j=i$}
\end{array} \right.
\end{split}\]</div>
<p>This equation scales as <span class="math notranslate nohighlight">\(O(N^2)\)</span>.
The evaluation of the determinant of an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix by standard Gaussian elimination
requires <span class="math notranslate nohighlight">\(\mathbf{O}(N^3)\)</span>
calculations.
As there are <span class="math notranslate nohighlight">\(Nd\)</span> independent coordinates we need to evaluate <span class="math notranslate nohighlight">\(Nd\)</span> Slater determinants
for the gradient (quantum force) and <span class="math notranslate nohighlight">\(Nd\)</span> for the Laplacian (kinetic energy).
With the updating algorithm we need only to invert the Slater
determinant matrix once. This can be done by standard LU decomposition methods.</p>
</div>
<div class="section" id="expectation-value-of-the-kinetic-energy">
<h3><span class="section-number">5.8.2. </span>Expectation value of the kinetic energy<a class="headerlink" href="#expectation-value-of-the-kinetic-energy" title="Permalink to this headline">¶</a></h3>
<p>The expectation value of the kinetic energy expressed in atomic units for electron <span class="math notranslate nohighlight">\(i\)</span> is</p>
<div class="math notranslate nohighlight">
\[
\langle \hat{K}_i \rangle = -\frac{1}{2}\frac{\langle\Psi|\nabla_{i}^2|\Psi \rangle}{\langle\Psi|\Psi \rangle},
\]</div>
<!-- Equation labels as ordinary links -->
<div id="kineticE"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{kineticE} \tag{22}
K_i = -\frac{1}{2}\frac{\nabla_{i}^{2} \Psi}{\Psi}.
\end{equation}
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2 \Psi}{\Psi}  =  \frac{\nabla^2 ({\Psi_{D} \,  \Psi_C})}{\Psi_{D} \,  \Psi_C} = \frac{\nabla  \cdot [\nabla  {(\Psi_{D} \,  \Psi_C)}]}{\Psi_{D} \,  \Psi_C} = \frac{\nabla  \cdot [ \Psi_C \nabla  \Psi_{D} + \Psi_{D} \nabla   \Psi_C]}{\Psi_{D} \,  \Psi_C}\nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
=  \frac{\nabla   \Psi_C \cdot \nabla  \Psi_{D} +  \Psi_C \nabla^2 \Psi_{D} + \nabla  \Psi_{D} \cdot \nabla   \Psi_C + \Psi_{D} \nabla^2  \Psi_C}{\Psi_{D} \,  \Psi_C}\nonumber
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto7"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\label{_auto7} \tag{23}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\nabla^2 \Psi}{\Psi}
 =  \frac{\nabla^2 \Psi_{D}}{\Psi_{D}} + \frac{\nabla^2  \Psi_C}{ \Psi_C} + 2 \frac{\nabla  \Psi_{D}}{\Psi_{D}}\cdot\frac{\nabla   \Psi_C}{ \Psi_C}
\label{_auto8} \tag{24}
\end{equation}
\]</div>
<p>The second derivative of the Jastrow factor divided by the Jastrow factor (the way it enters the kinetic energy) is</p>
<div class="math notranslate nohighlight">
\[
\left[\frac{\nabla^2 \Psi_C}{\Psi_C}\right]_x =\  
2\sum_{k=1}^{N}
\sum_{i=1}^{k-1}\frac{\partial^2 g_{ik}}{\partial x_k^2}\ +\ 
\sum_{k=1}^N
\left(
\sum_{i=1}^{k-1}\frac{\partial g_{ik}}{\partial x_k} -
\sum_{i=k+1}^{N}\frac{\partial g_{ki}}{\partial x_i}
\right)^2
\]</div>
<p>But we have a simple form for the function, namely</p>
<div class="math notranslate nohighlight">
\[
\Psi_{C}=\prod_{i&lt; j}\exp{f(r_{ij})}= \exp{\left\{\sum_{i&lt;j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>and it is easy to see that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}f'(r_{ki})f'(r_{kj})+
\sum_{j\ne k}\left( f''(r_{kj})+\frac{2}{r_{kj}}f'(r_{kj})\right)
\]</div>
<p>Using</p>
<div class="math notranslate nohighlight">
\[
f(r_{ij})= \frac{ar_{ij}}{1+\beta r_{ij}},
\]</div>
<p>and <span class="math notranslate nohighlight">\(g'(r_{kj})=dg(r_{kj})/dr_{kj}\)</span> and
<span class="math notranslate nohighlight">\(g''(r_{kj})=d^2g(r_{kj})/dr_{kj}^2\)</span>  we find that for particle  <span class="math notranslate nohighlight">\(k\)</span>
we have</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_k \Psi_C}{\Psi_C }=
\sum_{ij\ne k}\frac{(\mathbf{r}_k-\mathbf{r}_i)(\mathbf{r}_k-\mathbf{r}_j)}{r_{ki}r_{kj}}\frac{a}{(1+\beta r_{ki})^2}
\frac{a}{(1+\beta r_{kj})^2}+
\sum_{j\ne k}\left(\frac{2a}{r_{kj}(1+\beta r_{kj})^2}-\frac{2a\beta}{(1+\beta r_{kj})^3}\right)
\]</div>
<p>The gradient and
Laplacian can be calculated as follows:</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \vec\nabla_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \vec\nabla_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\frac{\nabla^2_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \nabla^2_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \nabla^2_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r})
\]</div>
<p>The gradient for the determinant is</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{\nabla}_i\vert\hat{D}(\mathbf{r})\vert}
{\vert\hat{D}(\mathbf{r})\vert} =
\sum_{j=1}^N \mathbf{\nabla}_i d_{ij}(\mathbf{r})\,
d_{ji}^{-1}(\mathbf{r}) =
\sum_{j=1}^N \mathbf{\nabla}_i \phi_j(\mathbf{r}_i)\,
d_{ji}^{-1}(\mathbf{r}).
\]</div>
<p>We have</p>
<div class="math notranslate nohighlight">
\[
\Psi_C=\prod_{i&lt; j}g(r_{ij})= \exp{\left\{\sum_{i&lt;j}\frac{ar_{ij}}{1+\beta r_{ij}}\right\}},
\]</div>
<p>the gradient needed for the quantum force and local energy is easy to compute.<br />
We get for particle  <span class="math notranslate nohighlight">\(k\)</span></p>
<div class="math notranslate nohighlight">
\[
\frac{ \nabla_k \Psi_C}{ \Psi_C }= \sum_{j\ne k}\frac{\mathbf{r}_{kj}}{r_{kj}}\frac{a}{(1+\beta r_{kj})^2},
\]</div>
<p>which is rather easy to code.  Remember to sum over all particles  when you compute the local energy.</p>
<p>We need to compute the ratio between wave functions, in particular  for the Slater determinants.</p>
<div class="math notranslate nohighlight">
\[
R =\sum_{j=1}^N d_{ij}(\mathbf{r}^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}}) = 
\sum_{j=1}^N \phi_j(\mathbf{r}_i^{\mathrm{new}})\,
d_{ji}^{-1}(\mathbf{r}^{\mathrm{old}})
\]</div>
<p>What this means is that in order to get the ratio when only the <em>i</em>-th
particle  has been moved, we only need to calculate the dot
product of the vector <span class="math notranslate nohighlight">\(\left(\phi_1(\mathbf{r}_i^\mathrm{new}),\,\dots,\,
\phi_N(\mathbf{r}_i^\mathrm{new})\right)\)</span> of single particle  wave functions
evaluated at this new position with the <em>i</em>-th column of the inverse
matrix <span class="math notranslate nohighlight">\(\hat{D}^{-1}\)</span> evaluated at the original position. Such
an operation has a time scaling of <span class="math notranslate nohighlight">\(O(N)\)</span>. The only extra thing we
need to do is to maintain the inverse matrix
<span class="math notranslate nohighlight">\(\hat{D}^{-1}(\mathbf{x}^{\mathrm{old}})\)</span>.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="mbpt.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">4. </span>Many-body perturbation theory</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="gradientmethods.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>Gradient Methods</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Morten Hjorth-Jensen<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>