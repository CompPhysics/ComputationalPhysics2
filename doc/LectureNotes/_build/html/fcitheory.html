
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. Full configuration interaction theory &#8212; Advanced Topics in Computational Physics</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Many-body perturbation theory" href="mbpt.html" />
    <link rel="prev" title="2. Hartree-Fock methods" href="hartreefocktheory.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Advanced Topics in Computational Physics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Advanced Topics in Computational Physics: Computational Quantum Mechanics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Schedule
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Instructor information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks and practicalities
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basic Many-Body Physics
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicmanybody.html">
   1. Many-body Hamiltonians, basic linear algebra and Second Quantization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hartreefocktheory.html">
   2. Hartree-Fock methods
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. Full configuration interaction theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mbpt.html">
   4. Many-body perturbation theory
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Stochastic Methods
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vmcdmc.html">
   5. Variational Monte Carlo methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="gradientmethods.html">
   6. Gradient Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="resamplingmethods.html">
   7. Resampling Techniques, Bootstrap and Blocking
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Computational Aspects
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vectorization.html">
   8. Optimization and Vectorization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallelization.html">
   9. Parallelization with MPI and OpenMPI
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Deep Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="linearregression.html">
   10. Linear Regression and more Advanced Regression Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="logisticregression.html">
   11. Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="supportvectormachines.html">
   12. Support Vector Machines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="neuralnetworks.html">
   13. Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boltzmannmachines.html">
   14. Boltzmann Machines
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Quantum Computing and Quantum Machine Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicquantumcomputing.html">
   15. Quantum Computing
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/fcitheory.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slater-determinants-as-basis-states-repetition">
   3.1. Slater determinants as basis states, Repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   3.2. Slater determinants as basis states, repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slater-determinants-as-basis-states">
   3.3. Slater determinants as basis states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   3.4. Slater determinants as basis states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quick-repetition-of-the-occupation-representation">
   3.5. Quick repetition of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   3.6. Quick repetition  of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   3.7. Quick repetition  of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   3.8. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   3.9. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   3.10. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   3.11. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   3.12. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   3.13. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-of-a-hamiltonian-matrix">
   3.14. Example of a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-of-a-hamiltonian-matrix-with-a-hartree-fock-basis">
   3.15. Example of a Hamiltonian matrix with a Hartree-Fock basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shell-model-jargon">
   3.16. Shell-model jargon
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fci-and-the-exponential-growth">
   3.17. FCI and the exponential growth
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exponential-wall">
   3.18. Exponential wall
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-non-practical-way-of-solving-the-eigenvalue-problem">
   3.19. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   3.20. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   3.21. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation">
   3.22. Rewriting the FCI equation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   3.23. Rewriting the FCI equation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-does-not-stop-here">
   3.24. Rewriting the FCI equation, does not stop here
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-please-stop-here">
   3.25. Rewriting the FCI equation, please stop here
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-more-to-add">
   3.26. Rewriting the FCI equation, more to add
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id14">
   3.27. Rewriting the FCI equation, more to add
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summarizing-fci-and-bringing-in-approximative-methods">
   3.28. Summarizing FCI and bringing in approximative methods
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#definition-of-the-correlation-energy">
   3.29. Definition of the correlation energy
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fci-equation-and-the-coefficients">
   3.30. FCI equation and the coefficients
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#important-ingredients-to-have-in-codes">
   3.31. Important ingredients to have in codes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-structured-approach-to-solving-problems">
   3.32. A structured approach to solving problems
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-benefits">
   3.33. Additional benefits
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-testing">
   3.34. Unit Testing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-testing-benefits">
   3.35. Unit Testing, benefits
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simple-example-of-unit-test">
   3.36. Simple example of unit test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id15">
   3.37. Simple example of unit test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-tests">
   3.38. Unit tests
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examples">
   3.39. Examples
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#factorial-example">
   3.40. Factorial Example
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-did-we-do-1">
   3.41. What did we do (1)?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-did-we-do-2">
   3.42. What did we do (2)?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-test-summary-and-testing-approach">
   3.43. Unit test summary and testing approach
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#coding-recommendations">
   3.44. Coding Recommendations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary-and-recommendations">
   3.45. Summary and recommendations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-many-body-basis">
   3.46. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id16">
   3.47. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id17">
   3.48. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id18">
   3.49. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id19">
   3.50. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id20">
   3.51. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id21">
   3.52. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id22">
   3.53. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id23">
   3.54. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id24">
   3.55. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id25">
   3.56. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id26">
   3.57. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shell-model-project">
   3.58. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id27">
   3.59. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id28">
   3.60. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id29">
   3.61. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id30">
   3.62. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id31">
   3.63. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id32">
   3.64. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   3.65. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id34">
   3.66. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id35">
   3.67. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id36">
   3.68. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id37">
   3.69. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id38">
   3.70. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id39">
   3.71. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id40">
   3.72. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id41">
   3.73. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-case-pairing-hamiltonian">
   3.74. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id42">
   3.75. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id43">
   3.76. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id44">
   3.77. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id45">
   3.78. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id46">
   3.79. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id47">
   3.80. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id48">
   3.81. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id49">
   3.82. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix">
   3.83. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id50">
   3.84. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id51">
   3.85. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix-first-step">
   3.86. Building a Hamiltonian matrix, first step
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix-second-step">
   3.87. Building a Hamiltonian matrix, second step
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id52">
   3.88. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id53">
   3.89. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id54">
   3.90. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id55">
   3.91. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id56">
   3.92. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id57">
   3.93. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hamiltonian-matrix-without-the-bit-representation">
   3.94. Hamiltonian matrix without the bit representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hamiltonian-matrix-without-the-bit-representation-one-and-two-body-operators">
   3.95. Hamiltonian matrix without the bit representation, one and two-body operators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strategies-for-setting-up-an-algorithm">
   3.96. Strategies for setting up an algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computing-expectation-values-and-transitions-in-the-shell-model">
   3.97. Computing expectation values and transitions in the shell-model
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computing-expectation-values-and-transitions-in-the-shell-model-and-spectroscopic-factors">
   3.98. Computing expectation values and transitions in the shell-model and spectroscopic factors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operators-in-second-quantization">
   3.99. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id58">
   3.100. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id59">
   3.101. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id60">
   3.102. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id61">
   3.103. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id62">
   3.104. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id63">
   3.105. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id64">
   3.106. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id65">
   3.107. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bit-counting">
   3.108. Bit counting
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalue-problems-basic-definitions">
   3.109. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id66">
   3.110. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id67">
   3.111. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#abel-ruffini-impossibility-theorem">
   3.112. Abel-Ruffini Impossibility Theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id68">
   3.113. Abel-Ruffini Impossibility Theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id69">
   3.114. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id70">
   3.115. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id71">
   3.116. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id72">
   3.117. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion-of-methods-for-eigenvalues">
   3.118. Discussion of  methods for eigenvalues
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-methods">
   3.119. Eigenvalues methods
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id73">
   3.120. Discussion of methods for eigenvalues
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method">
   3.121. Eigenvalues and Lanczos’ method
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-tridiagonal-matrix">
   3.122. Eigenvalues and Lanczos’ method, tridiagonal matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-tridiagonal-and-orthogonal-matrices">
   3.123. Eigenvalues and Lanczos’ method, tridiagonal and orthogonal matrices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id74">
   3.124. Eigenvalues and Lanczos’ method
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-defining-the-lanczos-vectors">
   3.125. Eigenvalues and Lanczos’ method, defining the Lanczos’ vectors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-basic-steps">
   3.126. Eigenvalues and Lanczos’ method, basic steps
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Full configuration interaction theory</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slater-determinants-as-basis-states-repetition">
   3.1. Slater determinants as basis states, Repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   3.2. Slater determinants as basis states, repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slater-determinants-as-basis-states">
   3.3. Slater determinants as basis states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   3.4. Slater determinants as basis states
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quick-repetition-of-the-occupation-representation">
   3.5. Quick repetition of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   3.6. Quick repetition  of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   3.7. Quick repetition  of the occupation representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   3.8. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   3.9. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   3.10. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   3.11. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   3.12. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   3.13. Full Configuration Interaction Theory
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-of-a-hamiltonian-matrix">
   3.14. Example of a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-of-a-hamiltonian-matrix-with-a-hartree-fock-basis">
   3.15. Example of a Hamiltonian matrix with a Hartree-Fock basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shell-model-jargon">
   3.16. Shell-model jargon
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fci-and-the-exponential-growth">
   3.17. FCI and the exponential growth
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exponential-wall">
   3.18. Exponential wall
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-non-practical-way-of-solving-the-eigenvalue-problem">
   3.19. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   3.20. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   3.21. A non-practical way of solving the eigenvalue problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation">
   3.22. Rewriting the FCI equation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   3.23. Rewriting the FCI equation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-does-not-stop-here">
   3.24. Rewriting the FCI equation, does not stop here
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-please-stop-here">
   3.25. Rewriting the FCI equation, please stop here
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rewriting-the-fci-equation-more-to-add">
   3.26. Rewriting the FCI equation, more to add
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id14">
   3.27. Rewriting the FCI equation, more to add
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summarizing-fci-and-bringing-in-approximative-methods">
   3.28. Summarizing FCI and bringing in approximative methods
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#definition-of-the-correlation-energy">
   3.29. Definition of the correlation energy
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fci-equation-and-the-coefficients">
   3.30. FCI equation and the coefficients
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#important-ingredients-to-have-in-codes">
   3.31. Important ingredients to have in codes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-structured-approach-to-solving-problems">
   3.32. A structured approach to solving problems
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-benefits">
   3.33. Additional benefits
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-testing">
   3.34. Unit Testing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-testing-benefits">
   3.35. Unit Testing, benefits
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simple-example-of-unit-test">
   3.36. Simple example of unit test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id15">
   3.37. Simple example of unit test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-tests">
   3.38. Unit tests
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examples">
   3.39. Examples
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#factorial-example">
   3.40. Factorial Example
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-did-we-do-1">
   3.41. What did we do (1)?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-did-we-do-2">
   3.42. What did we do (2)?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unit-test-summary-and-testing-approach">
   3.43. Unit test summary and testing approach
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#coding-recommendations">
   3.44. Coding Recommendations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary-and-recommendations">
   3.45. Summary and recommendations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-many-body-basis">
   3.46. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id16">
   3.47. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id17">
   3.48. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id18">
   3.49. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id19">
   3.50. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id20">
   3.51. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id21">
   3.52. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id22">
   3.53. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id23">
   3.54. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id24">
   3.55. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id25">
   3.56. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id26">
   3.57. Building a many-body basis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shell-model-project">
   3.58. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id27">
   3.59. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id28">
   3.60. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id29">
   3.61. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id30">
   3.62. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id31">
   3.63. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id32">
   3.64. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   3.65. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id34">
   3.66. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id35">
   3.67. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id36">
   3.68. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id37">
   3.69. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id38">
   3.70. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id39">
   3.71. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id40">
   3.72. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id41">
   3.73. Shell-model project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-case-pairing-hamiltonian">
   3.74. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id42">
   3.75. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id43">
   3.76. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id44">
   3.77. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id45">
   3.78. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id46">
   3.79. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id47">
   3.80. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id48">
   3.81. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id49">
   3.82. Example case: pairing Hamiltonian
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix">
   3.83. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id50">
   3.84. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id51">
   3.85. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix-first-step">
   3.86. Building a Hamiltonian matrix, first step
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#building-a-hamiltonian-matrix-second-step">
   3.87. Building a Hamiltonian matrix, second step
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id52">
   3.88. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id53">
   3.89. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id54">
   3.90. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id55">
   3.91. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id56">
   3.92. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id57">
   3.93. Building a Hamiltonian matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hamiltonian-matrix-without-the-bit-representation">
   3.94. Hamiltonian matrix without the bit representation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hamiltonian-matrix-without-the-bit-representation-one-and-two-body-operators">
   3.95. Hamiltonian matrix without the bit representation, one and two-body operators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strategies-for-setting-up-an-algorithm">
   3.96. Strategies for setting up an algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computing-expectation-values-and-transitions-in-the-shell-model">
   3.97. Computing expectation values and transitions in the shell-model
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computing-expectation-values-and-transitions-in-the-shell-model-and-spectroscopic-factors">
   3.98. Computing expectation values and transitions in the shell-model and spectroscopic factors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operators-in-second-quantization">
   3.99. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id58">
   3.100. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id59">
   3.101. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id60">
   3.102. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id61">
   3.103. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id62">
   3.104. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id63">
   3.105. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id64">
   3.106. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id65">
   3.107. Operators in second quantization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bit-counting">
   3.108. Bit counting
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalue-problems-basic-definitions">
   3.109. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id66">
   3.110. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id67">
   3.111. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#abel-ruffini-impossibility-theorem">
   3.112. Abel-Ruffini Impossibility Theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id68">
   3.113. Abel-Ruffini Impossibility Theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id69">
   3.114. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id70">
   3.115. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id71">
   3.116. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id72">
   3.117. Eigenvalue problems, basic definitions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion-of-methods-for-eigenvalues">
   3.118. Discussion of  methods for eigenvalues
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-methods">
   3.119. Eigenvalues methods
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id73">
   3.120. Discussion of methods for eigenvalues
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method">
   3.121. Eigenvalues and Lanczos’ method
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-tridiagonal-matrix">
   3.122. Eigenvalues and Lanczos’ method, tridiagonal matrix
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-tridiagonal-and-orthogonal-matrices">
   3.123. Eigenvalues and Lanczos’ method, tridiagonal and orthogonal matrices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id74">
   3.124. Eigenvalues and Lanczos’ method
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-defining-the-lanczos-vectors">
   3.125. Eigenvalues and Lanczos’ method, defining the Lanczos’ vectors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-lanczos-method-basic-steps">
   3.126. Eigenvalues and Lanczos’ method, basic steps
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="full-configuration-interaction-theory">
<h1><span class="section-number">3. </span>Full configuration interaction theory<a class="headerlink" href="#full-configuration-interaction-theory" title="Permalink to this headline">¶</a></h1>
<div class="section" id="slater-determinants-as-basis-states-repetition">
<h2><span class="section-number">3.1. </span>Slater determinants as basis states, Repetition<a class="headerlink" href="#slater-determinants-as-basis-states-repetition" title="Permalink to this headline">¶</a></h2>
<p>The simplest possible choice for many-body wavefunctions are <strong>product</strong> wavefunctions.
That is</p>
<div class="math notranslate nohighlight">
\[
\Psi(x_1, x_2, x_3, \ldots, x_A) \approx \phi_1(x_1) \phi_2(x_2) \phi_3(x_3) \ldots
\]</div>
<p>because we are really only good  at thinking about one particle at a time. Such
product wavefunctions, without correlations, are easy to
work with; for example, if the single-particle states <span class="math notranslate nohighlight">\(\phi_i(x)\)</span> are orthonormal, then
the product wavefunctions are easy to orthonormalize.</p>
<p>Similarly, computing matrix elements of operators are relatively easy, because the
integrals factorize.</p>
<p>The price we pay is the lack of correlations, which we must build up by using many, many product
wavefunctions. (Thus we have a trade-off: compact representation of correlations but
difficult integrals versus easy integrals but many states required.)</p>
</div>
<div class="section" id="id1">
<h2><span class="section-number">3.2. </span>Slater determinants as basis states, repetition<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Because we have fermions, we are required to have antisymmetric wavefunctions, e.g.</p>
<div class="math notranslate nohighlight">
\[
\Psi(x_1, x_2, x_3, \ldots, x_A) = - \Psi(x_2, x_1, x_3, \ldots, x_A)
\]</div>
<p>etc. This is accomplished formally by using the determinantal formalism</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Psi(x_1, x_2, \ldots, x_A) 
= \frac{1}{\sqrt{A!}} 
\det \left | 
\begin{array}{cccc}
\phi_1(x_1) &amp; \phi_1(x_2) &amp; \ldots &amp; \phi_1(x_A) \\
\phi_2(x_1) &amp; \phi_2(x_2) &amp; \ldots &amp; \phi_2(x_A) \\
 \vdots &amp; &amp; &amp;  \\
\phi_A(x_1) &amp; \phi_A(x_2) &amp; \ldots &amp; \phi_A(x_A) 
\end{array}
\right |
\end{split}\]</div>
<p>Product wavefunction + antisymmetry = Slater determinant.</p>
</div>
<div class="section" id="slater-determinants-as-basis-states">
<h2><span class="section-number">3.3. </span>Slater determinants as basis states<a class="headerlink" href="#slater-determinants-as-basis-states" title="Permalink to this headline">¶</a></h2>
<div class="math notranslate nohighlight">
\[\begin{split}
\Psi(x_1, x_2, \ldots, x_A) 
= \frac{1}{\sqrt{A!}} 
\det \left | 
\begin{array}{cccc}
\phi_1(x_1) &amp; \phi_1(x_2) &amp; \ldots &amp; \phi_1(x_A) \\
\phi_2(x_1) &amp; \phi_2(x_2) &amp; \ldots &amp; \phi_2(x_A) \\
 \vdots &amp; &amp; &amp;  \\
\phi_A(x_1) &amp; \phi_A(x_2) &amp; \ldots &amp; \phi_A(x_A) 
\end{array}
\right |
\end{split}\]</div>
<p>Properties of the determinant (interchange of any two rows or
any two columns yields a change in sign; thus no two rows and no
two columns can be the same) lead to the Pauli principle:</p>
<ul class="simple">
<li><p>No two particles can be at the same place (two columns the same); and</p></li>
<li><p>No two particles can be in the same state (two rows the same).</p></li>
</ul>
</div>
<div class="section" id="id2">
<h2><span class="section-number">3.4. </span>Slater determinants as basis states<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>As a practical matter, however, Slater determinants beyond <span class="math notranslate nohighlight">\(N=4\)</span> quickly become
unwieldy. Thus we turn to the <strong>occupation representation</strong> or <strong>second quantization</strong> to simplify calculations.</p>
<p>The occupation representation or number representation, using fermion <strong>creation</strong> and <strong>annihilation</strong>
operators, is compact and efficient. It is also abstract and, at first encounter, not easy to
internalize. It is inspired by other operator formalism, such as the ladder operators for
the harmonic oscillator or for angular momentum, but unlike those cases, the operators <strong>do not have coordinate space representations</strong>.</p>
<p>Instead, one can think of fermion creation/annihilation operators as a game of symbols that
compactly reproduces what one would do, albeit clumsily, with full coordinate-space Slater
determinants.</p>
</div>
<div class="section" id="quick-repetition-of-the-occupation-representation">
<h2><span class="section-number">3.5. </span>Quick repetition of the occupation representation<a class="headerlink" href="#quick-repetition-of-the-occupation-representation" title="Permalink to this headline">¶</a></h2>
<p>We start with a set of orthonormal single-particle states <span class="math notranslate nohighlight">\(\{ \phi_i(x) \}\)</span>.
(Note: this requirement, and others, can be relaxed, but leads to a
more involved formalism.) <strong>Any</strong> orthonormal set will do.</p>
<p>To each single-particle state <span class="math notranslate nohighlight">\(\phi_i(x)\)</span> we associate a creation operator
<span class="math notranslate nohighlight">\(\hat{a}^\dagger_i\)</span> and an annihilation operator <span class="math notranslate nohighlight">\(\hat{a}_i\)</span>.</p>
<p>When acting on the vacuum state <span class="math notranslate nohighlight">\(| 0 \rangle\)</span>, the creation operator <span class="math notranslate nohighlight">\(\hat{a}^\dagger_i\)</span> causes
a particle to occupy the single-particle state <span class="math notranslate nohighlight">\(\phi_i(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\phi_i(x) \rightarrow \hat{a}^\dagger_i |0 \rangle
\]</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.6. </span>Quick repetition  of the occupation representation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>But with multiple creation operators we can occupy multiple states:</p>
<div class="math notranslate nohighlight">
\[
\phi_i(x) \phi_j(x^\prime) \phi_k(x^{\prime \prime}) 
\rightarrow \hat{a}^\dagger_i \hat{a}^\dagger_j \hat{a}^\dagger_k |0 \rangle.
\]</div>
<p>Now we impose antisymmetry, by having the fermion operators satisfy  <strong>anticommutation relations</strong>:</p>
<div class="math notranslate nohighlight">
\[
\hat{a}^\dagger_i \hat{a}^\dagger_j + \hat{a}^\dagger_j \hat{a}^\dagger_i
= [ \hat{a}^\dagger_i ,\hat{a}^\dagger_j ]_+ 
= \{ \hat{a}^\dagger_i ,\hat{a}^\dagger_j \} = 0
\]</div>
<p>so that</p>
<div class="math notranslate nohighlight">
\[
\hat{a}^\dagger_i \hat{a}^\dagger_j = - \hat{a}^\dagger_j \hat{a}^\dagger_i
\]</div>
</div>
<div class="section" id="id4">
<h2><span class="section-number">3.7. </span>Quick repetition  of the occupation representation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Because of this property, automatically <span class="math notranslate nohighlight">\(\hat{a}^\dagger_i \hat{a}^\dagger_i = 0\)</span>,
enforcing the Pauli exclusion principle.  Thus when writing a Slater determinant
using creation operators,</p>
<div class="math notranslate nohighlight">
\[
\hat{a}^\dagger_i \hat{a}^\dagger_j \hat{a}^\dagger_k \ldots |0 \rangle
\]</div>
<p>each index <span class="math notranslate nohighlight">\(i,j,k, \ldots\)</span> must be unique.</p>
<p>For some relevant exercises with solutions see chapter 8 of <a class="reference external" href="http://www.springer.com/us/book/9783319533353">Lecture Notes in Physics, volume 936</a>.</p>
</div>
<div class="section" id="id5">
<h2><span class="section-number">3.8. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>We have defined the ansatz for the ground state as</p>
<div class="math notranslate nohighlight">
\[
|\Phi_0\rangle = \left(\prod_{i\le F}\hat{a}_{i}^{\dagger}\right)|0\rangle,
\]</div>
<p>where the index <span class="math notranslate nohighlight">\(i\)</span> defines different single-particle states up to the Fermi level. We have assumed that we have <span class="math notranslate nohighlight">\(N\)</span> fermions.
A given one-particle-one-hole (<span class="math notranslate nohighlight">\(1p1h\)</span>) state can be written as</p>
<div class="math notranslate nohighlight">
\[
|\Phi_i^a\rangle = \hat{a}_{a}^{\dagger}\hat{a}_i|\Phi_0\rangle,
\]</div>
<p>while a <span class="math notranslate nohighlight">\(2p2h\)</span> state can be written as</p>
<div class="math notranslate nohighlight">
\[
|\Phi_{ij}^{ab}\rangle = \hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_j\hat{a}_i|\Phi_0\rangle,
\]</div>
<p>and a general <span class="math notranslate nohighlight">\(NpNh\)</span> state as</p>
<div class="math notranslate nohighlight">
\[
|\Phi_{ijk\dots}^{abc\dots}\rangle = \hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_{c}^{\dagger}\dots\hat{a}_k\hat{a}_j\hat{a}_i|\Phi_0\rangle.
\]</div>
</div>
<div class="section" id="id6">
<h2><span class="section-number">3.9. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>We can then expand our exact state function for the ground state
as</p>
<div class="math notranslate nohighlight">
\[
|\Psi_0\rangle=C_0|\Phi_0\rangle+\sum_{ai}C_i^a|\Phi_i^a\rangle+\sum_{abij}C_{ij}^{ab}|\Phi_{ij}^{ab}\rangle+\dots
=(C_0+\hat{C})|\Phi_0\rangle,
\]</div>
<p>where we have introduced the so-called correlation operator</p>
<div class="math notranslate nohighlight">
\[
\hat{C}=\sum_{ai}C_i^a\hat{a}_{a}^{\dagger}\hat{a}_i  +\sum_{abij}C_{ij}^{ab}\hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_j\hat{a}_i+\dots
\]</div>
<p>Since the normalization of <span class="math notranslate nohighlight">\(\Psi_0\)</span> is at our disposal and since <span class="math notranslate nohighlight">\(C_0\)</span> is by hypothesis non-zero, we may arbitrarily set <span class="math notranslate nohighlight">\(C_0=1\)</span> with
corresponding proportional changes in all other coefficients. Using this so-called intermediate normalization we have</p>
<div class="math notranslate nohighlight">
\[
\langle \Psi_0 | \Phi_0 \rangle = \langle \Phi_0 | \Phi_0 \rangle = 1,
\]</div>
<p>resulting in</p>
<div class="math notranslate nohighlight">
\[
|\Psi_0\rangle=(1+\hat{C})|\Phi_0\rangle.
\]</div>
</div>
<div class="section" id="id7">
<h2><span class="section-number">3.10. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>We rewrite</p>
<div class="math notranslate nohighlight">
\[
|\Psi_0\rangle=C_0|\Phi_0\rangle+\sum_{ai}C_i^a|\Phi_i^a\rangle+\sum_{abij}C_{ij}^{ab}|\Phi_{ij}^{ab}\rangle+\dots,
\]</div>
<p>in a more compact form as</p>
<div class="math notranslate nohighlight">
\[
|\Psi_0\rangle=\sum_{PH}C_H^P\Phi_H^P=\left(\sum_{PH}C_H^P\hat{A}_H^P\right)|\Phi_0\rangle,
\]</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> stands for <span class="math notranslate nohighlight">\(0,1,\dots,n\)</span> hole states and <span class="math notranslate nohighlight">\(P\)</span> for <span class="math notranslate nohighlight">\(0,1,\dots,n\)</span> particle states.
Our requirement of unit normalization gives</p>
<div class="math notranslate nohighlight">
\[
\langle \Psi_0 | \Phi_0 \rangle = \sum_{PH}|C_H^P|^2= 1,
\]</div>
<p>and the energy can be written as</p>
<div class="math notranslate nohighlight">
\[
E= \langle \Psi_0 | \hat{H} |\Phi_0 \rangle= \sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}.
\]</div>
</div>
<div class="section" id="id8">
<h2><span class="section-number">3.11. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Normally</p>
<div class="math notranslate nohighlight">
\[
E= \langle \Psi_0 | \hat{H} |\Phi_0 \rangle= \sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'},
\]</div>
<p>is solved by diagonalization setting up the Hamiltonian matrix defined by the basis of all possible Slater determinants. A diagonalization</p>
<!-- to do: add text about Rayleigh-Ritz -->
<p>is equivalent to finding the variational minimum   of</p>
<div class="math notranslate nohighlight">
\[
\langle \Psi_0 | \hat{H} |\Phi_0 \rangle-\lambda \langle \Psi_0 |\Phi_0 \rangle,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a variational multiplier to be identified with the energy of the system.
The minimization process results in</p>
<p>2
3</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\sum_{P'H'}\left\{\delta[C_H^{*P}]\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}+
C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle \delta[C_{H'}^{P'}]-
\lambda( \delta[C_H^{*P}]C_{H'}^{P'}+C_H^{*P}\delta[C_{H'}^{P'}]\right\} = 0.
\]</div>
<p>Since the coefficients <span class="math notranslate nohighlight">\(\delta[C_H^{*P}]\)</span> and <span class="math notranslate nohighlight">\(\delta[C_{H'}^{P'}]\)</span> are complex conjugates it is necessary and sufficient to require the quantities that multiply with <span class="math notranslate nohighlight">\(\delta[C_H^{*P}]\)</span> to vanish.</p>
</div>
<div class="section" id="id9">
<h2><span class="section-number">3.12. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>This leads to</p>
<div class="math notranslate nohighlight">
\[
\sum_{P'H'}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}-\lambda C_H^{P}=0,
\]</div>
<p>for all sets of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>If we then multiply by the corresponding <span class="math notranslate nohighlight">\(C_H^{*P}\)</span> and sum over <span class="math notranslate nohighlight">\(PH\)</span> we obtain</p>
<div class="math notranslate nohighlight">
\[
\sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}-\lambda\sum_{PH}|C_H^P|^2=0,
\]</div>
<p>leading to the identification <span class="math notranslate nohighlight">\(\lambda = E\)</span>. This means that we have for all <span class="math notranslate nohighlight">\(PH\)</span> sets</p>
<!-- Equation labels as ordinary links -->
<div id="eq:fullci"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{P'H'}\langle \Phi_H^P | \hat{H} -E|\Phi_{H'}^{P'} \rangle = 0. \label{eq:fullci} \tag{1}
\end{equation}
\]</div>
</div>
<div class="section" id="id10">
<h2><span class="section-number">3.13. </span>Full Configuration Interaction Theory<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>An alternative way to derive the last equation is to start from</p>
<div class="math notranslate nohighlight">
\[
(\hat{H} -E)|\Psi_0\rangle = (\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0,
\]</div>
<p>and if this equation is successively projected against all <span class="math notranslate nohighlight">\(\Phi_H^P\)</span> in the expansion of <span class="math notranslate nohighlight">\(\Psi\)</span>, then the last equation on the previous slide
results.   As stated previously, one solves this equation normally by diagonalization. If we are able to solve this equation exactly (that is
numerically exactly) in a large Hilbert space (it will be truncated in terms of the number of single-particle states included in the definition
of Slater determinants), it can then serve as a benchmark for other many-body methods which approximate the correlation operator
<span class="math notranslate nohighlight">\(\hat{C}\)</span>.</p>
</div>
<div class="section" id="example-of-a-hamiltonian-matrix">
<h2><span class="section-number">3.14. </span>Example of a Hamiltonian matrix<a class="headerlink" href="#example-of-a-hamiltonian-matrix" title="Permalink to this headline">¶</a></h2>
<p>Suppose, as an example, that we have six fermions below the Fermi level.
This means that we can make at most <span class="math notranslate nohighlight">\(6p-6h\)</span> excitations. If we have an infinity of single particle states above the Fermi level, we will obviously have an infinity of say <span class="math notranslate nohighlight">\(2p-2h\)</span> excitations. Each such way to configure the particles is called a <strong>configuration</strong>. We will always have to truncate in the basis of single-particle states.
This gives us a finite number of possible Slater determinants. Our Hamiltonian matrix would then look like (where each block can have a large dimensionalities):</p>
<table border="1">
<thead>
<tr><th align="center">       </th> <th align="center">$0p-0h$</th> <th align="center">$1p-1h$</th> <th align="center">$2p-2h$</th> <th align="center">$3p-3h$</th> <th align="center">$4p-4h$</th> <th align="center">$5p-5h$</th> <th align="center">$6p-6h$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   $0p-0h$    </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   $1p-1h$    </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   $2p-2h$    </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   0          </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   $3p-3h$    </td> <td align="center">   0          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   $4p-4h$    </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> </tr>
<tr><td align="center">   $5p-5h$    </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> </tr>
<tr><td align="center">   $6p-6h$    </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   x          </td> <td align="center">   x          </td> <td align="center">   x          </td> </tr>
</tbody>
</table>
with a two-body force. Why are there non-zero blocks of elements?
</div>
<div class="section" id="example-of-a-hamiltonian-matrix-with-a-hartree-fock-basis">
<h2><span class="section-number">3.15. </span>Example of a Hamiltonian matrix with a Hartree-Fock basis<a class="headerlink" href="#example-of-a-hamiltonian-matrix-with-a-hartree-fock-basis" title="Permalink to this headline">¶</a></h2>
<p>If we use a Hartree-Fock basis, this corresponds to a particular unitary transformation where matrix elements of the type <span class="math notranslate nohighlight">\(\langle 0p-0h \vert \hat{H} \vert 1p-1h\rangle =\langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle=0\)</span> and our Hamiltonian matrix becomes</p>
<table border="1">
<thead>
<tr><th align="center">       </th> <th align="center">  $0p-0h$  </th> <th align="center">  $1p-1h$  </th> <th align="center">  $2p-2h$  </th> <th align="center">  $3p-3h$  </th> <th align="center">  $4p-4h$  </th> <th align="center">  $5p-5h$  </th> <th align="center">  $6p-6h$  </th> </tr>
</thead>
<tbody>
<tr><td align="center">   $0p-0h$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   $1p-1h$    </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   $2p-2h$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   $3p-3h$    </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   $4p-4h$    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> </tr>
<tr><td align="center">   $5p-5h$    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> </tr>
<tr><td align="center">   $6p-6h$    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> <td align="center">   $\tilde{x}$    </td> </tr>
</tbody>
</table>
</div>
<div class="section" id="shell-model-jargon">
<h2><span class="section-number">3.16. </span>Shell-model jargon<a class="headerlink" href="#shell-model-jargon" title="Permalink to this headline">¶</a></h2>
<p>If we do not make any truncations in the possible sets of Slater determinants (many-body states) we can make by distributing <span class="math notranslate nohighlight">\(A\)</span> nucleons among <span class="math notranslate nohighlight">\(n\)</span> single-particle states, we call such a calculation for <strong>Full configuration interaction theory</strong></p>
<p>If we make truncations, we have different possibilities</p>
<ul class="simple">
<li><p>The standard nuclear shell-model. Here we define an effective Hilbert space with respect to a given core. The calculations are normally then performed for all many-body states that can be constructed from the effective Hilbert spaces. This approach requires a properly defined effective Hamiltonian</p></li>
<li><p>We can truncate in the number of excitations. For example, we can limit the possible Slater determinants to only <span class="math notranslate nohighlight">\(1p-1h\)</span> and <span class="math notranslate nohighlight">\(2p-2h\)</span> excitations. This is called a configuration interaction calculation at the level of singles and doubles excitations, or just CISD.</p></li>
<li><p>We can limit the number of excitations in terms of the excitation energies. If we do not define a core, this defines normally what is called the no-core shell-model approach.</p></li>
</ul>
<p>What happens if we have a three-body interaction and a Hartree-Fock basis?</p>
</div>
<div class="section" id="fci-and-the-exponential-growth">
<h2><span class="section-number">3.17. </span>FCI and the exponential growth<a class="headerlink" href="#fci-and-the-exponential-growth" title="Permalink to this headline">¶</a></h2>
<p>Full configuration interaction theory calculations provide in principle, if we can diagonalize numerically, all states of interest. The dimensionality of the problem explodes however quickly.</p>
<p>The total number of Slater determinants which can be built with say <span class="math notranslate nohighlight">\(N\)</span> neutrons distributed among <span class="math notranslate nohighlight">\(n\)</span> single particle states is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left (\begin{array}{c} n \\ N\end{array} \right) =\frac{n!}{(n-N)!N!}.
\end{split}\]</div>
<p>For a model space which comprises the first for major shells only <span class="math notranslate nohighlight">\(0s\)</span>, <span class="math notranslate nohighlight">\(0p\)</span>, <span class="math notranslate nohighlight">\(1s0d\)</span> and <span class="math notranslate nohighlight">\(1p0f\)</span> we have <span class="math notranslate nohighlight">\(40\)</span> single particle states for neutrons and protons.  For the eight neutrons of oxygen-16 we would then have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left (\begin{array}{c} 40 \\ 8\end{array} \right) =\frac{40!}{(32)!8!}\sim 10^{9},
\end{split}\]</div>
<p>and multiplying this with the number of proton Slater determinants we end up with approximately with a dimensionality <span class="math notranslate nohighlight">\(d\)</span> of <span class="math notranslate nohighlight">\(d\sim 10^{18}\)</span>.</p>
</div>
<div class="section" id="exponential-wall">
<h2><span class="section-number">3.18. </span>Exponential wall<a class="headerlink" href="#exponential-wall" title="Permalink to this headline">¶</a></h2>
<p>This number can be reduced if we look at specific symmetries only. However, the dimensionality explodes quickly!</p>
<ul class="simple">
<li><p>For Hamiltonian matrices of dimensionalities  which are smaller than <span class="math notranslate nohighlight">\(d\sim 10^5\)</span>, we would use so-called direct methods for diagonalizing the Hamiltonian matrix</p></li>
<li><p>For larger dimensionalities iterative eigenvalue solvers like Lanczos’ method are used. The most efficient codes at present can handle matrices of <span class="math notranslate nohighlight">\(d\sim 10^{10}\)</span>.</p></li>
</ul>
</div>
<div class="section" id="a-non-practical-way-of-solving-the-eigenvalue-problem">
<h2><span class="section-number">3.19. </span>A non-practical way of solving the eigenvalue problem<a class="headerlink" href="#a-non-practical-way-of-solving-the-eigenvalue-problem" title="Permalink to this headline">¶</a></h2>
<p>To see this, we look at the contributions arising from</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi_H^P | = \langle \Phi_0|
\]</div>
<p>in  Eq. (<a class="reference external" href="#eq:fullci">1</a>), that is we multiply with <span class="math notranslate nohighlight">\(\langle \Phi_0 |\)</span>
from the left in</p>
<div class="math notranslate nohighlight">
\[
(\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0.
\]</div>
<p>If we assume that we have a two-body operator at most, Slater’s rule gives then an equation for the
correlation energy in terms of <span class="math notranslate nohighlight">\(C_i^a\)</span> and <span class="math notranslate nohighlight">\(C_{ij}^{ab}\)</span> only.  We get then</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi_0 | \hat{H} -E| \Phi_0\rangle + \sum_{ai}\langle \Phi_0 | \hat{H} -E|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H} -E|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}=0,
\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[
E-E_0 =\Delta E=\sum_{ai}\langle \Phi_0 | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab},
\]</div>
<p>where the energy <span class="math notranslate nohighlight">\(E_0\)</span> is the reference energy and <span class="math notranslate nohighlight">\(\Delta E\)</span> defines the so-called correlation energy.
The single-particle basis functions  could be the results of a Hartree-Fock calculation or just the eigenstates of the non-interacting part of the Hamiltonian.</p>
</div>
<div class="section" id="id11">
<h2><span class="section-number">3.20. </span>A non-practical way of solving the eigenvalue problem<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>To see this, we look at the contributions arising from</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi_H^P | = \langle \Phi_0|
\]</div>
<p>in  Eq. (<a class="reference external" href="#eq:fullci">1</a>), that is we multiply with <span class="math notranslate nohighlight">\(\langle \Phi_0 |\)</span>
from the left in</p>
<div class="math notranslate nohighlight">
\[
(\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0.
\]</div>
</div>
<div class="section" id="id12">
<h2><span class="section-number">3.21. </span>A non-practical way of solving the eigenvalue problem<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>If we assume that we have a two-body operator at most, Slater’s rule gives then an equation for the
correlation energy in terms of <span class="math notranslate nohighlight">\(C_i^a\)</span> and <span class="math notranslate nohighlight">\(C_{ij}^{ab}\)</span> only.  We get then</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi_0 | \hat{H} -E| \Phi_0\rangle + \sum_{ai}\langle \Phi_0 | \hat{H} -E|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H} -E|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}=0,
\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[
E-E_0 =\Delta E=\sum_{ai}\langle \Phi_0 | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab},
\]</div>
<p>where the energy <span class="math notranslate nohighlight">\(E_0\)</span> is the reference energy and <span class="math notranslate nohighlight">\(\Delta E\)</span> defines the so-called correlation energy.
The single-particle basis functions  could be the results of a Hartree-Fock calculation or just the eigenstates of the non-interacting part of the Hamiltonian.</p>
</div>
<div class="section" id="rewriting-the-fci-equation">
<h2><span class="section-number">3.22. </span>Rewriting the FCI equation<a class="headerlink" href="#rewriting-the-fci-equation" title="Permalink to this headline">¶</a></h2>
<p>In our notes on Hartree-Fock calculations,
we have already computed the matrix <span class="math notranslate nohighlight">\(\langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle \)</span> and <span class="math notranslate nohighlight">\(\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab}\rangle\)</span>.  If we are using a Hartree-Fock basis, then the matrix elements
<span class="math notranslate nohighlight">\(\langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle=0\)</span> and we are left with a <em>correlation energy</em> given by</p>
<div class="math notranslate nohighlight">
\[
E-E_0 =\Delta E^{HF}=\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}.
\]</div>
</div>
<div class="section" id="id13">
<h2><span class="section-number">3.23. </span>Rewriting the FCI equation<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>Inserting the various matrix elements we can rewrite the previous equation as</p>
<div class="math notranslate nohighlight">
\[
\Delta E=\sum_{ai}\langle i| \hat{f}|a \rangle C_{i}^{a}+
\sum_{abij}\langle ij | \hat{v}| ab \rangle C_{ij}^{ab}.
\]</div>
<p>This equation determines the correlation energy but not the coefficients <span class="math notranslate nohighlight">\(C\)</span>.</p>
</div>
<div class="section" id="rewriting-the-fci-equation-does-not-stop-here">
<h2><span class="section-number">3.24. </span>Rewriting the FCI equation, does not stop here<a class="headerlink" href="#rewriting-the-fci-equation-does-not-stop-here" title="Permalink to this headline">¶</a></h2>
<p>We need more equations. Our next step is to set up</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi_i^a | \hat{H} -E| \Phi_0\rangle + \sum_{bj}\langle \Phi_i^a | \hat{H} -E|\Phi_{j}^{b} \rangle C_{j}^{b}+
\sum_{bcjk}\langle \Phi_i^a | \hat{H} -E|\Phi_{jk}^{bc} \rangle C_{jk}^{bc}+
\sum_{bcdjkl}\langle \Phi_i^a | \hat{H} -E|\Phi_{jkl}^{bcd} \rangle C_{jkl}^{bcd}=0,
\]</div>
<p>as this equation will allow us to find an expression for the coefficents <span class="math notranslate nohighlight">\(C_i^a\)</span> since we can rewrite this equation as</p>
<div class="math notranslate nohighlight">
\[
\langle i | \hat{f}| a\rangle +\langle \Phi_i^a | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+ \sum_{bj\ne ai}\langle \Phi_i^a | \hat{H}|\Phi_{j}^{b} \rangle C_{j}^{b}+
\sum_{bcjk}\langle \Phi_i^a | \hat{H}|\Phi_{jk}^{bc} \rangle C_{jk}^{bc}+
\sum_{bcdjkl}\langle \Phi_i^a | \hat{H}|\Phi_{jkl}^{bcd} \rangle C_{jkl}^{bcd}=EC_i^a.
\]</div>
</div>
<div class="section" id="rewriting-the-fci-equation-please-stop-here">
<h2><span class="section-number">3.25. </span>Rewriting the FCI equation, please stop here<a class="headerlink" href="#rewriting-the-fci-equation-please-stop-here" title="Permalink to this headline">¶</a></h2>
<p>We see that on the right-hand side we have the energy <span class="math notranslate nohighlight">\(E\)</span>. This leads to a non-linear equation in the unknown coefficients.
These equations are normally solved iteratively ( that is we can start with a guess for the coefficients <span class="math notranslate nohighlight">\(C_i^a\)</span>). A common choice is to use perturbation theory for the first guess, setting thereby</p>
<div class="math notranslate nohighlight">
\[
C_{i}^{a}=\frac{\langle i | \hat{f}| a\rangle}{\epsilon_i-\epsilon_a}.
\]</div>
</div>
<div class="section" id="rewriting-the-fci-equation-more-to-add">
<h2><span class="section-number">3.26. </span>Rewriting the FCI equation, more to add<a class="headerlink" href="#rewriting-the-fci-equation-more-to-add" title="Permalink to this headline">¶</a></h2>
<p>The observant reader will however see that we need an equation for <span class="math notranslate nohighlight">\(C_{jk}^{bc}\)</span> and <span class="math notranslate nohighlight">\(C_{jkl}^{bcd}\)</span> as well.
To find equations for these coefficients we need then to continue our multiplications from the left with the various
<span class="math notranslate nohighlight">\(\Phi_{H}^P\)</span> terms.</p>
<p>For <span class="math notranslate nohighlight">\(C_{jk}^{bc}\)</span> we need then</p>
<p>4
4</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\sum_{cdkl}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{kl}^{cd} \rangle C_{kl}^{cd}+\sum_{cdeklm}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{klm}^{cde} \rangle C_{klm}^{cde}+\sum_{cdefklmn}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{klmn}^{cdef} \rangle C_{klmn}^{cdef}=0,
\]</div>
<p>and we can isolate the coefficients <span class="math notranslate nohighlight">\(C_{kl}^{cd}\)</span> in a similar way as we did for the coefficients <span class="math notranslate nohighlight">\(C_{i}^{a}\)</span>.</p>
</div>
<div class="section" id="id14">
<h2><span class="section-number">3.27. </span>Rewriting the FCI equation, more to add<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>A standard choice for the first iteration is to set</p>
<div class="math notranslate nohighlight">
\[
C_{ij}^{ab} =\frac{\langle ij \vert \hat{v} \vert ab \rangle}{\epsilon_i+\epsilon_j-\epsilon_a-\epsilon_b}.
\]</div>
<p>At the end we can rewrite our solution of the Schroedinger equation in terms of <span class="math notranslate nohighlight">\(n\)</span> coupled equations for the coefficients <span class="math notranslate nohighlight">\(C_H^P\)</span>.
This is a very cumbersome way of solving the equation. However, by using this iterative scheme we can illustrate how we can compute the
various terms in the wave operator or correlation operator <span class="math notranslate nohighlight">\(\hat{C}\)</span>. We will later identify the calculation of the various terms <span class="math notranslate nohighlight">\(C_H^P\)</span>
as parts of different many-body approximations to full CI. In particular, we can  relate this non-linear scheme with Coupled Cluster theory and
many-body perturbation theory.</p>
</div>
<div class="section" id="summarizing-fci-and-bringing-in-approximative-methods">
<h2><span class="section-number">3.28. </span>Summarizing FCI and bringing in approximative methods<a class="headerlink" href="#summarizing-fci-and-bringing-in-approximative-methods" title="Permalink to this headline">¶</a></h2>
<p>If we can diagonalize large matrices, FCI is the method of choice since:</p>
<ul class="simple">
<li><p>It gives all eigenvalues, ground state and excited states</p></li>
<li><p>The eigenvectors are obtained directly from the coefficients <span class="math notranslate nohighlight">\(C_H^P\)</span> which result from the diagonalization</p></li>
<li><p>We can compute easily expectation values of other operators, as well as transition probabilities</p></li>
<li><p>Correlations are easy to understand in terms of contributions to a given operator beyond the Hartree-Fock contribution. This is the standard approach in  many-body theory.</p></li>
</ul>
</div>
<div class="section" id="definition-of-the-correlation-energy">
<h2><span class="section-number">3.29. </span>Definition of the correlation energy<a class="headerlink" href="#definition-of-the-correlation-energy" title="Permalink to this headline">¶</a></h2>
<p>The correlation energy is defined as, with a two-body Hamiltonian,</p>
<div class="math notranslate nohighlight">
\[
\Delta E=\sum_{ai}\langle i| \hat{f}|a \rangle C_{i}^{a}+
\sum_{abij}\langle ij | \hat{v}| ab \rangle C_{ij}^{ab}.
\]</div>
<p>The coefficients <span class="math notranslate nohighlight">\(C\)</span> result from the solution of the eigenvalue problem.
The energy of say the ground state is then</p>
<div class="math notranslate nohighlight">
\[
E=E_{ref}+\Delta E,
\]</div>
<p>where the so-called reference energy is the energy we obtain from a Hartree-Fock calculation, that is</p>
<div class="math notranslate nohighlight">
\[
E_{ref}=\langle \Phi_0 \vert \hat{H} \vert \Phi_0 \rangle.
\]</div>
</div>
<div class="section" id="fci-equation-and-the-coefficients">
<h2><span class="section-number">3.30. </span>FCI equation and the coefficients<a class="headerlink" href="#fci-equation-and-the-coefficients" title="Permalink to this headline">¶</a></h2>
<p>However, as we have seen, even for a small case like the four first major shells and a nucleus like oxygen-16, the dimensionality becomes quickly intractable. If we wish to include single-particle states that reflect weakly bound systems, we need a much larger single-particle basis. We need thus approximative methods that sum specific correlations to infinite order.</p>
<p>Popular methods are</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.sciencedirect.com/science/article/pii/0370157395000126">Many-body perturbation theory (in essence a Taylor expansion)</a></p></li>
<li><p><a class="reference external" href="http://iopscience.iop.org/article/10.1088/0034-4885/77/9/096302/meta">Coupled cluster theory (coupled non-linear equations)</a></p></li>
<li><p>Green’s function approaches (matrix inversion)</p></li>
<li><p><a class="reference external" href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.222502">Similarity group transformation methods (coupled ordinary differential equations)</a></p></li>
</ul>
<p>All these methods start normally with a Hartree-Fock basis as the calculational basis.</p>
</div>
<div class="section" id="important-ingredients-to-have-in-codes">
<h2><span class="section-number">3.31. </span>Important ingredients to have in codes<a class="headerlink" href="#important-ingredients-to-have-in-codes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Be able to validate and verify  the  algorithms.</p></li>
<li><p>Include concepts like unit testing. Gives the possibility to test and validate several or all parts of the code.</p></li>
<li><p>Validation and verification are then included <em>naturally</em> and one can develop a better attitude to what is meant with an ethically sound scientific approach.</p></li>
</ul>
</div>
<div class="section" id="a-structured-approach-to-solving-problems">
<h2><span class="section-number">3.32. </span>A structured approach to solving problems<a class="headerlink" href="#a-structured-approach-to-solving-problems" title="Permalink to this headline">¶</a></h2>
<p>In the steps that lead to the development of clean code you should  think of</p>
<ol class="simple">
<li><p>How to structure a code in terms of functions  (use IDEs or advanced text editors like sublime or atom)</p></li>
<li><p>How to make a module</p></li>
<li><p>How to read input data flexibly from the command line or files</p></li>
<li><p>How to create graphical/web user interfaces</p></li>
<li><p>How to write unit tests</p></li>
<li><p>How to refactor code in terms of classes (instead of functions only)</p></li>
<li><p>How to conduct and automate large-scale numerical experiments</p></li>
<li><p>How to write scientific reports in various formats (LaTeX, HTML, doconce)</p></li>
</ol>
</div>
<div class="section" id="additional-benefits">
<h2><span class="section-number">3.33. </span>Additional benefits<a class="headerlink" href="#additional-benefits" title="Permalink to this headline">¶</a></h2>
<p>Many of the above aspetcs  will save you a lot of time when you incrementally extend software over time from simpler to more complicated problems. In particular, you will benefit from many good habits:</p>
<ol class="simple">
<li><p>New code is added in a modular fashion to a library (modules)</p></li>
<li><p>Programs are run through convenient user interfaces</p></li>
<li><p>It takes one quick command to let all your code undergo heavy testing</p></li>
<li><p>Tedious manual work with running programs is automated,</p></li>
<li><p>Your scientific investigations are reproducible, scientific reports with top quality typesetting are produced both for paper and electronic devices. Use version control software like <a class="reference external" href="https://git-scm.com/">git</a> and repositories like <a class="reference external" href="https://github.com/">github</a></p></li>
</ol>
</div>
<div class="section" id="unit-testing">
<h2><span class="section-number">3.34. </span>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h2>
<p>Unit Testing is the practice of testing the smallest testable parts,
called units, of an application individually and independently to
determine if they behave exactly as expected.</p>
<p>Unit tests (short code
fragments) are usually written such that they can be preformed at any
time during the development to continually verify the behavior of the
code.</p>
<p>In this way, possible bugs will be identified early in the
development cycle, making the debugging at later stages much
easier.</p>
</div>
<div class="section" id="unit-testing-benefits">
<h2><span class="section-number">3.35. </span>Unit Testing, benefits<a class="headerlink" href="#unit-testing-benefits" title="Permalink to this headline">¶</a></h2>
<p>There are many benefits associated with Unit Testing, such as</p>
<ul class="simple">
<li><p>It increases confidence in changing and maintaining code. Big changes can be made to the code quickly, since the tests will ensure that everything still is working properly.</p></li>
<li><p>Since the code needs to be modular to make Unit Testing possible, the code will be easier to reuse. This improves the code design.</p></li>
<li><p>Debugging is easier, since when a test fails, only the latest changes need to be debugged.</p></li>
<li><p>Different parts of a project can be tested without the need to wait for the other parts to be available.</p></li>
<li><p>A unit test can serve as a documentation on the functionality of a unit of the code.</p></li>
</ul>
</div>
<div class="section" id="simple-example-of-unit-test">
<h2><span class="section-number">3.36. </span>Simple example of unit test<a class="headerlink" href="#simple-example-of-unit-test" title="Permalink to this headline">¶</a></h2>
<p>Look up the guide on how to install unit tests for c++ at course webpage. This is the version with classes.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &lt;unittest++/UnitTest++.h&gt;
    
    class MyMultiplyClass{
    public:
        double multiply(double x, double y) {
            return x * y;
        }
    };
    
    TEST(MyMath) {
        MyMultiplyClass my;
        CHECK_EQUAL(56, my.multiply(7,8));
    }
    
    int main()
    {
        return UnitTest::RunAllTests();
    }
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2><span class="section-number">3.37. </span>Simple example of unit test<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>And without classes</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &lt;unittest++/UnitTest++.h&gt;
    
    
    double multiply(double x, double y) {
        return x * y;
    }
    
    TEST(MyMath) {
        CHECK_EQUAL(56, multiply(7,8));
    }
    
    int main()
    {
        return UnitTest::RunAllTests();
    } 
</pre></div>
</div>
<p>For Fortran users, the link at <a class="reference external" href="http://sourceforge.net/projects/fortranxunit/">http://sourceforge.net/projects/fortranxunit/</a> contains a similar
software for unit testing. For Python go to <a class="reference external" href="https://docs.python.org/2/library/unittest.html">https://docs.python.org/2/library/unittest.html</a>.</p>
</div>
<div class="section" id="unit-tests">
<h2><span class="section-number">3.38. </span><a class="reference external" href="https://github.com/philsquared/Catch/blob/master/docs/tutorial.md">Unit tests</a><a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h2>
<p>There are many types of <strong>unit test</strong> libraries. One which is very popular with C++ programmers is <a class="reference external" href="https://github.com/philsquared/Catch/blob/master/docs/tutorial.md">Catch</a></p>
<p>Catch is header only. All you need to do is drop the file(s) somewhere reachable from your project - either in some central location you can set your header search path to find, or directly into your project tree itself!</p>
<p>This is a particularly good option for other Open-Source projects that want to use Catch for their test suite.</p>
</div>
<div class="section" id="examples">
<h2><span class="section-number">3.39. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Computing factorials</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    inline unsigned int Factorial( unsigned int number ) {
      return number &gt; 1 ? Factorial(number-1)*number : 1;
    }
</pre></div>
</div>
</div>
<div class="section" id="factorial-example">
<h2><span class="section-number">3.40. </span>Factorial Example<a class="headerlink" href="#factorial-example" title="Permalink to this headline">¶</a></h2>
<p>Simple test where we put everything in a single file</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #define CATCH_CONFIG_MAIN  // This tells Catch to provide a main()
    #include &quot;catch.hpp&quot;
    inline unsigned int Factorial( unsigned int number ) {
      return number &gt; 1 ? Factorial(number-1)*number : 1;
    }
    
    TEST_CASE( &quot;Factorials are computed&quot;, &quot;[factorial]&quot; ) {
        REQUIRE( Factorial(0) == 1 );
        REQUIRE( Factorial(1) == 1 );
        REQUIRE( Factorial(2) == 2 );
        REQUIRE( Factorial(3) == 6 );
        REQUIRE( Factorial(10) == 3628800 );
    }
</pre></div>
</div>
<p>This will compile to a complete executable which responds to command line arguments. If you just run it with no arguments it will execute all test cases (in this case there is just one), report any failures, report a summary of how many tests passed and failed and return the number of failed tests.</p>
</div>
<div class="section" id="what-did-we-do-1">
<h2><span class="section-number">3.41. </span>What did we do (1)?<a class="headerlink" href="#what-did-we-do-1" title="Permalink to this headline">¶</a></h2>
<p>All we did was</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #define 
</pre></div>
</div>
<p>one identifier and</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include 
</pre></div>
</div>
<p>one header and we got everything - even an implementation of main() that will respond to command line arguments.
Once you have more than one file with unit tests in you’ll just need to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #include &quot;catch.hpp&quot; 
</pre></div>
</div>
<p>and go. Usually it’s a good idea to have a dedicated implementation file that just has</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    #define CATCH_CONFIG_MAIN 
    #include &quot;catch.hpp&quot;. 
</pre></div>
</div>
<p>You can also provide your own implementation of main and drive Catch yourself.</p>
</div>
<div class="section" id="what-did-we-do-2">
<h2><span class="section-number">3.42. </span>What did we do (2)?<a class="headerlink" href="#what-did-we-do-2" title="Permalink to this headline">¶</a></h2>
<p>We introduce test cases with the</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    TEST_CASE 
</pre></div>
</div>
<p>macro.</p>
<p>The test name must be unique. You can run sets of tests by specifying a wildcarded test name or a tag expression.
All we did was <strong>define</strong> one identifier and <strong>include</strong> one header and we got everything.</p>
<p>We write our individual test assertions using the</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    REQUIRE 
</pre></div>
</div>
<p>macro.</p>
</div>
<div class="section" id="unit-test-summary-and-testing-approach">
<h2><span class="section-number">3.43. </span>Unit test summary and testing approach<a class="headerlink" href="#unit-test-summary-and-testing-approach" title="Permalink to this headline">¶</a></h2>
<p>Three levels of tests</p>
<ol class="simple">
<li><p>Microscopic level: testing small parts of code, use often unit test libraries</p></li>
<li><p>Mesoscopic level: testing the integration of various parts  of your code</p></li>
<li><p>Macroscopic level: testing that the final result is ok</p></li>
</ol>
</div>
<div class="section" id="coding-recommendations">
<h2><span class="section-number">3.44. </span>Coding Recommendations<a class="headerlink" href="#coding-recommendations" title="Permalink to this headline">¶</a></h2>
<p>Writing clean and clear code is an art and reflects
your understanding of</p>
<ol class="simple">
<li><p>derivation, verification, and implementation of algorithms</p></li>
<li><p>what can go wrong with algorithms</p></li>
<li><p>overview of important, known algorithms</p></li>
<li><p>how algorithms are used to solve mathematical problems</p></li>
<li><p>reproducible science and ethics</p></li>
<li><p>algorithmic thinking for gaining deeper insights about scientific problems</p></li>
</ol>
<p>Computing is understanding and your understanding is reflected in your abilities to
write clear and clean code.</p>
</div>
<div class="section" id="summary-and-recommendations">
<h2><span class="section-number">3.45. </span>Summary and recommendations<a class="headerlink" href="#summary-and-recommendations" title="Permalink to this headline">¶</a></h2>
<p>Some simple hints and tips in order to write clean and clear code</p>
<ol class="simple">
<li><p>Spell out the algorithm and have a top-down approach to the flow of data</p></li>
<li><p>Start with coding as close as possible to eventual mathematical expressions</p></li>
<li><p>Use meaningful names for variables</p></li>
<li><p>Split tasks in simple functions and modules/classes</p></li>
<li><p>Functions should return as few as possible variables</p></li>
<li><p>Use unit tests and make sure your codes are producing the correct results</p></li>
<li><p>Where possible use symbolic coding to autogenerate code and check results</p></li>
<li><p>Make a proper timing of your algorithms</p></li>
<li><p>Use version control and make your science reproducible</p></li>
<li><p>Use IDEs or smart editors with debugging and analysis tools.</p></li>
<li><p>Automatize your computations interfacing high-level and compiled languages like C++ and Fortran.</p></li>
<li><p>…..</p></li>
</ol>
</div>
<div class="section" id="building-a-many-body-basis">
<h2><span class="section-number">3.46. </span>Building a many-body basis<a class="headerlink" href="#building-a-many-body-basis" title="Permalink to this headline">¶</a></h2>
<p>Here we will discuss how we can set up a single-particle basis which we can use in the various parts of our projects, from the simple pairing model to infinite nuclear matter. We will use here the simple pairing model to illustrate in particular how to set up a single-particle basis. We will also use this do discuss standard FCI approaches like:</p>
<ol class="simple">
<li><p>Standard shell-model basis in one or two major shells</p></li>
<li><p>Full CI in a given basis and no truncations</p></li>
<li><p>CISD and CISDT approximations</p></li>
<li><p>No-core shell model and truncation in excitation energy</p></li>
</ol>
</div>
<div class="section" id="id16">
<h2><span class="section-number">3.47. </span>Building a many-body basis<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>An important step in an FCI code  is to construct the many-body basis.</p>
<p>While the formalism is independent of the choice of basis, the <strong>effectiveness</strong> of a calculation
will certainly be basis dependent.</p>
<p>Furthermore there are common conventions useful to know.</p>
<p>First, the single-particle basis has angular momentum as a good quantum number.  You can
imagine the single-particle wavefunctions being generated by a one-body Hamiltonian,
for example a harmonic oscillator.  Modifications include harmonic oscillator plus
spin-orbit splitting, or self-consistent mean-field potentials, or the Woods-Saxon potential which mocks
up the self-consistent mean-field.
For nuclei, the harmonic oscillator, modified by spin-orbit splitting, provides a useful language
for describing single-particle states.</p>
</div>
<div class="section" id="id17">
<h2><span class="section-number">3.48. </span>Building a many-body basis<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>Each single-particle state is labeled by the following quantum numbers:</p>
<ul class="simple">
<li><p>Orbital angular momentum <span class="math notranslate nohighlight">\(l\)</span></p></li>
<li><p>Intrinsic spin <span class="math notranslate nohighlight">\(s\)</span> = 1/2 for protons and neutrons</p></li>
<li><p>Angular momentum <span class="math notranslate nohighlight">\(j = l \pm 1/2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(z\)</span>-component <span class="math notranslate nohighlight">\(j_z\)</span> (or <span class="math notranslate nohighlight">\(m\)</span>)</p></li>
<li><p>Some labeling of the radial wavefunction, typically <span class="math notranslate nohighlight">\(n\)</span> the number of nodes in  the radial wavefunction, but in the case of harmonic oscillator one can also use the principal quantum number <span class="math notranslate nohighlight">\(N\)</span>, where the harmonic oscillator energy is <span class="math notranslate nohighlight">\((N+3/2)\hbar \omega\)</span>.</p></li>
</ul>
<p>In this format one labels states by <span class="math notranslate nohighlight">\(n(l)_j\)</span>, with <span class="math notranslate nohighlight">\((l)\)</span> replaced by a letter:
<span class="math notranslate nohighlight">\(s\)</span> for <span class="math notranslate nohighlight">\(l=0\)</span>, <span class="math notranslate nohighlight">\(p\)</span> for <span class="math notranslate nohighlight">\(l=1\)</span>, <span class="math notranslate nohighlight">\(d\)</span> for <span class="math notranslate nohighlight">\(l=2\)</span>, <span class="math notranslate nohighlight">\(f\)</span> for <span class="math notranslate nohighlight">\(l=3\)</span>, and thenceforth alphabetical.</p>
</div>
<div class="section" id="id18">
<h2><span class="section-number">3.49. </span>Building a many-body basis<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>In practice the single-particle space has to be severely truncated.  This truncation is
typically based upon the single-particle energies, which is the effective energy
from a mean-field potential.</p>
<p>Sometimes we freeze the core and only consider a valence space. For example, one
may assume a frozen <span class="math notranslate nohighlight">\(^{4}\mbox{He}\)</span> core, with two protons and two neutrons in the <span class="math notranslate nohighlight">\(0s_{1/2}\)</span>
shell, and then only allow active particles in the <span class="math notranslate nohighlight">\(0p_{1/2}\)</span> and <span class="math notranslate nohighlight">\(0p_{3/2}\)</span> orbits.</p>
<p>Another example is a frozen <span class="math notranslate nohighlight">\(^{16}\mbox{O}\)</span> core, with eight protons and eight neutrons filling the
<span class="math notranslate nohighlight">\(0s_{1/2}\)</span>,  <span class="math notranslate nohighlight">\(0p_{1/2}\)</span> and <span class="math notranslate nohighlight">\(0p_{3/2}\)</span> orbits, with valence particles in the
<span class="math notranslate nohighlight">\(0d_{5/2}, 1s_{1/2}\)</span> and <span class="math notranslate nohighlight">\(0d_{3/2}\)</span> orbits.</p>
<p>Sometimes we refer to nuclei by the valence space where their last nucleons go.<br />
So, for example, we call <span class="math notranslate nohighlight">\(^{12}\mbox{C}\)</span> a <span class="math notranslate nohighlight">\(p\)</span>-shell nucleus, while <span class="math notranslate nohighlight">\(^{26}\mbox{Al}\)</span> is an
<span class="math notranslate nohighlight">\(sd\)</span>-shell nucleus and <span class="math notranslate nohighlight">\(^{56}\mbox{Fe}\)</span> is a <span class="math notranslate nohighlight">\(pf\)</span>-shell nucleus.</p>
</div>
<div class="section" id="id19">
<h2><span class="section-number">3.50. </span>Building a many-body basis<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>There are different kinds of truncations.</p>
<ul class="simple">
<li><p>For example, one can start with `filled’ orbits (almost always the lowest), and then  allow one, two, three… particles excited out of those filled orbits. These are called  1p-1h, 2p-2h, 3p-3h excitations.</p></li>
<li><p>Alternately, one can state a maximal orbit and allow all possible configurations with  particles occupying states up to that maximum. This is called <em>full configuration</em>.</p></li>
<li><p>Finally, for particular use in nuclear physics, there is the <em>energy</em> truncation, also  called the <span class="math notranslate nohighlight">\(N\hbar\Omega\)</span> or <span class="math notranslate nohighlight">\(N_{max}\)</span> truncation.</p></li>
</ul>
</div>
<div class="section" id="id20">
<h2><span class="section-number">3.51. </span>Building a many-body basis<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>Here one works in a harmonic oscillator basis, with each major oscillator shell assigned  a principal quantum number <span class="math notranslate nohighlight">\(N=0,1,2,3,...\)</span>.
The <span class="math notranslate nohighlight">\(N\hbar\Omega\)</span> or <span class="math notranslate nohighlight">\(N_{max}\)</span> truncation: Any configuration is given an noninteracting energy, which is the sum
of the single-particle harmonic oscillator energies. (Thus this ignores
spin-orbit splitting.)</p>
<p>Excited state are labeled relative to the lowest configuration by the
number of harmonic oscillator quanta.</p>
<p>This truncation is useful because if one includes <em>all</em> configuration up to
some <span class="math notranslate nohighlight">\(N_{max}\)</span>, and has a translationally invariant interaction, then the intrinsic
motion and the center-of-mass motion factor. In other words, we can know exactly
the center-of-mass wavefunction.</p>
<p>In almost all cases, the many-body Hamiltonian is rotationally invariant. This means
it commutes with the operators <span class="math notranslate nohighlight">\(\hat{J}^2, \hat{J}_z\)</span> and so eigenstates will have
good <span class="math notranslate nohighlight">\(J,M\)</span>. Furthermore, the eigenenergies do not depend upon the orientation <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>Therefore we can choose to construct a many-body basis which has fixed <span class="math notranslate nohighlight">\(M\)</span>; this is
called an <span class="math notranslate nohighlight">\(M\)</span>-scheme basis.</p>
<p>Alternately, one can construct a many-body basis which has fixed <span class="math notranslate nohighlight">\(J\)</span>, or a <span class="math notranslate nohighlight">\(J\)</span>-scheme
basis.</p>
</div>
<div class="section" id="id21">
<h2><span class="section-number">3.52. </span>Building a many-body basis<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<p>The Hamiltonian matrix will have smaller dimensions (a factor of 10 or more) in the <span class="math notranslate nohighlight">\(J\)</span>-scheme than in the <span class="math notranslate nohighlight">\(M\)</span>-scheme.
On the other hand, as we’ll show in the next slide, the <span class="math notranslate nohighlight">\(M\)</span>-scheme is very easy to
construct with Slater determinants, while the <span class="math notranslate nohighlight">\(J\)</span>-scheme basis states, and thus the
matrix elements, are more complicated, almost always being linear combinations of
<span class="math notranslate nohighlight">\(M\)</span>-scheme states. <span class="math notranslate nohighlight">\(J\)</span>-scheme bases are important and useful, but we’ll focus on the
simpler <span class="math notranslate nohighlight">\(M\)</span>-scheme.</p>
<p>The quantum number <span class="math notranslate nohighlight">\(m\)</span> is additive (because the underlying group is Abelian):
if a Slater determinant <span class="math notranslate nohighlight">\(\hat{a}_i^\dagger \hat{a}^\dagger_j \hat{a}^\dagger_k \ldots | 0 \rangle\)</span>
is built from single-particle states all with good <span class="math notranslate nohighlight">\(m\)</span>, then the total</p>
<div class="math notranslate nohighlight">
\[
M = m_i + m_j + m_k + \ldots
\]</div>
<p>This is <em>not</em> true of <span class="math notranslate nohighlight">\(J\)</span>, because the angular momentum group SU(2) is not Abelian.</p>
</div>
<div class="section" id="id22">
<h2><span class="section-number">3.53. </span>Building a many-body basis<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>The upshot is that</p>
<ul class="simple">
<li><p>It is easy to construct a Slater determinant with good total <span class="math notranslate nohighlight">\(M\)</span>;</p></li>
<li><p>It is trivial to calculate <span class="math notranslate nohighlight">\(M\)</span> for each Slater determinant;</p></li>
<li><p>So it is easy to construct an <span class="math notranslate nohighlight">\(M\)</span>-scheme basis with fixed total <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
</ul>
<p>Note that the individual <span class="math notranslate nohighlight">\(M\)</span>-scheme basis states will <em>not</em>, in general,
have good total <span class="math notranslate nohighlight">\(J\)</span>.
Because the Hamiltonian is rotationally invariant, however, the eigenstates will
have good <span class="math notranslate nohighlight">\(J\)</span>. (The situation is muddied when one has states of different <span class="math notranslate nohighlight">\(J\)</span> that are
nonetheless degenerate.)</p>
</div>
<div class="section" id="id23">
<h2><span class="section-number">3.54. </span>Building a many-body basis<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>Example: two <span class="math notranslate nohighlight">\(j=1/2\)</span> orbits</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$j$</th> <th align="center">$m_j$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
</tbody>
</table>
Note that the order is arbitrary.
</div>
<div class="section" id="id24">
<h2><span class="section-number">3.55. </span>Building a many-body basis<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<p>There are <span class="math notranslate nohighlight">\(\left ( \begin{array}{c} 4 \\ 2 \end{array} \right) = 6\)</span> two-particle states,
which we list with the total <span class="math notranslate nohighlight">\(M\)</span>:</p>
<table border="1">
<thead>
<tr><th align="center">Occupied</th> <th align="center">$M$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1,2         </td> <td align="center">   0      </td> </tr>
<tr><td align="center">   1,3         </td> <td align="center">   -1     </td> </tr>
<tr><td align="center">   1,4         </td> <td align="center">   0      </td> </tr>
<tr><td align="center">   2,3         </td> <td align="center">   0      </td> </tr>
<tr><td align="center">   2,4         </td> <td align="center">   1      </td> </tr>
<tr><td align="center">   3,4         </td> <td align="center">   0      </td> </tr>
</tbody>
</table>
There are 4 states with $M= 0$, 
and 1 each with $M = \pm 1$.
</div>
<div class="section" id="id25">
<h2><span class="section-number">3.56. </span>Building a many-body basis<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<p>As another example, consider using only single particle states from the <span class="math notranslate nohighlight">\(0d_{5/2}\)</span> space.
They have the following quantum numbers</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$j$</th> <th align="center">$m_j$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -5/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -3/2     </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   3/2      </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   5/2      </td> </tr>
</tbody>
</table>
</div>
<div class="section" id="id26">
<h2><span class="section-number">3.57. </span>Building a many-body basis<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<p>There are <span class="math notranslate nohighlight">\(\left ( \begin{array}{c} 6 \\ 2 \end{array} \right) = 15\)</span> two-particle states,
which we list with the total <span class="math notranslate nohighlight">\(M\)</span>:</p>
<table border="1">
<thead>
<tr><th align="center">Occupied</th> <th align="center">$M$</th> <th align="center">Occupied</th> <th align="center">$M$</th> <th align="center">Occupied</th> <th align="center">$M$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1,2         </td> <td align="center">   -4     </td> <td align="center">   2,3         </td> <td align="center">   -2     </td> <td align="center">   3,5         </td> <td align="center">   1      </td> </tr>
<tr><td align="center">   1,3         </td> <td align="center">   -3     </td> <td align="center">   2,4         </td> <td align="center">   -1     </td> <td align="center">   3,6         </td> <td align="center">   2      </td> </tr>
<tr><td align="center">   1,4         </td> <td align="center">   -2     </td> <td align="center">   2,5         </td> <td align="center">   0      </td> <td align="center">   4,5         </td> <td align="center">   2      </td> </tr>
<tr><td align="center">   1,5         </td> <td align="center">   -1     </td> <td align="center">   2,6         </td> <td align="center">   1      </td> <td align="center">   4,6         </td> <td align="center">   3      </td> </tr>
<tr><td align="center">   1,6         </td> <td align="center">   0      </td> <td align="center">   3,4         </td> <td align="center">   0      </td> <td align="center">   5,6         </td> <td align="center">   4      </td> </tr>
</tbody>
</table>
There are 3 states with $M= 0$, 2 with $M = 1$, and so on.
</div>
<div class="section" id="shell-model-project">
<h2><span class="section-number">3.58. </span>Shell-model project<a class="headerlink" href="#shell-model-project" title="Permalink to this headline">¶</a></h2>
<p>The first step  is to construct the <span class="math notranslate nohighlight">\(M\)</span>-scheme basis of Slater determinants.
Here <span class="math notranslate nohighlight">\(M\)</span>-scheme means the total <span class="math notranslate nohighlight">\(J_z\)</span> of the many-body states is fixed.</p>
<p>The steps could be:</p>
<ul class="simple">
<li><p>Read in a user-supplied file of single-particle states (examples can be given) or just code these internally;</p></li>
<li><p>Ask for the total <span class="math notranslate nohighlight">\(M\)</span> of the system and the number of particles <span class="math notranslate nohighlight">\(N\)</span>;</p></li>
<li><p>Construct all the <span class="math notranslate nohighlight">\(N\)</span>-particle states with given <span class="math notranslate nohighlight">\(M\)</span>.  You will validate the code by  comparing both the number of states and specific states.</p></li>
</ul>
</div>
<div class="section" id="id27">
<h2><span class="section-number">3.59. </span>Shell-model project<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<p>The format of a possible input  file could be</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$2j$</th> <th align="center">$2m_j$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1       </td> <td align="center">   -1        </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1       </td> <td align="center">   1         </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   3       </td> <td align="center">   -3        </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   3       </td> <td align="center">   -1        </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   3       </td> <td align="center">   1         </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   3       </td> <td align="center">   3         </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   -5        </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   -3        </td> </tr>
<tr><td align="center">   9        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   -1        </td> </tr>
<tr><td align="center">   10       </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   1         </td> </tr>
<tr><td align="center">   11       </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   3         </td> </tr>
<tr><td align="center">   12       </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5       </td> <td align="center">   5         </td> </tr>
</tbody>
</table>
This represents the $1s_{1/2}0d_{3/2}0d_{5/2}$ valence space, or just the $sd$-space.  There are 
twelve single-particle states, labeled by an overall index, and which have associated quantum 
numbers the number of radial nodes, the orbital angular momentum $l$, and the 
angular momentum $j$ and third component $j_z$.  To keep everything as integers, we could store $2 \times j$ and 
$2 \times j_z$.
</div>
<div class="section" id="id28">
<h2><span class="section-number">3.60. </span>Shell-model project<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h2>
<p>To read in the single-particle states you need to:</p>
<ul class="simple">
<li><p>Open the file</p></li>
<li><p>Read the number of single-particle states (in the above example, 12);  allocate memory; all you need is a single array storing <span class="math notranslate nohighlight">\(2\times j_z\)</span> for each state, labeled by the index.</p></li>
<li><p>Read in the quantum numbers and store <span class="math notranslate nohighlight">\(2 \times j_z\)</span> (and anything else you happen to want).</p></li>
</ul>
</div>
<div class="section" id="id29">
<h2><span class="section-number">3.61. </span>Shell-model project<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<p>The next step is to read in the number of particles <span class="math notranslate nohighlight">\(N\)</span> and the fixed total <span class="math notranslate nohighlight">\(M\)</span> (or, actually, <span class="math notranslate nohighlight">\(2 \times M\)</span>).
For this project we assume only a single species of particles, say neutrons, although this can be
relaxed. <strong>Note</strong>: Although it is often a good idea to try to write a more general code, given the
short time alloted we would suggest you keep your ambition in check, at least in the initial phases of the
project.</p>
<p>You should probably write an error trap to make sure <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(M\)</span> are congruent; if <span class="math notranslate nohighlight">\(N\)</span> is even, then
<span class="math notranslate nohighlight">\(2 \times M\)</span> should be even, and if <span class="math notranslate nohighlight">\(N\)</span> is odd then <span class="math notranslate nohighlight">\(2\times M\)</span> should be odd.</p>
</div>
<div class="section" id="id30">
<h2><span class="section-number">3.62. </span>Shell-model project<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>The final step is to generate the set of <span class="math notranslate nohighlight">\(N\)</span>-particle Slater determinants with fixed <span class="math notranslate nohighlight">\(M\)</span>.
The Slater determinants will be stored in occupation representation.  Although in many codes
this representation is done compactly in bit notation with ones and zeros, but for
greater transparency and simplicity we will list the occupied single particle states.</p>
<p>Hence we can
store the Slater determinant basis states as <span class="math notranslate nohighlight">\(sd(i,j)\)</span>, that is an
array of dimension <span class="math notranslate nohighlight">\(N_{SD}\)</span>, the number of Slater determinants, by <span class="math notranslate nohighlight">\(N\)</span>, the number of occupied
state. So if for the 7th Slater determinant the 2nd, 3rd, and 9th single-particle states are occupied,
then <span class="math notranslate nohighlight">\(sd(7,1) = 2\)</span>, <span class="math notranslate nohighlight">\(sd(7,2) = 3\)</span>, and <span class="math notranslate nohighlight">\(sd(7,3) = 9\)</span>.</p>
</div>
<div class="section" id="id31">
<h2><span class="section-number">3.63. </span>Shell-model project<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>We can construct an occupation representation of Slater determinants by the <em>odometer</em>
method.  Consider <span class="math notranslate nohighlight">\(N_{sp} = 12\)</span> and <span class="math notranslate nohighlight">\(N=4\)</span>.
Start with the first 4 states occupied, that is:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sd(1,:)= 1,2,3,4\)</span> (also written as <span class="math notranslate nohighlight">\(|1,2,3,4 \rangle\)</span>)</p></li>
</ul>
<p>Now increase the last occupancy recursively:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sd(2,:)= 1,2,3,5\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(sd(3,:)= 1,2,3,6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(sd(4,:)= 1,2,3,7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(sd(9,:)= 1,2,3,12\)</span></p></li>
</ul>
<p>Then start over with</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sd(10,:)= 1,2,4,5\)</span></p></li>
</ul>
<p>and again increase the rightmost digit</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sd(11,:)= 1,2,4,6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(sd(12,:)= 1,2,4,7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(sd(17,:)= 1,2,4,12\)</span></p></li>
</ul>
</div>
<div class="section" id="id32">
<h2><span class="section-number">3.64. </span>Shell-model project<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h2>
<p>When we restrict ourselves to an <span class="math notranslate nohighlight">\(M\)</span>-scheme basis, we could choose two paths.
The first is simplest (and simplest is often best, at
least in the first draft of a code): generate all possible Slater determinants,
and then extract from this initial list a list of those Slater determinants with a given
<span class="math notranslate nohighlight">\(M\)</span>. (You will need to write a short function or routine that computes <span class="math notranslate nohighlight">\(M\)</span> for any
given occupation.)</p>
<p>Alternately, and not too difficult, is to run the odometer routine twice: each time, as
as a Slater determinant is calculated, compute <span class="math notranslate nohighlight">\(M\)</span>, but do not store the Slater determinants
except the current one. You can then count up the number of Slater determinants with a
chosen <span class="math notranslate nohighlight">\(M\)</span>.  Then allocated storage for the Slater determinants, and run the odometer
algorithm again, this time storing Slater determinants with the desired <span class="math notranslate nohighlight">\(M\)</span> (this can be
done with a simple logical flag).</p>
</div>
<div class="section" id="id33">
<h2><span class="section-number">3.65. </span>Shell-model project<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
<p><em>Some example solutions</em>:  Let’s begin with a simple case, the <span class="math notranslate nohighlight">\(0d_{5/2}\)</span> space containing six single-particle states</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$j$</th> <th align="center">$m_j$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -5/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -3/2     </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   3/2      </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0      </td> <td align="center">   2      </td> <td align="center">   5/2    </td> <td align="center">   5/2      </td> </tr>
</tbody>
</table>
For two particles, there are a total of 15 states, which we list here with the total $M$:
* $\vert 1,2 \rangle$, $M= -4$,  $\vert 1,3 \rangle$, $M= -3$
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vert  1,4 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= -2\)</span>, <span class="math notranslate nohighlight">\(\vert 1,5 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= -1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 1,5 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 0\)</span>, <span class="math notranslate nohighlight">\(vert 2,3 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= -2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 2,4 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= -1\)</span>, <span class="math notranslate nohighlight">\(\vert 2,5 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 2,6 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 1\)</span>, <span class="math notranslate nohighlight">\(\vert 3,4 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 3,5 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 1\)</span>, <span class="math notranslate nohighlight">\(\vert 3,6 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 4,5 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 2\)</span>, <span class="math notranslate nohighlight">\(\vert 4,6 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vert 5,6 \rangle\)</span>, <span class="math notranslate nohighlight">\(M= 4\)</span></p></li>
</ul>
<p>Of these, there are only 3 states with <span class="math notranslate nohighlight">\(M=0\)</span>.</p>
</div>
<div class="section" id="id34">
<h2><span class="section-number">3.66. </span>Shell-model project<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<p><em>You should try</em> by hand to show that in this same single-particle space, that for
<span class="math notranslate nohighlight">\(N=3\)</span> there are 3 states with <span class="math notranslate nohighlight">\(M=1/2\)</span> and for <span class="math notranslate nohighlight">\(N= 4\)</span> there are also only 3 states with <span class="math notranslate nohighlight">\(M=0\)</span>.</p>
<p><em>To test your code</em>, confirm the above.</p>
<p>Also,
for the <span class="math notranslate nohighlight">\(sd\)</span>-space given above, for <span class="math notranslate nohighlight">\(N=2\)</span> there are 14 states with <span class="math notranslate nohighlight">\(M=0\)</span>, for <span class="math notranslate nohighlight">\(N=3\)</span> there are 37
states with <span class="math notranslate nohighlight">\(M=1/2\)</span>, for <span class="math notranslate nohighlight">\(N=4\)</span> there are 81 states with <span class="math notranslate nohighlight">\(M=0\)</span>.</p>
</div>
<div class="section" id="id35">
<h2><span class="section-number">3.67. </span>Shell-model project<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
<p>For our project, we will only consider the pairing model.
A simple space is the <span class="math notranslate nohighlight">\((1/2)^2\)</span> space with four single-particle states</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$s$</th> <th align="center">$m_s$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
</tbody>
</table>
For $N=2$ there are 4 states with $M=0$; show this by hand and confirm your code reproduces it.
</div>
<div class="section" id="id36">
<h2><span class="section-number">3.68. </span>Shell-model project<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
<p>Another, slightly more challenging space is the <span class="math notranslate nohighlight">\((1/2)^4\)</span> space, that is,
with eight  single-particle states we have</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$s$</th> <th align="center">$m_s$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   2      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   2      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   3      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   3      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
</tbody>
</table>
For $N=2$ there are 16 states with $M=0$; for $N=3$ there are 24 states with $M=1/2$, and for 
$N=4$ there are 36 states with $M=0$.
</div>
<div class="section" id="id37">
<h2><span class="section-number">3.69. </span>Shell-model project<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h2>
<p>In the shell-model context we can interpret this as 4 <span class="math notranslate nohighlight">\(s_{1/2}\)</span> levels, with <span class="math notranslate nohighlight">\(m = \pm 1/2\)</span>, we can also think of these are simple four pairs,  <span class="math notranslate nohighlight">\(\pm k, k = 1,2,3,4\)</span>. Later on we will
assign single-particle energies,  depending on the radial quantum number <span class="math notranslate nohighlight">\(n\)</span>, that is,
<span class="math notranslate nohighlight">\(\epsilon_k = |k| \delta\)</span> so that they are equally spaced.</p>
</div>
<div class="section" id="id38">
<h2><span class="section-number">3.70. </span>Shell-model project<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h2>
<p>For application in the pairing model we can go further and consider only states with
no “broken pairs,” that is, if <span class="math notranslate nohighlight">\(+k\)</span> is filled (or <span class="math notranslate nohighlight">\(m = +1/2\)</span>, so is <span class="math notranslate nohighlight">\(-k\)</span> (<span class="math notranslate nohighlight">\(m=-1/2\)</span>).
If you want, you can write your code to accept only these, and obtain the following
six states:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(|           1,           2 ,          3         ,       4  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            1      ,     2        ,        5         ,       6 \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            1         ,       2     ,           7         ,       8  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            3        ,        4      ,          5          ,      6  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            3        ,        4      ,          7         ,       8  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            5        ,        6     ,           7     ,           8  \rangle \)</span></p></li>
</ul>
</div>
<div class="section" id="id39">
<h2><span class="section-number">3.71. </span>Shell-model project<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<p><strong>Hints for coding.</strong></p>
<ul class="simple">
<li><p>Write small modules (routines/functions) ; avoid big functions  that do everything. (But not too small.)</p></li>
<li><p>Use Unit tests! Write lots of error traps, even for things that are `obvious.’</p></li>
<li><p>Document as you go along. The Unit tests serve as documentation. For each function write a header that includes:</p></li>
</ul>
<p>a. Main purpose of function and/or unit test</p>
<p>b. names and  brief explanation of input variables, if any</p>
<p>c. names and brief explanation of output variables, if any</p>
<p>d. functions called by this function</p>
<p>e. called by which functions</p>
</div>
<div class="section" id="id40">
<h2><span class="section-number">3.72. </span>Shell-model project<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
<p>Hints for coding</p>
<ul class="simple">
<li><p>Unit tests will save time. Use also IDEs for debugging. If you insist on brute force debugging, print out intermediate values. It’s almost impossible to debug a  code by looking at it - the code will almost always win a `staring contest.’</p></li>
<li><p>Validate code with SIMPLE CASES. Validate early and often.  Unit tests!!</p></li>
</ul>
<p>The number one mistake is using a too complex a system to test. For example ,
if you are computing particles in a potential in a box, try removing the potential - you should get
particles in a box. And start with one particle, then two, then three… Don’t start with
eight particles.</p>
</div>
<div class="section" id="id41">
<h2><span class="section-number">3.73. </span>Shell-model project<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<p>Our recommended occupation representation, e.g. <span class="math notranslate nohighlight">\(| 1,2,4,8 \rangle\)</span>, is
easy to code, but numerically inefficient when one has hundreds of
millions of Slater determinants.</p>
<p>In state-of-the-art shell-model codes, one generally uses bit
representation, i.e. <span class="math notranslate nohighlight">\(|1101000100... \rangle\)</span> where one stores
the Slater determinant as a single (or a small number of) integer.</p>
<p>This is much more compact, but more intricate to code with considerable
more overhead. There exist
bit-manipulation functions. We will discuss these in more detail at the beginning of the third week.</p>
</div>
<div class="section" id="example-case-pairing-hamiltonian">
<h2><span class="section-number">3.74. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#example-case-pairing-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>We consider a space with <span class="math notranslate nohighlight">\(2\Omega\)</span> single-particle states, with each
state labeled by
<span class="math notranslate nohighlight">\(k = 1, 2, 3, \Omega\)</span> and <span class="math notranslate nohighlight">\(m = \pm 1/2\)</span>. The convention is that
the state with <span class="math notranslate nohighlight">\(k&gt;0\)</span> has <span class="math notranslate nohighlight">\(m = + 1/2\)</span> while <span class="math notranslate nohighlight">\(-k\)</span> has <span class="math notranslate nohighlight">\(m = -1/2\)</span>.</p>
<p>The Hamiltonian we consider is</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = -G \hat{P}_+ \hat{P}_-,
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_+ = \sum_{k &gt; 0} \hat{a}^\dagger_k \hat{a}^\dagger_{-{k}}.
\]</div>
<p>and <span class="math notranslate nohighlight">\(\hat{P}_- = ( \hat{P}_+)^\dagger\)</span>.</p>
<p>This problem can be solved using what is called the quasi-spin formalism to obtain the
exact results. Thereafter we will try again using the explicit Slater determinant formalism.</p>
</div>
<div class="section" id="id42">
<h2><span class="section-number">3.75. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h2>
<p>One can show (and this is part of the project) that</p>
<div class="math notranslate nohighlight">
\[
\left [ \hat{P}_+, \hat{P}_- \right ] = \sum_{k&gt; 0} \left( \hat{a}^\dagger_k \hat{a}_k 
+ \hat{a}^\dagger_{-{k}} \hat{a}_{-{k}} - 1 \right) = \hat{N} - \Omega.
\]</div>
<p>Now define</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_z = \frac{1}{2} ( \hat{N} -\Omega).
\]</div>
<p>Finally you can show</p>
<div class="math notranslate nohighlight">
\[
\left [ \hat{P}_z , \hat{P}_\pm \right ] = \pm \hat{P}_\pm.
\]</div>
<p>This means the operators <span class="math notranslate nohighlight">\(\hat{P}_\pm, \hat{P}_z\)</span> form a so-called  <span class="math notranslate nohighlight">\(SU(2)\)</span> algebra, and we can
use all our insights about angular momentum, even though there is no actual
angular momentum involved.</p>
<p>So we rewrite the Hamiltonian to make this explicit:</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = -G \hat{P}_+ \hat{P}_- 
= -G \left( \hat{P}^2 - \hat{P}_z^2 + \hat{P}_z\right)
\]</div>
</div>
<div class="section" id="id43">
<h2><span class="section-number">3.76. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h2>
<p>Because of the SU(2) algebra, we know that the eigenvalues of
<span class="math notranslate nohighlight">\(\hat{P}^2\)</span> must be of the form <span class="math notranslate nohighlight">\(p(p+1)\)</span>, with <span class="math notranslate nohighlight">\(p\)</span> either integer or half-integer, and the eigenvalues of <span class="math notranslate nohighlight">\(\hat{P}_z\)</span>
are <span class="math notranslate nohighlight">\(m_p\)</span> with <span class="math notranslate nohighlight">\(p \geq | m_p|\)</span>, with <span class="math notranslate nohighlight">\(m_p\)</span> also integer or half-integer.</p>
<p>But because <span class="math notranslate nohighlight">\(\hat{P}_z = (1/2)(\hat{N}-\Omega)\)</span>, we know that for <span class="math notranslate nohighlight">\(N\)</span> particles
the value <span class="math notranslate nohighlight">\(m_p = (N-\Omega)/2\)</span>. Furthermore, the values of <span class="math notranslate nohighlight">\(m_p\)</span> range from
<span class="math notranslate nohighlight">\(-\Omega/2\)</span> (for <span class="math notranslate nohighlight">\(N=0\)</span>) to <span class="math notranslate nohighlight">\(+\Omega/2\)</span> (for <span class="math notranslate nohighlight">\(N=2\Omega\)</span>, with all states filled).</p>
<p>We deduce the maximal <span class="math notranslate nohighlight">\(p = \Omega/2\)</span> and for a given <span class="math notranslate nohighlight">\(n\)</span> the
values range of <span class="math notranslate nohighlight">\(p\)</span> range from <span class="math notranslate nohighlight">\(|N-\Omega|/2\)</span> to <span class="math notranslate nohighlight">\(\Omega/2\)</span> in steps of 1
(for an even number of particles)</p>
<p>Following Racah we introduce the notation
<span class="math notranslate nohighlight">\(p = (\Omega - v)/2\)</span>
where <span class="math notranslate nohighlight">\(v = 0, 2, 4,..., \Omega - |N-\Omega|\)</span>
With this it is easy to deduce that the eigenvalues of the pairing Hamiltonian are</p>
<div class="math notranslate nohighlight">
\[
-G(N-v)(2\Omega +2-N-v)/4
\]</div>
<p>This also works for <span class="math notranslate nohighlight">\(N\)</span> odd, with <span class="math notranslate nohighlight">\(v= 1,3,5, \dots\)</span>.</p>
</div>
<div class="section" id="id44">
<h2><span class="section-number">3.77. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<p>Let’s take a specific example: <span class="math notranslate nohighlight">\(\Omega = 3\)</span> so there are 6 single-particle states,
and <span class="math notranslate nohighlight">\(N = 3\)</span>, with <span class="math notranslate nohighlight">\(v= 1,3\)</span>. Therefore there are two distinct eigenvalues,</p>
<div class="math notranslate nohighlight">
\[
E = -2G, 0
\]</div>
<p>Now let’s work this out explicitly. The single particle degrees of freedom are defined as</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$k$</th> <th align="center">$m$ </th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   1      </td> <td align="center">   -1/2    </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   -1     </td> <td align="center">   1/2     </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   2      </td> <td align="center">   -1/2    </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   -2     </td> <td align="center">   1/2     </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   3      </td> <td align="center">   -1/2    </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   -3     </td> <td align="center">   1/2     </td> </tr>
</tbody>
</table>
 There are  $\left( \begin{array}{c}6 \\ 3 \end{array} \right) = 20$ three-particle states, but there 
are 9 states with $M = +1/2$, namely
$| 1,2,3 \rangle, |1,2,5\rangle, | 1,4,6 \rangle, | 2,3,4 \rangle, |2,3,6 \rangle, | 2,4,5 \rangle, | 2, 5, 6 \rangle, |3,4,6 \rangle, | 4,5,6 \rangle$.
</div>
<div class="section" id="id45">
<h2><span class="section-number">3.78. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h2>
<p>In this basis, the operator</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_+
= \hat{a}^\dagger_1 \hat{a}^\dagger_2 + \hat{a}^\dagger_3 \hat{a}^\dagger_4 +
\hat{a}^\dagger_5 \hat{a}^\dagger_6
\]</div>
<p>From this we can determine that</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_- | 1, 4, 6 \rangle = \hat{P}_- | 2, 3, 6 \rangle
= \hat{P}_- | 2, 4, 5 \rangle = 0
\]</div>
<p>so those states all have eigenvalue 0.</p>
</div>
<div class="section" id="id46">
<h2><span class="section-number">3.79. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
<p>Now for further example,</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_- | 1,2,3 \rangle = | 3 \rangle
\]</div>
<p>so</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_+ \hat{P}_- | 1,2,3\rangle = | 1,2,3\rangle+ | 3,4,3\rangle + | 5,6,3\rangle
\]</div>
<p>The second term vanishes because state 3 is occupied twice, and reordering the last
term we
get</p>
<div class="math notranslate nohighlight">
\[
\hat{P}_+ \hat{P}_- | 1,2,3\rangle = | 1,2,3\rangle+ |3, 5,6\rangle
\]</div>
<p>without picking up a phase.</p>
</div>
<div class="section" id="id47">
<h2><span class="section-number">3.80. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h2>
<p>Continuing in this fashion, with the previous ordering of the many-body states
(  <span class="math notranslate nohighlight">\(| 1,2,3 \rangle, |1,2,5\rangle, | 1,4,6 \rangle, | 2,3,4 \rangle, |2,3,6 \rangle, | 2,4,5 \rangle, | 2, 5, 6 \rangle, |3,4,6 \rangle, | 4,5,6 \rangle\)</span>) the
Hamiltonian matrix of this system is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
H = -G\left( 
\begin{array}{ccccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  
\end{array} \right )
\end{split}\]</div>
<p>This is useful for our project.  One can by hand confirm
that there are 3 eigenvalues <span class="math notranslate nohighlight">\(-2G\)</span> and 6 with value zero.</p>
</div>
<div class="section" id="id48">
<h2><span class="section-number">3.81. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>Another example
Using the <span class="math notranslate nohighlight">\((1/2)^4\)</span> single-particle space, resulting in eight single-particle states</p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <th align="center">$n$</th> <th align="center">$l$</th> <th align="center">$s$</th> <th align="center">$m_s$</th> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   2      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   2      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   3      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   -1/2     </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   3      </td> <td align="center">   0      </td> <td align="center">   1/2    </td> <td align="center">   1/2      </td> </tr>
</tbody>
</table>
and then taking only 4-particle, $M=0$ states that have no `broken pairs', there are six basis Slater 
determinants:
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(|           1,           2 ,          3         ,       4  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            1      ,     2        ,        5         ,       6 \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            1         ,       2     ,           7         ,       8  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            3        ,        4      ,          5          ,      6  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            3        ,        4      ,          7         ,       8  \rangle , \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|            5        ,        6     ,           7     ,           8  \rangle \)</span></p></li>
</ul>
</div>
<div class="section" id="id49">
<h2><span class="section-number">3.82. </span>Example case: pairing Hamiltonian<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
<p>Now we take the following Hamiltonian</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = \sum_n n \delta \hat{N}_n  - G \hat{P}^\dagger \hat{P}
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\hat{N}_n = \hat{a}^\dagger_{n, m=+1/2} \hat{a}_{n, m=+1/2} +
\hat{a}^\dagger_{n, m=-1/2} \hat{a}_{n, m=-1/2}
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\hat{P}^\dagger = \sum_{n} \hat{a}^\dagger_{n, m=+1/2} \hat{a}^\dagger_{n, m=-1/2}
\]</div>
<p>We can write down the <span class="math notranslate nohighlight">\( 6 \times 6\)</span>  Hamiltonian in the basis from the prior slide:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
H = \left ( 
\begin{array}{cccccc}
2\delta -2G &amp; -G &amp; -G &amp; -G &amp; -G &amp; 0 \\
 -G &amp; 4\delta -2G &amp; -G &amp; -G &amp; -0 &amp; -G \\
-G &amp; -G &amp; 6\delta -2G &amp; 0 &amp; -G &amp; -G \\
 -G &amp; -G &amp; 0 &amp; 6\delta-2G &amp; -G &amp; -G \\
 -G &amp; 0 &amp; -G &amp; -G &amp; 8\delta-2G &amp; -G \\
0 &amp; -G &amp; -G &amp; -G &amp; -G &amp; 10\delta -2G 
\end{array} \right )
\end{split}\]</div>
<p>(You should check by hand that this is correct.)</p>
<p>For <span class="math notranslate nohighlight">\(\delta = 0\)</span> we have the closed form solution of  the g.s. energy given by <span class="math notranslate nohighlight">\(-6G\)</span>.</p>
</div>
<div class="section" id="building-a-hamiltonian-matrix">
<h2><span class="section-number">3.83. </span>Building a Hamiltonian matrix<a class="headerlink" href="#building-a-hamiltonian-matrix" title="Permalink to this headline">¶</a></h2>
<p>The goal is to compute the matrix elements of the Hamiltonian, specifically
matrix elements between many-body states (Slater determinants) of two-body
operators</p>
<div class="math notranslate nohighlight">
\[
\sum_{p &lt; q, r &lt; s}V_{pqr} \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r
\]</div>
<p>In particular we will need to compute</p>
<div class="math notranslate nohighlight">
\[
\langle \beta | \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha, \beta\)</span> are indices labeling Slater determinants and <span class="math notranslate nohighlight">\(p,q,r,s\)</span> label
single-particle states.</p>
</div>
<div class="section" id="id50">
<h2><span class="section-number">3.84. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
<p>Note: there are other, more efficient ways to do this than the method we describe,
but you will
be able to produce a working code quickly.</p>
<p>As we coded in the first step,
a Slater determinant <span class="math notranslate nohighlight">\(| \alpha \rangle\)</span> with index <span class="math notranslate nohighlight">\(\alpha\)</span> is a
list of <span class="math notranslate nohighlight">\(N\)</span> occupied single-particle states <span class="math notranslate nohighlight">\(i_1 &lt; i_2 &lt; i_3 \ldots i_N\)</span>.</p>
<p>Furthermore, for the two-body matrix elements <span class="math notranslate nohighlight">\(V_{pqrs}\)</span> we normally assume
<span class="math notranslate nohighlight">\(p &lt; q\)</span> and <span class="math notranslate nohighlight">\(r &lt; s\)</span>. For our specific project, the interaction is much simpler and you can use this to simplify considerably the setup of a shell-model code for project 2.</p>
<p>What follows here is a more general, but still brute force, approach.</p>
</div>
<div class="section" id="id51">
<h2><span class="section-number">3.85. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
<p>Write a function that:</p>
<ol class="simple">
<li><p>Has as input the single-particle indices <span class="math notranslate nohighlight">\(p,q,r,s\)</span> for the two-body operator and the index <span class="math notranslate nohighlight">\(\alpha\)</span> for the ket Slater determinant;</p></li>
<li><p>Returns the index <span class="math notranslate nohighlight">\(\beta\)</span> of the unique (if any) Slater determinant such that</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
| \beta \rangle = \pm \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
\]</div>
<p>as well as the phase</p>
<p>This is equivalent to computing</p>
<div class="math notranslate nohighlight">
\[
\langle \beta | \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
\]</div>
</div>
<div class="section" id="building-a-hamiltonian-matrix-first-step">
<h2><span class="section-number">3.86. </span>Building a Hamiltonian matrix, first step<a class="headerlink" href="#building-a-hamiltonian-matrix-first-step" title="Permalink to this headline">¶</a></h2>
<p>The first step can take as input an initial Slater determinant
(whose position in the list of basis Slater determinants is <span class="math notranslate nohighlight">\(\alpha\)</span>) written as an
ordered listed of occupied single-particle states, e.g. <span class="math notranslate nohighlight">\(1,2,5,8\)</span>, and the
indices <span class="math notranslate nohighlight">\(p,q,r,s\)</span> from the two-body operator.</p>
<p>It will return another final Slater determinant if the single-particle states <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are occupied, else it will return an
empty Slater determinant
(all zeroes).</p>
<p>If <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are in the list of occupied single particle states, then
replace the initial single-particle states <span class="math notranslate nohighlight">\(ij\)</span> as <span class="math notranslate nohighlight">\(i \rightarrow r\)</span> and <span class="math notranslate nohighlight">\(j \rightarrow r\)</span>.</p>
</div>
<div class="section" id="building-a-hamiltonian-matrix-second-step">
<h2><span class="section-number">3.87. </span>Building a Hamiltonian matrix, second step<a class="headerlink" href="#building-a-hamiltonian-matrix-second-step" title="Permalink to this headline">¶</a></h2>
<p>The second step will take the final Slater determinant
from the first step (if not empty),
and then order by pairwise permutations (i.e., if the Slater determinant is
<span class="math notranslate nohighlight">\(i_1, i_2, i_3, \ldots\)</span>, then if <span class="math notranslate nohighlight">\(i_n &gt; i_{n+1}\)</span>, interchange
<span class="math notranslate nohighlight">\(i_n \leftrightarrow i_{n+1}\)</span>.</p>
</div>
<div class="section" id="id52">
<h2><span class="section-number">3.88. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h2>
<p>It will also output a phase.  If any two single-particle occupancies are repeated,
the phase is
0.  Otherwise it is +1 for an even permutation and -1 for an odd permutation to
bring the final
Slater determinant into ascending order, <span class="math notranslate nohighlight">\(j_1 &lt; j_2 &lt; j_3 \ldots\)</span>.</p>
</div>
<div class="section" id="id53">
<h2><span class="section-number">3.89. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h2>
<p><strong>Example</strong>: Suppose in the <span class="math notranslate nohighlight">\(sd\)</span> single-particle space that the initial
Slater determinant
is <span class="math notranslate nohighlight">\(1,3,9,12\)</span>. If <span class="math notranslate nohighlight">\(p,q,r,s = 2,8,1,12\)</span>, then after the first step the final Slater determinant
is <span class="math notranslate nohighlight">\(2,3,9,8\)</span>.  The second step will return <span class="math notranslate nohighlight">\(2,3,8,9\)</span> and a phase of -1,
because an odd number  of interchanges is required.</p>
</div>
<div class="section" id="id54">
<h2><span class="section-number">3.90. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h2>
<p><strong>Example</strong>: Suppose in the <span class="math notranslate nohighlight">\(sd\)</span> single-particle space that the initial
Slater determinant
is <span class="math notranslate nohighlight">\(1,3,9,12\)</span>. If <span class="math notranslate nohighlight">\(p,q,r,s = 3,8,1,12\)</span>, then after the first step the
final  Slater determinant
is <span class="math notranslate nohighlight">\(3,3,9,8\)</span>, but after the second step the phase is 0
because the single-particle state 3 is
occupied twice.</p>
<p>Lastly, the final step  takes the ordered final Slater determinant and
we search through the basis list to
determine its index in the many-body basis, that is, <span class="math notranslate nohighlight">\(\beta\)</span>.</p>
</div>
<div class="section" id="id55">
<h2><span class="section-number">3.91. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h2>
<p>The Hamiltonian is then stored as an <span class="math notranslate nohighlight">\(N_{SD} \times N_{SD}\)</span> array of real numbers, which
can be allocated once you have created the many-body basis and know <span class="math notranslate nohighlight">\(N_{SD}\)</span>.</p>
</div>
<div class="section" id="id56">
<h2><span class="section-number">3.92. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(H(\alpha,\beta)=0.0\)</span></p></li>
<li><p>Set up an outer loop over <span class="math notranslate nohighlight">\(\beta\)</span></p></li>
<li><p>Loop over <span class="math notranslate nohighlight">\(\alpha = 1, NSD\)</span></p></li>
<li><p>For each <span class="math notranslate nohighlight">\(\alpha\)</span>, loop over <span class="math notranslate nohighlight">\(a=1,ntbme\)</span>  and fetch <span class="math notranslate nohighlight">\(V(a)\)</span> and the single-particle indices <span class="math notranslate nohighlight">\(p,q,r,s\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\(V(a) = 0\)</span> skip.  Otherwise, apply <span class="math notranslate nohighlight">\(\hat{a}^\dagger_p\hat{a}^\dagger_q \hat{a}_s \hat{a}_r\)</span> to the Slater determinant labeled by <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p>Find, if any, the label <span class="math notranslate nohighlight">\(\beta\)</span> of the resulting Slater determinant and the phase (which is 0, +1, -1).</p></li>
<li><p>If phase <span class="math notranslate nohighlight">\(\neq 0\)</span>, then update <span class="math notranslate nohighlight">\(H(\alpha,\beta)\)</span>  as <span class="math notranslate nohighlight">\(H(\alpha,\beta) + phase*V(a)\)</span>. The sum is important because multiple operators might contribute to the same matrix element.</p></li>
<li><p>Continue loop over <span class="math notranslate nohighlight">\(a\)</span></p></li>
<li><p>Continue loop over <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p>End the outer loop over <span class="math notranslate nohighlight">\(\beta\)</span>.</p></li>
</ol>
<p>You should force the resulting matrix <span class="math notranslate nohighlight">\(H\)</span> to be symmetric. To do this, when
updating <span class="math notranslate nohighlight">\(H(\alpha,\beta)\)</span>, if <span class="math notranslate nohighlight">\(\alpha \neq \beta\)</span>, also update <span class="math notranslate nohighlight">\(H(\beta,\alpha)\)</span>.</p>
</div>
<div class="section" id="id57">
<h2><span class="section-number">3.93. </span>Building a Hamiltonian matrix<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h2>
<p>You will also need to include the single-particle energies. This is easy: they only
contribute to diagonal matrix elements, that is, <span class="math notranslate nohighlight">\(H(\alpha,\alpha)\)</span>.<br />
Simply find the occupied single-particle states <span class="math notranslate nohighlight">\(i\)</span> and add the corresponding <span class="math notranslate nohighlight">\(\epsilon(i)\)</span>.</p>
</div>
<div class="section" id="hamiltonian-matrix-without-the-bit-representation">
<h2><span class="section-number">3.94. </span>Hamiltonian matrix without the bit representation<a class="headerlink" href="#hamiltonian-matrix-without-the-bit-representation" title="Permalink to this headline">¶</a></h2>
<p>Consider the many-body state <span class="math notranslate nohighlight">\(\Psi_{\lambda}\)</span> expressed as linear combinations of
Slater determinants (<span class="math notranslate nohighlight">\(SD\)</span>) of orthonormal single-particle states <span class="math notranslate nohighlight">\(\phi({\bf r})\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\Psi_{\lambda} = \sum_i C_{\lambda i} SD_i
\label{_auto1} \tag{2}
\end{equation}
\]</div>
<p>Using the Slater-Condon rules the matrix elements of any one-body
(<span class="math notranslate nohighlight">\(\cal{O}_1\)</span>) or two-body (<span class="math notranslate nohighlight">\(\cal{O}_2\)</span>) operator expressed in the
determinant space have simple expressions involving one- and two-fermion
integrals in our given single-particle basis.
The diagonal elements are given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
  \langle SD | \cal{O}_1 | SD \rangle &amp; = &amp; \sum_{i \in SD} \langle \phi_i | \cal{O}_1 | \phi_i \rangle \\
  \langle SD | \cal{O}_2 | SD \rangle &amp; = &amp; \frac{1}{2} \sum_{(i,j) \in SD}  
      \langle \phi_i \phi_j | \cal{O}_2 | \phi_i \phi_j \rangle - \nonumber \\
 &amp; &amp; 
      \langle \phi_i \phi_j | \cal{O}_2 | \phi_j \phi_i \rangle \nonumber 
\end{eqnarray}
\end{split}\]</div>
</div>
<div class="section" id="hamiltonian-matrix-without-the-bit-representation-one-and-two-body-operators">
<h2><span class="section-number">3.95. </span>Hamiltonian matrix without the bit representation, one and two-body operators<a class="headerlink" href="#hamiltonian-matrix-without-the-bit-representation-one-and-two-body-operators" title="Permalink to this headline">¶</a></h2>
<p>For two determinants which differ only by the substitution of single-particle states <span class="math notranslate nohighlight">\(i\)</span> with
a single-particle state <span class="math notranslate nohighlight">\(j\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
  \langle SD | \cal{O}_1 | SD_i^j \rangle &amp; = &amp; \langle \phi_i | \cal{O}_1 | \phi_j \rangle \\
  \langle SD | \cal{O}_2 | SD_i^j \rangle &amp; = &amp; \sum_{k \in SD} 
      \langle \phi_i \phi_k | \cal{O}_2 | \phi_j \phi_k \rangle - 
      \langle \phi_i \phi_k | \cal{O}_2 | \phi_k \phi_j \rangle \nonumber
\end{eqnarray}
\end{split}\]</div>
<p>For two determinants which differ by two single-particle states</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
  \langle SD | \cal{O}_1 | SD_{ik}^{jl} \rangle &amp; = &amp; 0 \\
  \langle SD | \cal{O}_2 | SD_{ik}^{jl} \rangle &amp; = &amp; 
      \langle \phi_i \phi_k | \cal{O}_2 | \phi_j \phi_l \rangle -
      \langle \phi_i \phi_k | \cal{O}_2 | \phi_l \phi_j \rangle \nonumber 
\end{eqnarray}
\end{split}\]</div>
<p>All other matrix elements involving determinants with more than two
substitutions are zero.</p>
</div>
<div class="section" id="strategies-for-setting-up-an-algorithm">
<h2><span class="section-number">3.96. </span>Strategies for setting up an algorithm<a class="headerlink" href="#strategies-for-setting-up-an-algorithm" title="Permalink to this headline">¶</a></h2>
<p>An efficient implementation of these rules requires</p>
<ul class="simple">
<li><p>to find the number of single-particle state substitutions between two determinants</p></li>
<li><p>to find which single-particle states are involved in the substitution</p></li>
<li><p>to compute the phase factor if a reordering of the single-particle states has occured</p></li>
</ul>
<p>We can solve this problem using our odometric approach or alternatively using a bit representation as discussed below and in more detail in</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/scemama/slater_condon">Scemama and Gimer’s article (Fortran codes)</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/0810.2644">Simen Kvaal’s article on how to build an FCI code (C++ code)</a></p></li>
</ul>
<p>We recommend in particular the article by Simen Kvaal. It contains nice general classes for creation and annihilation operators as well as the calculation of the phase (see below).</p>
</div>
<div class="section" id="computing-expectation-values-and-transitions-in-the-shell-model">
<h2><span class="section-number">3.97. </span>Computing expectation values and transitions in the shell-model<a class="headerlink" href="#computing-expectation-values-and-transitions-in-the-shell-model" title="Permalink to this headline">¶</a></h2>
<p>When we diagonalize the Hamiltonian matrix, the eigenvectors are the coefficients <span class="math notranslate nohighlight">\(C_{\lambda i}\)</span> used
to express the many-body state <span class="math notranslate nohighlight">\(\Psi_{\lambda}\)</span> in terms of  a linear combinations of
Slater determinants (<span class="math notranslate nohighlight">\(SD\)</span>) of orthonormal single-particle states <span class="math notranslate nohighlight">\(\phi({\bf r})\)</span>.</p>
<p>With these eigenvectors we can compute say the transition likelyhood of a one-body operator as</p>
<div class="math notranslate nohighlight">
\[
\langle \Psi_{\lambda} \vert \cal{O}_1 \vert \Psi_{\sigma} \rangle  = 
\sum_{ij}C_{\lambda i}^*C_{\sigma j}  \langle SD_i | \cal{O}_1 | SD_j \rangle .
\]</div>
<p>Writing the one-body operator in second quantization as</p>
<div class="math notranslate nohighlight">
\[
\cal{O}_1  = \sum_{pq} \langle p \vert \cal{o}_1 \vert q\rangle a_p^{\dagger} a_q,
\]</div>
<p>we have</p>
<div class="math notranslate nohighlight">
\[
\langle \Psi_{\lambda} \vert \cal{O}_1 \vert \Psi_{\sigma} \rangle  = 
\sum_{pq}\langle p \vert \cal{o}_1 \vert q\rangle \sum_{ij}C_{\lambda i}^*C_{\sigma j}  \langle SD_i |a_p^{\dagger} a_q | SD_j \rangle .
\]</div>
</div>
<div class="section" id="computing-expectation-values-and-transitions-in-the-shell-model-and-spectroscopic-factors">
<h2><span class="section-number">3.98. </span>Computing expectation values and transitions in the shell-model and spectroscopic factors<a class="headerlink" href="#computing-expectation-values-and-transitions-in-the-shell-model-and-spectroscopic-factors" title="Permalink to this headline">¶</a></h2>
<p>The terms we need to evalute then are just the elements</p>
<div class="math notranslate nohighlight">
\[
\langle SD_i |a_p^{\dagger} a_q | SD_j \rangle,
\]</div>
<p>which can be rewritten in terms of spectroscopic factors by inserting a complete set of Slater determinats as</p>
<div class="math notranslate nohighlight">
\[
\langle SD_i |a_p^{\dagger} a_q | SD_j \rangle = \sum_{l}\langle SD_i \vert a_p^{\dagger}\vert SD_l\rangle \langle SD_l \vert  a_q \vert SD_j \rangle,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\langle SD_l\vert a_q(a_p^{\dagger})\vert SD_j\rangle\)</span> are the spectroscopic factors. These can be easily evaluated in <span class="math notranslate nohighlight">\(m\)</span>-scheme. Using the Wigner-Eckart theorem we can transform these to a <span class="math notranslate nohighlight">\(J\)</span>-coupled scheme through so-called reduced matrix elements.</p>
</div>
<div class="section" id="operators-in-second-quantization">
<h2><span class="section-number">3.99. </span>Operators in second quantization<a class="headerlink" href="#operators-in-second-quantization" title="Permalink to this headline">¶</a></h2>
<p>In the build-up of a shell-model or FCI code that is meant to tackle large dimensionalities
we need to deal with the action of the Hamiltonian <span class="math notranslate nohighlight">\(\hat{H}\)</span> on a
Slater determinant represented in second quantization as</p>
<div class="math notranslate nohighlight">
\[
|\alpha_1\dots \alpha_n\rangle = a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \dots a_{\alpha_n}^{\dagger} |0\rangle.
\]</div>
<p>The time consuming part stems from the action of the Hamiltonian
on the above determinant,</p>
<div class="math notranslate nohighlight">
\[
\left(\sum_{\alpha\beta} \langle \alpha|t+u|\beta\rangle a_\alpha^{\dagger} a_\beta + \frac{1}{4} \sum_{\alpha\beta\gamma\delta}
                \langle \alpha \beta|\hat{v}|\gamma \delta\rangle a_\alpha^{\dagger} a_\beta^{\dagger} a_\delta a_\gamma\right)a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \dots a_{\alpha_n}^{\dagger} |0\rangle.
\]</div>
<p>A practically useful way to implement this action is to encode a Slater determinant as a bit pattern.</p>
</div>
<div class="section" id="id58">
<h2><span class="section-number">3.100. </span>Operators in second quantization<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h2>
<p>Assume that we have at our disposal <span class="math notranslate nohighlight">\(n\)</span> different single-particle states
<span class="math notranslate nohighlight">\(\alpha_0,\alpha_2,\dots,\alpha_{n-1}\)</span> and that we can distribute  among these states <span class="math notranslate nohighlight">\(N\le n\)</span> particles.</p>
<p>A Slater  determinant can then be coded as an integer of <span class="math notranslate nohighlight">\(n\)</span> bits. As an example, if we have <span class="math notranslate nohighlight">\(n=16\)</span> single-particle states
<span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,\dots,\alpha_{15}\)</span> and <span class="math notranslate nohighlight">\(N=4\)</span> fermions occupying the states <span class="math notranslate nohighlight">\(\alpha_3\)</span>, <span class="math notranslate nohighlight">\(\alpha_6\)</span>, <span class="math notranslate nohighlight">\(\alpha_{10}\)</span> and <span class="math notranslate nohighlight">\(\alpha_{13}\)</span>
we could write this Slater determinant as</p>
<div class="math notranslate nohighlight">
\[
\Phi_{\Lambda} = a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle.
\]</div>
<p>The unoccupied single-particle states have bit value <span class="math notranslate nohighlight">\(0\)</span> while the occupied ones are represented by bit state <span class="math notranslate nohighlight">\(1\)</span>.
In the binary notation we would write this   16 bits long integer as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{cccccccccccccccc}
{\alpha_0}&amp;{\alpha_1}&amp;{\alpha_2}&amp;{\alpha_3}&amp;{\alpha_4}&amp;{\alpha_5}&amp;{\alpha_6}&amp;{\alpha_7} &amp; {\alpha_8} &amp;{\alpha_9} &amp; {\alpha_{10}} &amp;{\alpha_{11}} &amp;{\alpha_{12}} &amp;{\alpha_{13}} &amp;{\alpha_{14}} &amp; {\alpha_{15}} \\
{0} &amp; {0} &amp;{0} &amp;{1} &amp;{0} &amp;{0} &amp;{1} &amp;{0} &amp;{0} &amp;{0} &amp;{1} &amp;{0} &amp;{0} &amp;{1} &amp;{0} &amp; {0} \\
\end{array}
\end{split}\]</div>
<p>which translates into the decimal number</p>
<div class="math notranslate nohighlight">
\[
2^3+2^6+2^{10}+2^{13}=9288.
\]</div>
<p>We can thus encode a Slater determinant as a bit pattern.</p>
</div>
<div class="section" id="id59">
<h2><span class="section-number">3.101. </span>Operators in second quantization<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h2>
<p>With <span class="math notranslate nohighlight">\(N\)</span> particles that can be distributed over <span class="math notranslate nohighlight">\(n\)</span> single-particle states, the total number of Slater determinats (and defining thereby the dimensionality of the system) is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathrm{dim}(\mathcal{H}) = \left(\begin{array}{c} n \\N\end{array}\right).
\end{split}\]</div>
<p>The total number of bit patterns is <span class="math notranslate nohighlight">\(2^n\)</span>.</p>
</div>
<div class="section" id="id60">
<h2><span class="section-number">3.102. </span>Operators in second quantization<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h2>
<p>We assume again that we have at our disposal <span class="math notranslate nohighlight">\(n\)</span> different single-particle orbits
<span class="math notranslate nohighlight">\(\alpha_0,\alpha_2,\dots,\alpha_{n-1}\)</span> and that we can distribute  among these orbits <span class="math notranslate nohighlight">\(N\le n\)</span> particles.
The ordering among these states is important as it defines the order of the creation operators.
We will write the determinant</p>
<div class="math notranslate nohighlight">
\[
\Phi_{\Lambda} = a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
\]</div>
<p>in a more compact way as</p>
<div class="math notranslate nohighlight">
\[
\Phi_{3,6,10,13} = |0001001000100100\rangle.
\]</div>
<p>The action of a creation operator is thus</p>
<div class="math notranslate nohighlight">
\[
a^{\dagger}_{\alpha_4}\Phi_{3,6,10,13} = a^{\dagger}_{\alpha_4}|0001001000100100\rangle=a^{\dagger}_{\alpha_4}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
\]</div>
<p>which becomes</p>
<div class="math notranslate nohighlight">
\[
-a_{\alpha_3}^{\dagger} a^{\dagger}_{\alpha_4} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=-|0001101000100100\rangle.
\]</div>
</div>
<div class="section" id="id61">
<h2><span class="section-number">3.103. </span>Operators in second quantization<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h2>
<p>Similarly</p>
<div class="math notranslate nohighlight">
\[
a^{\dagger}_{\alpha_6}\Phi_{3,6,10,13} = a^{\dagger}_{\alpha_6}|0001001000100100\rangle=a^{\dagger}_{\alpha_6}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
\]</div>
<p>which becomes</p>
<div class="math notranslate nohighlight">
\[
-a^{\dagger}_{\alpha_4} (a_{\alpha_6}^{\dagger})^ 2 a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=0!
\]</div>
<p>This gives a simple recipe:</p>
<ul class="simple">
<li><p>If one of the bits <span class="math notranslate nohighlight">\(b_j\)</span> is <span class="math notranslate nohighlight">\(1\)</span> and we act with a creation operator on this bit, we return a null vector</p></li>
<li><p>If <span class="math notranslate nohighlight">\(b_j=0\)</span>, we set it to <span class="math notranslate nohighlight">\(1\)</span> and return a sign factor <span class="math notranslate nohighlight">\((-1)^l\)</span>, where <span class="math notranslate nohighlight">\(l\)</span> is the number of bits set before bit <span class="math notranslate nohighlight">\(j\)</span>.</p></li>
</ul>
</div>
<div class="section" id="id62">
<h2><span class="section-number">3.104. </span>Operators in second quantization<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h2>
<p>Consider the action of <span class="math notranslate nohighlight">\(a^{\dagger}_{\alpha_2}\)</span> on various slater determinants:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{ccc}
a^{\dagger}_{\alpha_2}\Phi_{00111}&amp; = a^{\dagger}_{\alpha_2}|00111\rangle&amp;=0\times |00111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01011}&amp; = a^{\dagger}_{\alpha_2}|01011\rangle&amp;=(-1)\times |01111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01101}&amp; = a^{\dagger}_{\alpha_2}|01101\rangle&amp;=0\times |01101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01110}&amp; = a^{\dagger}_{\alpha_2}|01110\rangle&amp;=0\times |01110\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10011}&amp; = a^{\dagger}_{\alpha_2}|10011\rangle&amp;=(-1)\times |10111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10101}&amp; = a^{\dagger}_{\alpha_2}|10101\rangle&amp;=0\times |10101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10110}&amp; = a^{\dagger}_{\alpha_2}|10110\rangle&amp;=0\times |10110\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{11001}&amp; = a^{\dagger}_{\alpha_2}|11001\rangle&amp;=(+1)\times |11101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{11010}&amp; = a^{\dagger}_{\alpha_2}|11010\rangle&amp;=(+1)\times |11110\rangle\\
\end{array}
\end{split}\]</div>
<p>What is the simplest way to obtain the phase when we act with one annihilation(creation) operator
on the given Slater determinant representation?</p>
</div>
<div class="section" id="id63">
<h2><span class="section-number">3.105. </span>Operators in second quantization<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h2>
<p>We have an SD representation</p>
<div class="math notranslate nohighlight">
\[
\Phi_{\Lambda} = a_{\alpha_0}^{\dagger} a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
\]</div>
<p>in a more compact way as</p>
<div class="math notranslate nohighlight">
\[
\Phi_{0,3,6,10,13} = |1001001000100100\rangle.
\]</div>
<p>The action of</p>
<div class="math notranslate nohighlight">
\[
a^{\dagger}_{\alpha_4}a_{\alpha_0}\Phi_{0,3,6,10,13} = a^{\dagger}_{\alpha_4}|0001001000100100\rangle=a^{\dagger}_{\alpha_4}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
\]</div>
<p>which becomes</p>
<div class="math notranslate nohighlight">
\[
-a_{\alpha_3}^{\dagger} a^{\dagger}_{\alpha_4} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=-|0001101000100100\rangle.
\]</div>
</div>
<div class="section" id="id64">
<h2><span class="section-number">3.106. </span>Operators in second quantization<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h2>
<p>The action</p>
<div class="math notranslate nohighlight">
\[
a_{\alpha_0}\Phi_{0,3,6,10,13} = |0001001000100100\rangle,
\]</div>
<p>can be obtained by subtracting the logical sum (AND operation) of <span class="math notranslate nohighlight">\(\Phi_{0,3,6,10,13}\)</span> and
a word which represents only <span class="math notranslate nohighlight">\(\alpha_0\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
|1000000000000000\rangle,
\]</div>
<p>from <span class="math notranslate nohighlight">\(\Phi_{0,3,6,10,13}= |1001001000100100\rangle\)</span>.</p>
<p>This operation gives <span class="math notranslate nohighlight">\(|0001001000100100\rangle\)</span>.</p>
<p>Similarly, we can form <span class="math notranslate nohighlight">\(a^{\dagger}_{\alpha_4}a_{\alpha_0}\Phi_{0,3,6,10,13}\)</span>, say, by adding
<span class="math notranslate nohighlight">\(|0000100000000000\rangle\)</span> to <span class="math notranslate nohighlight">\(a_{\alpha_0}\Phi_{0,3,6,10,13}\)</span>, first checking that their logical sum
is zero in order to make sure that the state <span class="math notranslate nohighlight">\(\alpha_4\)</span> is not already occupied.</p>
</div>
<div class="section" id="id65">
<h2><span class="section-number">3.107. </span>Operators in second quantization<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h2>
<p>It is trickier however to get the phase <span class="math notranslate nohighlight">\((-1)^l\)</span>.
One possibility is as follows</p>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(S_1\)</span> be a word that represents the 1-bit to be removed and all others set to zero.</p></li>
</ul>
<p>In the previous example <span class="math notranslate nohighlight">\(S_1=|1000000000000000\rangle\)</span></p>
<ul class="simple">
<li><p>Define <span class="math notranslate nohighlight">\(S_2\)</span> as the similar word that represents the bit to be added, that is in our case</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(S_2=|0000100000000000\rangle\)</span>.</p>
<ul class="simple">
<li><p>Compute then <span class="math notranslate nohighlight">\(S=S_1-S_2\)</span>, which here becomes</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
S=|0111000000000000\rangle
\]</div>
<ul class="simple">
<li><p>Perform then the logical AND operation of <span class="math notranslate nohighlight">\(S\)</span> with the word containing</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\Phi_{0,3,6,10,13} = |1001001000100100\rangle,
\]</div>
<p>which results in <span class="math notranslate nohighlight">\(|0001000000000000\rangle\)</span>. Counting the number of 1-bits gives the phase.  Here you need however an algorithm for bitcounting.</p>
</div>
<div class="section" id="bit-counting">
<h2><span class="section-number">3.108. </span>Bit counting<a class="headerlink" href="#bit-counting" title="Permalink to this headline">¶</a></h2>
<p>We include here a python program which may aid in this direction. It uses bit manipulation functions from <a class="reference external" href="http://wiki.python.org/moin/BitManipulation">http://wiki.python.org/moin/BitManipulation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A simple Python class for Slater determinant manipulation</span>
<span class="sd">Bit-manipulation stolen from:</span>

<span class="sd">http://wiki.python.org/moin/BitManipulation</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># bitCount() counts the number of bits set (not an optimal function)</span>

<span class="k">def</span> <span class="nf">bitCount</span><span class="p">(</span><span class="n">int_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Count bits set in integer &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="n">int_type</span><span class="p">):</span>
        <span class="n">int_type</span> <span class="o">&amp;=</span> <span class="n">int_type</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>


<span class="c1"># testBit() returns a nonzero result, 2**offset, if the bit at &#39;offset&#39; is one.</span>

<span class="k">def</span> <span class="nf">testBit</span><span class="p">(</span><span class="n">int_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span>
    <span class="k">return</span><span class="p">(</span><span class="n">int_type</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">offset</span>

<span class="c1"># setBit() returns an integer with the bit at &#39;offset&#39; set to 1.</span>

<span class="k">def</span> <span class="nf">setBit</span><span class="p">(</span><span class="n">int_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span>
    <span class="k">return</span><span class="p">(</span><span class="n">int_type</span> <span class="o">|</span> <span class="n">mask</span><span class="p">)</span>

<span class="c1"># clearBit() returns an integer with the bit at &#39;offset&#39; cleared.</span>

<span class="k">def</span> <span class="nf">clearBit</span><span class="p">(</span><span class="n">int_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">int_type</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>

<span class="c1"># toggleBit() returns an integer with the bit at &#39;offset&#39; inverted, 0 -&gt; 1 and 1 -&gt; 0.</span>

<span class="k">def</span> <span class="nf">toggleBit</span><span class="p">(</span><span class="n">int_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span>
    <span class="k">return</span><span class="p">(</span><span class="n">int_type</span> <span class="o">^</span> <span class="n">mask</span><span class="p">)</span>

<span class="c1"># binary string made from number</span>

<span class="k">def</span> <span class="nf">bin0</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">&lt;=</span><span class="mi">1</span> <span class="k">else</span> <span class="n">bin0</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">bin0</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span> <span class="o">+</span> <span class="n">ss</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ss</span>
    
    

<span class="k">class</span> <span class="nc">Slater</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for Slater determinants &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;c^+_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; |&quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;  = &quot;</span><span class="p">,</span>
        <span class="c1"># Assume bit j is set, then we return zero.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Check if bit j is set.</span>
        <span class="n">isset</span> <span class="o">=</span> <span class="n">testBit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="n">bitCount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">setBit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="nb">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; x |&quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">s</span>
        
    <span class="k">def</span> <span class="nf">annihilate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;c_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; |&quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;  = &quot;</span><span class="p">,</span>
        <span class="c1"># Assume bit j is not set, then we return zero.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Check if bit j is set.</span>
        <span class="n">isset</span> <span class="o">=</span> <span class="n">testBit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isset</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="n">bitCount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">clearBit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="nb">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; x |&quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">s</span>



<span class="c1"># Do some testing:</span>

<span class="n">phi</span> <span class="o">=</span> <span class="n">Slater</span><span class="p">()</span>
<span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span>


<span class="n">s</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">annihilate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">annihilate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-1-8c9947e6a3ed&gt;&quot;</span><span class="gt">, line </span><span class="mi">65</span>
    <span class="nb">print</span> <span class="s2">&quot;c^+_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; |&quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;  = &quot;</span><span class="p">,</span>
          <span class="o">^</span>
<span class="ne">SyntaxError</span>: invalid syntax
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="eigenvalue-problems-basic-definitions">
<h2><span class="section-number">3.109. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#eigenvalue-problems-basic-definitions" title="Permalink to this headline">¶</a></h2>
<p>Let us consider the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> of dimension <span class="math notranslate nohighlight">\(n\)</span>. The eigenvalues of
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> are defined through the matrix equation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{A}\mathbf{x}^{(\nu)} = \lambda^{(\nu)}\mathbf{x}^{(\nu)},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda^{(\nu)}\)</span> are the eigenvalues and <span class="math notranslate nohighlight">\(\mathbf{x}^{(\nu)}\)</span> the
corresponding eigenvectors.
Unless otherwise stated, when we use the wording eigenvector we mean the
right eigenvector. The left eigenvalue problem is defined as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}^{(\nu)}_L\mathbf{A} = \lambda^{(\nu)}\mathbf{x}^{(\nu)}_L
\]</div>
<p>The above right eigenvector problem is equivalent to a set of <span class="math notranslate nohighlight">\(n\)</span> equations with <span class="math notranslate nohighlight">\(n\)</span> unknowns
<span class="math notranslate nohighlight">\(x_i\)</span>.</p>
</div>
<div class="section" id="id66">
<h2><span class="section-number">3.110. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h2>
<p>The eigenvalue problem can be rewritten as</p>
<div class="math notranslate nohighlight">
\[
\left( \mathbf{A}-\lambda^{(\nu)} \mathbf{I} \right) \mathbf{x}^{(\nu)} = 0,
\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{I}\)</span> being the unity matrix. This equation provides
a solution to the problem if and only if the determinant
is zero, namely</p>
<div class="math notranslate nohighlight">
\[
\left| \mathbf{A}-\lambda^{(\nu)}\mathbf{I}\right| = 0,
\]</div>
<p>which in turn means that the determinant is a polynomial
of degree <span class="math notranslate nohighlight">\(n\)</span> in <span class="math notranslate nohighlight">\(\lambda\)</span> and in general we will have
<span class="math notranslate nohighlight">\(n\)</span> distinct zeros.</p>
</div>
<div class="section" id="id67">
<h2><span class="section-number">3.111. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id67" title="Permalink to this headline">¶</a></h2>
<p>The eigenvalues of a matrix
<span class="math notranslate nohighlight">\(\mathbf{A}\in {\mathbb{C}}^{n\times n}\)</span>
are thus the <span class="math notranslate nohighlight">\(n\)</span> roots of its characteristic polynomial</p>
<div class="math notranslate nohighlight">
\[
P(\lambda) = det(\lambda\mathbf{I}-\mathbf{A}),
\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[
P(\lambda)= \prod_{i=1}^{n}\left(\lambda_i-\lambda\right).
\]</div>
<p>The set of these roots is called the spectrum and is denoted as
<span class="math notranslate nohighlight">\(\lambda(\mathbf{A})\)</span>.
If <span class="math notranslate nohighlight">\(\lambda(\mathbf{A})=\left\{\lambda_1,\lambda_2,\dots ,\lambda_n\right\}\)</span> then we have</p>
<div class="math notranslate nohighlight">
\[
det(\mathbf{A})= \lambda_1\lambda_2\dots\lambda_n,
\]</div>
<p>and if we define the trace of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> as</p>
<div class="math notranslate nohighlight">
\[
Tr(\mathbf{A})=\sum_{i=1}^n a_{ii}
\]</div>
<p>then</p>
<div class="math notranslate nohighlight">
\[
Tr(\mathbf{A})=\lambda_1+\lambda_2+\dots+\lambda_n.
\]</div>
</div>
<div class="section" id="abel-ruffini-impossibility-theorem">
<h2><span class="section-number">3.112. </span>Abel-Ruffini Impossibility Theorem<a class="headerlink" href="#abel-ruffini-impossibility-theorem" title="Permalink to this headline">¶</a></h2>
<p>The <em>Abel-Ruffini</em> theorem (also known as Abel’s impossibility theorem)
states that there is no general solution in radicals to polynomial equations of degree five or higher.</p>
<p>The content of this theorem is frequently misunderstood. It does not assert that higher-degree polynomial equations are unsolvable.
In fact, if the polynomial has real or complex coefficients, and we allow complex solutions, then every polynomial equation has solutions; this is the fundamental theorem of algebra. Although these solutions cannot always be computed exactly with radicals, they can be computed to any desired degree of accuracy using numerical methods such as the Newton-Raphson method or Laguerre method, and in this way they are no different from solutions to polynomial equations of the second, third, or fourth degrees.</p>
<p>The theorem only concerns the form that such a solution must take. The content of the theorem is
that the solution of a higher-degree equation cannot in all cases be expressed in terms of the polynomial coefficients with a finite number of operations of addition, subtraction, multiplication, division and root extraction. Some polynomials of arbitrary degree, of which the simplest nontrivial example is the monomial equation <span class="math notranslate nohighlight">\(ax^n = b\)</span>, are always solvable with a radical.</p>
</div>
<div class="section" id="id68">
<h2><span class="section-number">3.113. </span>Abel-Ruffini Impossibility Theorem<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h2>
<p>The <em>Abel-Ruffini</em> theorem says that there are some fifth-degree equations whose solution cannot be so expressed.
The equation <span class="math notranslate nohighlight">\(x^5 - x + 1 = 0\)</span> is an example. Some other fifth degree equations can be solved by radicals,
for example <span class="math notranslate nohighlight">\(x^5 - x^4 - x + 1 = 0\)</span>. The precise criterion that distinguishes between those equations that can be solved
by radicals and those that cannot was given by Galois and is now part of Galois theory:
a polynomial equation can be solved by radicals if and only if its Galois group is a solvable group.</p>
<p>Today, in the modern algebraic context, we say that second, third and fourth degree polynomial
equations can always be solved by radicals because the symmetric groups <span class="math notranslate nohighlight">\(S_2, S_3\)</span> and <span class="math notranslate nohighlight">\(S_4\)</span> are solvable groups,
whereas <span class="math notranslate nohighlight">\(S_n\)</span> is not solvable for <span class="math notranslate nohighlight">\(n \ge 5\)</span>.</p>
</div>
<div class="section" id="id69">
<h2><span class="section-number">3.114. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h2>
<p>In the present discussion we assume that our matrix is real and symmetric, that is
<span class="math notranslate nohighlight">\(\mathbf{A}\in {\mathbb{R}}^{n\times n}\)</span>.
The matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> has <span class="math notranslate nohighlight">\(n\)</span> eigenvalues
<span class="math notranslate nohighlight">\(\lambda_1\dots \lambda_n\)</span> (distinct or not). Let <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> be the
diagonal matrix with the eigenvalues on the diagonal</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{D}=    \left( \begin{array}{ccccccc} \lambda_1 &amp; 0 &amp; 0   &amp; 0    &amp; \dots  &amp;0     &amp; 0 \\
                                0 &amp; \lambda_2 &amp; 0 &amp; 0    &amp; \dots  &amp;0     &amp;0 \\
                                0   &amp; 0 &amp; \lambda_3 &amp; 0  &amp;0       &amp;\dots &amp; 0\\
                                \dots  &amp; \dots &amp; \dots &amp; \dots  &amp;\dots      &amp;\dots &amp; \dots\\
                                0   &amp; \dots &amp; \dots &amp; \dots  &amp;\dots       &amp;\lambda_{n-1} &amp; \\
                                0   &amp; \dots &amp; \dots &amp; \dots  &amp;\dots       &amp;0 &amp; \lambda_n
             \end{array} \right).
\end{split}\]</div>
<p>If <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is real and symmetric then there exists a real orthogonal matrix <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\mathbf{S}^T \mathbf{A}\mathbf{S}= \mathrm{diag}(\lambda_1,\lambda_2,\dots ,\lambda_n),
\]</div>
<p>and for <span class="math notranslate nohighlight">\(j=1:n\)</span> we have <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{S}(:,j) = \lambda_j \mathbf{S}(:,j)\)</span>.</p>
</div>
<div class="section" id="id70">
<h2><span class="section-number">3.115. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h2>
<p>To obtain the eigenvalues of <span class="math notranslate nohighlight">\(\mathbf{A}\in {\mathbb{R}}^{n\times n}\)</span>,
the strategy is to
perform a series of similarity transformations on the original
matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, in order to reduce it either into a  diagonal form as above
or into a  tridiagonal form.</p>
<p>We say that a matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is a similarity
transform  of  <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> if</p>
<div class="math notranslate nohighlight">
\[
\mathbf{B}= \mathbf{S}^T \mathbf{A}\mathbf{S}, \hspace{1cm} \mathrm{where} \hspace{1cm}  \mathbf{S}^T\mathbf{S}=\mathbf{S}^{-1}\mathbf{S} =\mathbf{I}.
\]</div>
<p>The importance of a similarity transformation lies in the fact that
the resulting matrix has the same
eigenvalues, but the eigenvectors are in general different.</p>
</div>
<div class="section" id="id71">
<h2><span class="section-number">3.116. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h2>
<p>To prove this we
start with  the eigenvalue problem and a similarity transformed matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\mathbf{A}\mathbf{x}=\lambda\mathbf{x} \hspace{1cm} \mathrm{and}\hspace{1cm} 
    \mathbf{B}= \mathbf{S}^T \mathbf{A}\mathbf{S}.
\]</div>
<p>We multiply the first equation on the left by <span class="math notranslate nohighlight">\(\mathbf{S}^T\)</span> and insert
<span class="math notranslate nohighlight">\(\mathbf{S}^{T}\mathbf{S} = \mathbf{I}\)</span> between <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. Then we get</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
   (\mathbf{S}^T\mathbf{A}\mathbf{S})(\mathbf{S}^T\mathbf{x})=\lambda\mathbf{S}^T\mathbf{x} ,
\label{_auto2} \tag{3}
\end{equation}
\]</div>
<p>which is the same as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{B} \left ( \mathbf{S}^T\mathbf{x} \right ) = \lambda \left (\mathbf{S}^T\mathbf{x}\right ).
\]</div>
<p>The variable  <span class="math notranslate nohighlight">\(\lambda\)</span> is an eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> as well, but with
eigenvector <span class="math notranslate nohighlight">\(\mathbf{S}^T\mathbf{x}\)</span>.</p>
</div>
<div class="section" id="id72">
<h2><span class="section-number">3.117. </span>Eigenvalue problems, basic definitions<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h2>
<p>The basic philosophy is to</p>
<ul class="simple">
<li><p>Either apply subsequent similarity transformations (direct method) so that</p></li>
</ul>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
   \mathbf{S}_N^T\dots \mathbf{S}_1^T\mathbf{A}\mathbf{S}_1\dots \mathbf{S}_N=\mathbf{D} ,
\label{_auto3} \tag{4}
\end{equation}
\]</div>
<ul class="simple">
<li><p>Or apply subsequent similarity transformations so that <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> becomes tridiagonal (Householder) or upper/lower triangular (the <em>QR</em> method to be discussed later).</p></li>
<li><p>Thereafter, techniques for obtaining eigenvalues from tridiagonal matrices can be used.</p></li>
<li><p>Or use so-called power methods</p></li>
<li><p>Or use iterative methods (Krylov, Lanczos, Arnoldi). These methods are popular for huge matrix problems.</p></li>
</ul>
</div>
<div class="section" id="discussion-of-methods-for-eigenvalues">
<h2><span class="section-number">3.118. </span>Discussion of  methods for eigenvalues<a class="headerlink" href="#discussion-of-methods-for-eigenvalues" title="Permalink to this headline">¶</a></h2>
<p><strong>The general overview.</strong></p>
<p>One speaks normally of two main approaches to solving the eigenvalue problem.</p>
<ul class="simple">
<li><p>The first is the formal method, involving determinants and the  characteristic polynomial. This proves how many eigenvalues  there are, and is the way most of you learned about how to solve the eigenvalue problem, but for matrices of dimensions greater than 2 or 3, it is rather impractical.</p></li>
<li><p>The other general approach is to use similarity or unitary tranformations  to reduce a matrix to diagonal form. This is normally done in two steps: first reduce to for example a <em>tridiagonal</em> form, and then to diagonal form. The main algorithms we will discuss in detail, Jacobi’s and  Householder’s  (so-called direct method) and Lanczos algorithms (an iterative method), follow this methodology.</p></li>
</ul>
</div>
<div class="section" id="eigenvalues-methods">
<h2><span class="section-number">3.119. </span>Eigenvalues methods<a class="headerlink" href="#eigenvalues-methods" title="Permalink to this headline">¶</a></h2>
<p>Direct or non-iterative methods  require for matrices of dimensionality <span class="math notranslate nohighlight">\(n\times n\)</span> typically <span class="math notranslate nohighlight">\(O(n^3)\)</span> operations. These methods are normally called standard methods and are used for dimensionalities
<span class="math notranslate nohighlight">\(n \sim 10^5\)</span> or smaller. A brief historical overview</p>
<table border="1">
<thead>
<tr><th align="center">    Year   </th> <th align="center">    $n$     </th> <th align="center">                 </th> </tr>
</thead>
<tbody>
<tr><td align="center">   1950           </td> <td align="center">   $n=20$          </td> <td align="center">   (Wilkinson)          </td> </tr>
<tr><td align="center">   1965           </td> <td align="center">   $n=200$         </td> <td align="center">   (Forsythe et al.)    </td> </tr>
<tr><td align="center">   1980           </td> <td align="center">   $n=2000$        </td> <td align="center">   Linpack              </td> </tr>
<tr><td align="center">   1995           </td> <td align="center">   $n=20000$       </td> <td align="center">   Lapack               </td> </tr>
<tr><td align="center">   This decade    </td> <td align="center">   $n\sim 10^5$    </td> <td align="center">   Lapack               </td> </tr>
</tbody>
</table>
shows that in the course of 60 years the dimension that  direct diagonalization methods can handle  has increased by almost a factor of
$10^4$ (note this is for serial versions). However, it pales beside the progress achieved by computer hardware, from flops to petaflops, a factor of almost $10^{15}$. We see clearly played out in history the $O(n^3)$ bottleneck  of direct matrix algorithms.
<p>Sloppily speaking, when  <span class="math notranslate nohighlight">\(n\sim 10^4\)</span> is cubed we have <span class="math notranslate nohighlight">\(O(10^{12})\)</span> operations, which is smaller than the <span class="math notranslate nohighlight">\(10^{15}\)</span> increase in flops.</p>
</div>
<div class="section" id="id73">
<h2><span class="section-number">3.120. </span>Discussion of methods for eigenvalues<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h2>
<p>If the matrix to diagonalize is large and sparse, direct methods simply become impractical,
also because
many of the direct methods tend to destroy sparsity. As a result large dense matrices may arise during the diagonalization procedure.  The idea behind iterative methods is to project the
<span class="math notranslate nohighlight">\(n-\)</span>dimensional problem in smaller spaces, so-called Krylov subspaces.
Given a matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, the associated Krylov sequences of vectors
(and thereby subspaces)
<span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{v}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{A}^2\mathbf{v}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{A}^3\mathbf{v},\dots\)</span>, represent
successively larger Krylov subspaces.</p>
<table border="1">
<thead>
<tr><th align="center">           Matrix           </th> <th align="center">$\mathbf{A}\mathbf{x}=\mathbf{b}$</th> <th align="center">$\mathbf{A}\mathbf{x}=\lambda\mathbf{x}$</th> </tr>
</thead>
<tbody>
<tr><td align="left">   $\mathbf{A}=\mathbf{A}^*$       </td> <td align="left">   Conjugate gradient                   </td> <td align="left">   Lanczos                                     </td> </tr>
<tr><td align="left">   $\mathbf{A}\ne \mathbf{A}^*$    </td> <td align="left">   GMRES etc                            </td> <td align="left">   Arnoldi                                     </td> </tr>
</tbody>
</table>
</div>
<div class="section" id="eigenvalues-and-lanczos-method">
<h2><span class="section-number">3.121. </span>Eigenvalues and Lanczos’ method<a class="headerlink" href="#eigenvalues-and-lanczos-method" title="Permalink to this headline">¶</a></h2>
<p>Basic features with a real symmetric matrix (and normally huge <span class="math notranslate nohighlight">\(n&gt; 10^6\)</span> and sparse)
<span class="math notranslate nohighlight">\(\hat{A}\)</span> of dimension <span class="math notranslate nohighlight">\(n\times n\)</span>:</p>
<ul class="simple">
<li><p>Lanczos’ algorithm generates a sequence of real tridiagonal matrices <span class="math notranslate nohighlight">\(T_k\)</span> of dimension <span class="math notranslate nohighlight">\(k\times k\)</span> with <span class="math notranslate nohighlight">\(k\le n\)</span>, with the property that the extremal eigenvalues of <span class="math notranslate nohighlight">\(T_k\)</span> are progressively better estimates of <span class="math notranslate nohighlight">\(\hat{A}\)</span>’ extremal eigenvalues.* The method converges to the extremal eigenvalues.</p></li>
<li><p>The similarity transformation is</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
\]</div>
<p>with the first vector <span class="math notranslate nohighlight">\(\hat{Q}\hat{e}_1=\hat{q}_1\)</span>.</p>
<p>We are going to solve iteratively</p>
<div class="math notranslate nohighlight">
\[
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
\]</div>
<p>with the first vector <span class="math notranslate nohighlight">\(\hat{Q}\hat{e}_1=\hat{q}_1\)</span>.
We can write out the matrix <span class="math notranslate nohighlight">\(\hat{Q}\)</span> in terms of its column vectors</p>
<div class="math notranslate nohighlight">
\[
\hat{Q}=\left[\hat{q}_1\hat{q}_2\dots\hat{q}_n\right].
\]</div>
</div>
<div class="section" id="eigenvalues-and-lanczos-method-tridiagonal-matrix">
<h2><span class="section-number">3.122. </span>Eigenvalues and Lanczos’ method, tridiagonal matrix<a class="headerlink" href="#eigenvalues-and-lanczos-method-tridiagonal-matrix" title="Permalink to this headline">¶</a></h2>
<p>The matrix</p>
<div class="math notranslate nohighlight">
\[
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
\]</div>
<p>can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{T} = \left(\begin{array}{cccccc}
                           \alpha_1&amp; \beta_1 &amp; 0 &amp;\dots   &amp; \dots &amp;0 \\
                           \beta_1 &amp; \alpha_2 &amp; \beta_2 &amp;0 &amp;\dots &amp;0 \\
                           0&amp; \beta_2 &amp; \alpha_3 &amp; \beta_3 &amp; \dots &amp;0 \\
                           \dots&amp; \dots   &amp; \dots &amp;\dots   &amp;\dots &amp; 0 \\
                           \dots&amp;   &amp;  &amp;\beta_{n-2}  &amp;\alpha_{n-1}&amp; \beta_{n-1} \\
                           0&amp;  \dots  &amp;\dots  &amp;0   &amp;\beta_{n-1} &amp; \alpha_{n} \\
                      \end{array} \right)
\end{split}\]</div>
</div>
<div class="section" id="eigenvalues-and-lanczos-method-tridiagonal-and-orthogonal-matrices">
<h2><span class="section-number">3.123. </span>Eigenvalues and Lanczos’ method, tridiagonal and orthogonal matrices<a class="headerlink" href="#eigenvalues-and-lanczos-method-tridiagonal-and-orthogonal-matrices" title="Permalink to this headline">¶</a></h2>
<p>Using the fact that</p>
<div class="math notranslate nohighlight">
\[
\hat{Q}\hat{Q}^T=\hat{I},
\]</div>
<p>we can rewrite</p>
<div class="math notranslate nohighlight">
\[
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
\]</div>
<p>as</p>
<div class="math notranslate nohighlight">
\[
\hat{Q}\hat{T}= \hat{A}\hat{Q}.
\]</div>
</div>
<div class="section" id="id74">
<h2><span class="section-number">3.124. </span>Eigenvalues and Lanczos’ method<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h2>
<p>If we equate columns</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{T} = \left(\begin{array}{cccccc}
        \alpha_1&amp; \beta_1 &amp; 0 &amp;\dots   &amp; \dots &amp;0 \\
        \beta_1 &amp; \alpha_2 &amp; \beta_2 &amp;0 &amp;\dots &amp;0 \\
        0&amp; \beta_2 &amp; \alpha_3 &amp; \beta_3 &amp; \dots &amp;0 \\
        \dots&amp; \dots   &amp; \dots &amp;\dots   &amp;\dots &amp; 0 \\
        \dots&amp;   &amp;  &amp;\beta_{n-2}  &amp;\alpha_{n-1}&amp; \beta_{n-1} \\
        0&amp;  \dots  &amp;\dots  &amp;0   &amp;\beta_{n-1} &amp; \alpha_{n} \\
        \end{array} \right)
\end{split}\]</div>
<p>we obtain</p>
<div class="math notranslate nohighlight">
\[
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1}.
\]</div>
</div>
<div class="section" id="eigenvalues-and-lanczos-method-defining-the-lanczos-vectors">
<h2><span class="section-number">3.125. </span>Eigenvalues and Lanczos’ method, defining the Lanczos’ vectors<a class="headerlink" href="#eigenvalues-and-lanczos-method-defining-the-lanczos-vectors" title="Permalink to this headline">¶</a></h2>
<p>We have thus</p>
<div class="math notranslate nohighlight">
\[
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1},
\]</div>
<p>with <span class="math notranslate nohighlight">\(\beta_0\hat{q}_0=0\)</span> for <span class="math notranslate nohighlight">\(k=1:n-1\)</span>. Remember that the vectors <span class="math notranslate nohighlight">\(\hat{q}_k\)</span>  are orthornormal and this implies</p>
<div class="math notranslate nohighlight">
\[
\alpha_k=\hat{q}_k^T\hat{A}\hat{q}_k,
\]</div>
<p>and these vectors are called Lanczos vectors.</p>
</div>
<div class="section" id="eigenvalues-and-lanczos-method-basic-steps">
<h2><span class="section-number">3.126. </span>Eigenvalues and Lanczos’ method, basic steps<a class="headerlink" href="#eigenvalues-and-lanczos-method-basic-steps" title="Permalink to this headline">¶</a></h2>
<p>We have thus</p>
<div class="math notranslate nohighlight">
\[
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1},
\]</div>
<p>with <span class="math notranslate nohighlight">\(\beta_0\hat{q}_0=0\)</span> for <span class="math notranslate nohighlight">\(k=1:n-1\)</span> and</p>
<div class="math notranslate nohighlight">
\[
\alpha_k=\hat{q}_k^T\hat{A}\hat{q}_k.
\]</div>
<p>If</p>
<div class="math notranslate nohighlight">
\[
\hat{r}_k=(\hat{A}-\alpha_k\hat{I})\hat{q}_k-\beta_{k-1}\hat{q}_{k-1},
\]</div>
<p>is non-zero, then</p>
<div class="math notranslate nohighlight">
\[
\hat{q}_{k+1}=\hat{r}_{k}/\beta_k,
\]</div>
<p>with <span class="math notranslate nohighlight">\(\beta_k=\pm ||\hat{r}_{k}||_2\)</span>.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="hartreefocktheory.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">2. </span>Hartree-Fock methods</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="mbpt.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Many-body perturbation theory</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Morten Hjorth-Jensen<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>