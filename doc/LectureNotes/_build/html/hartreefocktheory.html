
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Hartree-Fock methods &#8212; Advanced Topics in Computational Physics</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Full configuration interaction theory" href="fcitheory.html" />
    <link rel="prev" title="1. Many-body Hamiltonians, basic linear algebra and Second Quantization" href="basicmanybody.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Advanced Topics in Computational Physics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Advanced Topics in Computational Physics: Computational Quantum Mechanics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Schedule
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Instructor information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks and practicalities
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basic Many-Body Physics
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicmanybody.html">
   1. Many-body Hamiltonians, basic linear algebra and Second Quantization
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   2. Hartree-Fock methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fcitheory.html">
   3. Full configuration interaction theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mbpt.html">
   4. Many-body perturbation theory
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Stochastic Methods
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vmcdmc.html">
   5. Variational Monte Carlo methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="gradientmethods.html">
   6. Gradient Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="resamplingmethods.html">
   7. Resampling Techniques, Bootstrap and Blocking
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Computational Aspects
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vectorization.html">
   8. Optimization and Vectorization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallelization.html">
   9. Parallelization with MPI and OpenMPI
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Deep Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="linearregression.html">
   10. Linear Regression and more Advanced Regression Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="logisticregression.html">
   11. Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="supportvectormachines.html">
   12. Support Vector Machines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="neuralnetworks.html">
   13. Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boltzmannmachines.html">
   14. Boltzmann Machines
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Quantum Computing and Quantum Machine Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basicquantumcomputing.html">
   15. Quantum Computing
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/hartreefocktheory.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-hartree-fock-derivation-of-hartree-fock-equations-in-coordinate-space">
   2.1. Why Hartree-Fock? Derivation of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#variational-calculus-and-lagrangian-multipliers">
   2.2. Variational Calculus and Lagrangian Multipliers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#derivation-of-hartree-fock-equations-in-coordinate-space">
   2.3. Derivation of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis-of-hartree-fock-equations-in-coordinate-space">
   2.4. Analysis of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-by-varying-the-coefficients-of-a-wave-function-expansion">
   2.5. Hartree-Fock by varying the coefficients of a wave function expansion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-algorithm">
   2.6. Hartree-Fock algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis-of-hartree-fock-equations-and-koopman-s-theorem">
   2.7. Analysis of Hartree-Fock equations and Koopman’s theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-1-derivation-of-hartree-fock-equations">
   2.8. Exercise 1: Derivation of Hartree-Fock equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-2-derivation-of-hartree-fock-equations">
   2.9. Exercise 2: Derivation of Hartree-Fock equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-3-developing-a-hartree-fock-program">
   2.10. Exercise 3: Developing a  Hartree-Fock program
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-in-second-quantization-and-stability-of-hf-solution">
   2.11. Hartree-Fock in second quantization and stability of HF solution
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thouless-theorem">
   2.12. Thouless’ theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#new-operators">
   2.13. New operators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#showing-that-tilde-c-rangle-c-rangle">
   2.14. Showing that
   <span class="math notranslate nohighlight">
    \(|\tilde{c}\rangle= |c'\rangle\)
   </span>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   2.15. Hartree-Fock in second quantization and stability of HF solution
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Hartree-Fock methods</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-hartree-fock-derivation-of-hartree-fock-equations-in-coordinate-space">
   2.1. Why Hartree-Fock? Derivation of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#variational-calculus-and-lagrangian-multipliers">
   2.2. Variational Calculus and Lagrangian Multipliers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#derivation-of-hartree-fock-equations-in-coordinate-space">
   2.3. Derivation of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis-of-hartree-fock-equations-in-coordinate-space">
   2.4. Analysis of Hartree-Fock equations in coordinate space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-by-varying-the-coefficients-of-a-wave-function-expansion">
   2.5. Hartree-Fock by varying the coefficients of a wave function expansion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-algorithm">
   2.6. Hartree-Fock algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis-of-hartree-fock-equations-and-koopman-s-theorem">
   2.7. Analysis of Hartree-Fock equations and Koopman’s theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-1-derivation-of-hartree-fock-equations">
   2.8. Exercise 1: Derivation of Hartree-Fock equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-2-derivation-of-hartree-fock-equations">
   2.9. Exercise 2: Derivation of Hartree-Fock equations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise-3-developing-a-hartree-fock-program">
   2.10. Exercise 3: Developing a  Hartree-Fock program
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hartree-fock-in-second-quantization-and-stability-of-hf-solution">
   2.11. Hartree-Fock in second quantization and stability of HF solution
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thouless-theorem">
   2.12. Thouless’ theorem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#new-operators">
   2.13. New operators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#showing-that-tilde-c-rangle-c-rangle">
   2.14. Showing that
   <span class="math notranslate nohighlight">
    \(|\tilde{c}\rangle= |c'\rangle\)
   </span>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   2.15. Hartree-Fock in second quantization and stability of HF solution
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="hartree-fock-methods">
<h1><span class="section-number">2. </span>Hartree-Fock methods<a class="headerlink" href="#hartree-fock-methods" title="Permalink to this headline">¶</a></h1>
<div class="section" id="why-hartree-fock-derivation-of-hartree-fock-equations-in-coordinate-space">
<h2><span class="section-number">2.1. </span>Why Hartree-Fock? Derivation of Hartree-Fock equations in coordinate space<a class="headerlink" href="#why-hartree-fock-derivation-of-hartree-fock-equations-in-coordinate-space" title="Permalink to this headline">¶</a></h2>
<p>Hartree-Fock (HF) theory is an algorithm for finding an approximative expression for the ground state of a given Hamiltonian. The basic ingredients are</p>
<ul class="simple">
<li><p>Define a single-particle basis <span class="math notranslate nohighlight">\(\{\psi_{\alpha}\}\)</span> so that</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\hat{h}^{\mathrm{HF}}\psi_{\alpha} = \varepsilon_{\alpha}\psi_{\alpha}
\]</div>
<p>with the Hartree-Fock Hamiltonian defined as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{\mathrm{HF}}=\hat{t}+\hat{u}_{\mathrm{ext}}+\hat{u}^{\mathrm{HF}}
\]</div>
<ul class="simple">
<li><p>The term  <span class="math notranslate nohighlight">\(\hat{u}^{\mathrm{HF}}\)</span> is a single-particle potential to be determined by the HF algorithm.</p>
<ul>
<li><p>The HF algorithm means to choose <span class="math notranslate nohighlight">\(\hat{u}^{\mathrm{HF}}\)</span> in order to have</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[
\langle \hat{H} \rangle = E^{\mathrm{HF}}= \langle \Phi_0 | \hat{H}|\Phi_0 \rangle
\]</div>
<p>that is to find a local minimum with a Slater determinant <span class="math notranslate nohighlight">\(\Phi_0\)</span> being the ansatz for the ground state.</p>
<ul class="simple">
<li><p>The variational principle ensures that <span class="math notranslate nohighlight">\(E^{\mathrm{HF}} \ge E_0\)</span>, with <span class="math notranslate nohighlight">\(E_0\)</span> the exact ground state energy.</p></li>
</ul>
<p>We will show that the Hartree-Fock Hamiltonian <span class="math notranslate nohighlight">\(\hat{h}^{\mathrm{HF}}\)</span> equals our definition of the operator <span class="math notranslate nohighlight">\(\hat{f}\)</span> discussed in connection with the new definition of the normal-ordered Hamiltonian (see later lectures), that is we have, for a specific matrix element</p>
<div class="math notranslate nohighlight">
\[
\langle p |\hat{h}^{\mathrm{HF}}| q \rangle =\langle p |\hat{f}| q \rangle=\langle p|\hat{t}+\hat{u}_{\mathrm{ext}}|q \rangle +\sum_{i\le F} \langle pi | \hat{V} | qi\rangle_{AS},
\]</div>
<p>meaning that</p>
<div class="math notranslate nohighlight">
\[
\langle p|\hat{u}^{\mathrm{HF}}|q\rangle = \sum_{i\le F} \langle pi | \hat{V} | qi\rangle_{AS}.
\]</div>
<p>The so-called Hartree-Fock potential <span class="math notranslate nohighlight">\(\hat{u}^{\mathrm{HF}}\)</span> brings an explicit medium dependence due to the summation over all single-particle states below the Fermi level <span class="math notranslate nohighlight">\(F\)</span>. It brings also in an explicit dependence on the two-body interaction (in nuclear physics we can also have complicated three- or higher-body forces). The two-body interaction, with its contribution from the other bystanding fermions, creates an effective mean field in which a given fermion moves, in addition to the external potential <span class="math notranslate nohighlight">\(\hat{u}_{\mathrm{ext}}\)</span> which confines the motion of the fermion. For systems like nuclei, there is no external confining potential. Nuclei are examples of self-bound systems, where the binding arises due to the intrinsic nature of the strong force. For nuclear systems thus, there would be no external one-body potential in the Hartree-Fock Hamiltonian.</p>
</div>
<div class="section" id="variational-calculus-and-lagrangian-multipliers">
<h2><span class="section-number">2.2. </span>Variational Calculus and Lagrangian Multipliers<a class="headerlink" href="#variational-calculus-and-lagrangian-multipliers" title="Permalink to this headline">¶</a></h2>
<p>The calculus of variations involves
problems where the quantity to be minimized or maximized is an integral.</p>
<p>In the general case we have an integral of the type</p>
<div class="math notranslate nohighlight">
\[
E[\Phi]= \int_a^b f(\Phi(x),\frac{\partial \Phi}{\partial x},x)dx,
\]</div>
<p>where <span class="math notranslate nohighlight">\(E\)</span> is the quantity which is sought minimized or maximized.
The problem is that although <span class="math notranslate nohighlight">\(f\)</span> is a function of the variables <span class="math notranslate nohighlight">\(\Phi\)</span>, <span class="math notranslate nohighlight">\(\partial \Phi/\partial x\)</span> and <span class="math notranslate nohighlight">\(x\)</span>, the exact dependence of
<span class="math notranslate nohighlight">\(\Phi\)</span> on <span class="math notranslate nohighlight">\(x\)</span> is not known.  This means again that even though the integral has fixed limits <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, the path of integration is
not known. In our case the unknown quantities are the single-particle wave functions and we wish to choose an integration path which makes
the functional <span class="math notranslate nohighlight">\(E[\Phi]\)</span> stationary. This means that we want to find minima, or maxima or saddle points. In physics we search normally for minima.
Our task is therefore to find the minimum of <span class="math notranslate nohighlight">\(E[\Phi]\)</span> so that its variation <span class="math notranslate nohighlight">\(\delta E\)</span> is zero  subject to specific
constraints. In our case the constraints appear as the integral which expresses the orthogonality of the  single-particle wave functions.
The constraints can be treated via the technique of Lagrangian multipliers</p>
<p>Let us specialize to the expectation value of the energy for one particle in three-dimensions.
This expectation value reads</p>
<div class="math notranslate nohighlight">
\[
E=\int dxdydz \psi^*(x,y,z) \hat{H} \psi(x,y,z),
\]</div>
<p>with the constraint</p>
<div class="math notranslate nohighlight">
\[
\int dxdydz \psi^*(x,y,z) \psi(x,y,z)=1,
\]</div>
<p>and a Hamiltonian</p>
<div class="math notranslate nohighlight">
\[
\hat{H}=-\frac{1}{2}\nabla^2+V(x,y,z).
\]</div>
<p>We will, for the sake of notational convenience,  skip the variables <span class="math notranslate nohighlight">\(x,y,z\)</span> below, and write for example <span class="math notranslate nohighlight">\(V(x,y,z)=V\)</span>.</p>
<p>The integral involving the kinetic energy can be written as, with the function <span class="math notranslate nohighlight">\(\psi\)</span> vanishing
strongly for large values of <span class="math notranslate nohighlight">\(x,y,z\)</span> (given here by the limits <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>),</p>
<div class="math notranslate nohighlight">
\[
\int_a^b dxdydz \psi^* \left(-\frac{1}{2}\nabla^2\right) \psi dxdydz = \psi^*\nabla\psi|_a^b+\int_a^b dxdydz\frac{1}{2}\nabla\psi^*\nabla\psi.
\]</div>
<p>We will drop the limits <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> in the remaining discussion.
Inserting this expression into the expectation value for the energy and taking the variational minimum  we obtain</p>
<div class="math notranslate nohighlight">
\[
\delta E = \delta \left\{\int dxdydz\left( \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi\right)\right\} = 0.
\]</div>
<p>The constraint appears in integral form as</p>
<div class="math notranslate nohighlight">
\[
\int dxdydz \psi^* \psi=\mathrm{constant},
\]</div>
<p>and multiplying with a Lagrangian multiplier <span class="math notranslate nohighlight">\(\lambda\)</span> and taking the variational minimum we obtain the final variational equation</p>
<div class="math notranslate nohighlight">
\[
\delta \left\{\int dxdydz\left( \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi-\lambda\psi^*\psi\right)\right\} = 0.
\]</div>
<p>We introduce the function  <span class="math notranslate nohighlight">\(f\)</span></p>
<div class="math notranslate nohighlight">
\[
f =  \frac{1}{2}\nabla\psi^*\nabla\psi+V\psi^*\psi-\lambda\psi^*\psi=
\frac{1}{2}(\psi^*_x\psi_x+\psi^*_y\psi_y+\psi^*_z\psi_z)+V\psi^*\psi-\lambda\psi^*\psi,
\]</div>
<p>where we have skipped the dependence on <span class="math notranslate nohighlight">\(x,y,z\)</span> and introduced the shorthand <span class="math notranslate nohighlight">\(\psi_x\)</span>, <span class="math notranslate nohighlight">\(\psi_y\)</span> and <span class="math notranslate nohighlight">\(\psi_z\)</span>  for the various derivatives.</p>
<p>For <span class="math notranslate nohighlight">\(\psi^*\)</span> the Euler-Lagrange  equations yield</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial f}{\partial \psi^*}- \frac{\partial }{\partial x}\frac{\partial f}{\partial \psi^*_x}-\frac{\partial }{\partial y}\frac{\partial f}{\partial \psi^*_y}-\frac{\partial }{\partial z}\frac{\partial f}{\partial \psi^*_z}=0,
\]</div>
<p>which results in</p>
<div class="math notranslate nohighlight">
\[
-\frac{1}{2}(\psi_{xx}+\psi_{yy}+\psi_{zz})+V\psi=\lambda \psi.
\]</div>
<p>We can then identify the  Lagrangian multiplier as the energy of the system. The last equation is
nothing but the standard
Schroedinger equation and the variational  approach discussed here provides
a powerful method for obtaining approximate solutions of the wave function.</p>
</div>
<div class="section" id="derivation-of-hartree-fock-equations-in-coordinate-space">
<h2><span class="section-number">2.3. </span>Derivation of Hartree-Fock equations in coordinate space<a class="headerlink" href="#derivation-of-hartree-fock-equations-in-coordinate-space" title="Permalink to this headline">¶</a></h2>
<p>Let us denote the ground state energy by <span class="math notranslate nohighlight">\(E_0\)</span>. According to the
variational principle we have</p>
<div class="math notranslate nohighlight">
\[
E_0 \le E[\Phi] = \int \Phi^*\hat{H}\Phi d\mathbf{\tau}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> is a trial function which we assume to be normalized</p>
<div class="math notranslate nohighlight">
\[
\int \Phi^*\Phi d\mathbf{\tau} = 1,
\]</div>
<p>where we have used the shorthand <span class="math notranslate nohighlight">\(d\mathbf{\tau}=dx_1dx_2\dots dx_A\)</span>.</p>
<p>In the Hartree-Fock method the trial function is a Slater
determinant which can be rewritten as</p>
<div class="math notranslate nohighlight">
\[
\Psi(x_1,x_2,\dots,x_A,\alpha,\beta,\dots,\nu) = \frac{1}{\sqrt{A!}}\sum_{P} (-)^PP\psi_{\alpha}(x_1)
    \psi_{\beta}(x_2)\dots\psi_{\nu}(x_A)=\sqrt{A!}\hat{A}\Phi_H,
\]</div>
<p>where we have introduced the anti-symmetrization operator <span class="math notranslate nohighlight">\(\hat{A}\)</span> defined by the
summation over all possible permutations <em>p</em> of two fermions.
It is defined as</p>
<div class="math notranslate nohighlight">
\[
\hat{A} = \frac{1}{A!}\sum_{p} (-)^p\hat{P},
\]</div>
<p>with the the Hartree-function given by the simple product of all possible single-particle function</p>
<div class="math notranslate nohighlight">
\[
\Phi_H(x_1,x_2,\dots,x_A,\alpha,\beta,\dots,\nu) =
  \psi_{\alpha}(x_1)
    \psi_{\beta}(x_2)\dots\psi_{\nu}(x_A).
\]</div>
<p>Our functional is written as</p>
<div class="math notranslate nohighlight">
\[
E[\Phi] = \sum_{\mu=1}^A \int \psi_{\mu}^*(x_i)\hat{h}_0(x_i)\psi_{\mu}(x_i) dx_i 
  + \frac{1}{2}\sum_{\mu=1}^A\sum_{\nu=1}^A
   \left[ \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)\hat{v}(r_{ij})\psi_{\mu}(x_i)\psi_{\nu}(x_j)dx_idx_j- \int \psi_{\mu}^*(x_i)\psi_{\nu}^*(x_j)
 \hat{v}(r_{ij})\psi_{\nu}(x_i)\psi_{\mu}(x_j)dx_idx_j\right]
\]</div>
<p>The more compact version reads</p>
<div class="math notranslate nohighlight">
\[
E[\Phi] 
  = \sum_{\mu}^A \langle \mu | \hat{h}_0 | \mu\rangle+ \frac{1}{2}\sum_{\mu\nu}^A\left[\langle \mu\nu |\hat{v}|\mu\nu\rangle-\langle \nu\mu |\hat{v}|\mu\nu\rangle\right].
\]</div>
<p>Since the interaction is invariant under the interchange of two particles it means for example that we have</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\mu\nu\rangle =  \langle \nu\mu|\hat{v}|\nu\mu\rangle,
\]</div>
<p>or in the more general case</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\sigma\tau\rangle =  \langle \nu\mu|\hat{v}|\tau\sigma\rangle.
\]</div>
<p>The direct and exchange matrix elements can be  brought together if we define the antisymmetrized matrix element</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\mu\nu\rangle_{AS}= \langle \mu\nu|\hat{v}|\mu\nu\rangle-\langle \mu\nu|\hat{v}|\nu\mu\rangle,
\]</div>
<p>or for a general matrix element</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{AS}= \langle \mu\nu|\hat{v}|\sigma\tau\rangle-\langle \mu\nu|\hat{v}|\tau\sigma\rangle.
\]</div>
<p>It has the symmetry property</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{AS}= -\langle \mu\nu|\hat{v}|\tau\sigma\rangle_{AS}=-\langle \nu\mu|\hat{v}|\sigma\tau\rangle_{AS}.
\]</div>
<p>The antisymmetric matrix element is also hermitian, implying</p>
<div class="math notranslate nohighlight">
\[
\langle \mu\nu|\hat{v}|\sigma\tau\rangle_{AS}= \langle \sigma\tau|\hat{v}|\mu\nu\rangle_{AS}.
\]</div>
<p>With these notations we rewrite the Hartree-Fock functional as</p>
<!-- Equation labels as ordinary links -->
<div id="H2Expectation2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  \int \Phi^*\hat{H_I}\Phi d\mathbf{\tau} 
  = \frac{1}{2}\sum_{\mu=1}^A\sum_{\nu=1}^A \langle \mu\nu|\hat{v}|\mu\nu\rangle_{AS}. \label{H2Expectation2} \tag{1}
\end{equation}
\]</div>
<p>Adding the contribution from the one-body operator <span class="math notranslate nohighlight">\(\hat{H}_0\)</span> to
(<a class="reference external" href="#H2Expectation2">1</a>) we obtain the energy functional</p>
<!-- Equation labels as ordinary links -->
<div id="FunctionalEPhi"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  E[\Phi] 
  = \sum_{\mu=1}^A \langle \mu | h | \mu \rangle +
  \frac{1}{2}\sum_{{\mu}=1}^A\sum_{{\nu}=1}^A \langle \mu\nu|\hat{v}|\mu\nu\rangle_{AS}. \label{FunctionalEPhi} \tag{2}
\end{equation}
\]</div>
<p>In our coordinate space derivations below we will spell out the Hartree-Fock equations in terms of their integrals.</p>
<p>If we generalize the Euler-Lagrange equations to more variables
and introduce <span class="math notranslate nohighlight">\(N^2\)</span> Lagrange multipliers which we denote by
<span class="math notranslate nohighlight">\(\epsilon_{\mu\nu}\)</span>, we can write the variational equation for the functional of <span class="math notranslate nohighlight">\(E\)</span></p>
<div class="math notranslate nohighlight">
\[
\delta E - \sum_{\mu\nu}^A \epsilon_{\mu\nu} \delta
  \int \psi_{\mu}^* \psi_{\nu} = 0.
\]</div>
<p>For the orthogonal wave functions <span class="math notranslate nohighlight">\(\psi_{i}\)</span> this reduces to</p>
<div class="math notranslate nohighlight">
\[
\delta E - \sum_{\mu=1}^A \epsilon_{\mu} \delta
  \int \psi_{\mu}^* \psi_{\mu} = 0.
\]</div>
<p>Variation with respect to the single-particle wave functions <span class="math notranslate nohighlight">\(\psi_{\mu}\)</span> yields then</p>
<p>3
3</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\sum_{\mu=1}^A \int \psi_{\mu}^*\hat{h_0}(x_i)\delta\psi_{\mu}
  dx_i 
  + \frac{1}{2}\sum_{{\mu}=1}^A\sum_{{\nu}=1}^A \left[ \int
  \psi_{\mu}^*\psi_{\nu}^*\hat{v}(r_{ij})\delta\psi_{\mu}\psi_{\nu} dx_idx_j- \int
  \psi_{\mu}^*\psi_{\nu}^*\hat{v}(r_{ij})\psi_{\nu}\delta\psi_{\mu}
  dx_idx_j \right]-  \sum_{{\mu}=1}^A E_{\mu} \int \delta\psi_{\mu}^*
  \psi_{\mu}dx_i
  -  \sum_{{\mu}=1}^A E_{\mu} \int \psi_{\mu}^*
  \delta\psi_{\mu}dx_i = 0.
\]</div>
<p>Although the variations <span class="math notranslate nohighlight">\(\delta\psi\)</span> and <span class="math notranslate nohighlight">\(\delta\psi^*\)</span> are not
independent, they may in fact be treated as such, so that the
terms dependent on either <span class="math notranslate nohighlight">\(\delta\psi\)</span> and <span class="math notranslate nohighlight">\(\delta\psi^*\)</span> individually
may be set equal to zero. To see this, simply
replace the arbitrary variation <span class="math notranslate nohighlight">\(\delta\psi\)</span> by <span class="math notranslate nohighlight">\(i\delta\psi\)</span>, so that
<span class="math notranslate nohighlight">\(\delta\psi^*\)</span> is replaced by <span class="math notranslate nohighlight">\(-i\delta\psi^*\)</span>, and combine the two
equations. We thus arrive at the Hartree-Fock equations</p>
<!-- Equation labels as ordinary links -->
<div id="eq:hartreefockcoordinatespace"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\left[ -\frac{1}{2}\nabla_i^2+ \sum_{\nu=1}^A\int \psi_{\nu}^*(x_j)\hat{v}(r_{ij})\psi_{\nu}(x_j)dx_j \right]\psi_{\mu}(x_i) - \left[ \sum_{{\nu}=1}^A \int\psi_{\nu}^*(x_j)\hat{v}(r_{ij})\psi_{\mu}(x_j) dx_j\right] \psi_{\nu}(x_i) = \epsilon_{\mu} \psi_{\mu}(x_i).  \label{eq:hartreefockcoordinatespace} \tag{3}
\end{equation}
\]</div>
<p>Notice that the integration <span class="math notranslate nohighlight">\(\int dx_j\)</span> implies an
integration over the spatial coordinates <span class="math notranslate nohighlight">\(\mathbf{r_j}\)</span> and a summation
over the spin-coordinate of fermion <span class="math notranslate nohighlight">\(j\)</span>. We note that the factor of <span class="math notranslate nohighlight">\(1/2\)</span> in front of the sum involving the two-body interaction, has been removed. This is due to the fact that we need to vary both <span class="math notranslate nohighlight">\(\delta\psi_{\mu}^*\)</span> and
<span class="math notranslate nohighlight">\(\delta\psi_{\nu}^*\)</span>. Using the symmetry properties of the two-body interaction and interchanging <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\nu\)</span>
as summation indices, we obtain two identical terms.</p>
<p>The two first terms in the last equation are the one-body kinetic energy and the
electron-nucleus potential. The third or <em>direct</em> term is the averaged electronic repulsion of the other
electrons. As written, the
term includes the <em>self-interaction</em> of
electrons when <span class="math notranslate nohighlight">\(\mu=\nu\)</span>. The self-interaction is cancelled in the fourth
term, or the <em>exchange</em> term. The exchange term results from our
inclusion of the Pauli principle and the assumed determinantal form of
the wave-function. Equation (<a class="reference external" href="#eq:hartreefockcoordinatespace">3</a>), in addition to the kinetic energy and the attraction from the atomic nucleus that confines the motion of a single electron,   represents now the motion of a single-particle modified by the two-body interaction. The additional contribution to the Schroedinger equation due to the two-body interaction, represents a mean field set up by all the other bystanding electrons, the latter given by the sum over all single-particle states occupied by <span class="math notranslate nohighlight">\(N\)</span> electrons.</p>
<p>The Hartree-Fock equation is an example of an integro-differential equation. These equations involve repeated calculations of integrals, in addition to the solution of a set of coupled differential equations.
The Hartree-Fock equations can also be rewritten in terms of an eigenvalue problem. The solution of an eigenvalue problem represents often a more practical algorithm and the  solution of  coupled  integro-differential equations.
This alternative derivation of the Hartree-Fock equations is given below.</p>
</div>
<div class="section" id="analysis-of-hartree-fock-equations-in-coordinate-space">
<h2><span class="section-number">2.4. </span>Analysis of Hartree-Fock equations in coordinate space<a class="headerlink" href="#analysis-of-hartree-fock-equations-in-coordinate-space" title="Permalink to this headline">¶</a></h2>
<p>A theoretically convenient form of the
Hartree-Fock equation is to regard the direct and exchange operator
defined through</p>
<div class="math notranslate nohighlight">
\[
V_{\mu}^{d}(x_i) = \int \psi_{\mu}^*(x_j) 
 \hat{v}(r_{ij})\psi_{\mu}(x_j) dx_j
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
V_{\mu}^{ex}(x_i) g(x_i) 
  = \left(\int \psi_{\mu}^*(x_j) 
 \hat{v}(r_{ij})g(x_j) dx_j
  \right)\psi_{\mu}(x_i),
\]</div>
<p>respectively.</p>
<p>The function <span class="math notranslate nohighlight">\(g(x_i)\)</span> is an arbitrary function,
and by the substitution <span class="math notranslate nohighlight">\(g(x_i) = \psi_{\nu}(x_i)\)</span>
we get</p>
<div class="math notranslate nohighlight">
\[
V_{\mu}^{ex}(x_i) \psi_{\nu}(x_i) 
  = \left(\int \psi_{\mu}^*(x_j) 
 \hat{v}(r_{ij})\psi_{\nu}(x_j)
  dx_j\right)\psi_{\mu}(x_i).
\]</div>
<p>We may then rewrite the Hartree-Fock equations as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{HF}(x_i) \psi_{\nu}(x_i) = \epsilon_{\nu}\psi_{\nu}(x_i),
\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{HF}(x_i)= \hat{h}_0(x_i) + \sum_{\mu=1}^AV_{\mu}^{d}(x_i) -
  \sum_{\mu=1}^AV_{\mu}^{ex}(x_i),
\]</div>
<p>and where <span class="math notranslate nohighlight">\(\hat{h}_0(i)\)</span> is the one-body part. The latter is normally chosen as a part which yields solutions in closed form. The harmonic oscilltor is a classical problem thereof.
We normally rewrite the last equation as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{HF}(x_i)= \hat{h}_0(x_i) + \hat{u}^{HF}(x_i).
\]</div>
</div>
<div class="section" id="hartree-fock-by-varying-the-coefficients-of-a-wave-function-expansion">
<h2><span class="section-number">2.5. </span>Hartree-Fock by varying the coefficients of a wave function expansion<a class="headerlink" href="#hartree-fock-by-varying-the-coefficients-of-a-wave-function-expansion" title="Permalink to this headline">¶</a></h2>
<p>Another possibility is to expand the single-particle functions in a known basis  and vary the coefficients,
that is, the new single-particle wave function is written as a linear expansion
in terms of a fixed chosen orthogonal basis (for example the well-known harmonic oscillator functions or the hydrogen-like functions etc).
We define our new Hartree-Fock single-particle basis by performing a unitary transformation
on our previous basis (labelled with greek indices) as</p>
<!-- Equation labels as ordinary links -->
<div id="eq:newbasis"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\psi_p^{HF}  = \sum_{\lambda} C_{p\lambda}\phi_{\lambda}. \label{eq:newbasis} \tag{4}
\end{equation}
\]</div>
<p>In this case we vary the coefficients <span class="math notranslate nohighlight">\(C_{p\lambda}\)</span>. If the basis has infinitely many solutions, we need
to truncate the above sum.  We assume that the basis <span class="math notranslate nohighlight">\(\phi_{\lambda}\)</span> is orthogonal.</p>
<p>It is normal to choose a single-particle basis defined as the eigenfunctions
of parts of the full Hamiltonian. The typical situation consists of the solutions of the one-body part of the Hamiltonian, that is we have</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_0\phi_{\lambda}=\epsilon_{\lambda}\phi_{\lambda}.
\]</div>
<p>The single-particle wave functions <span class="math notranslate nohighlight">\(\phi_{\lambda}(\mathbf{r})\)</span>, defined by the quantum numbers <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mathbf{r}\)</span>
are defined as the overlap</p>
<div class="math notranslate nohighlight">
\[
\phi_{\lambda}(\mathbf{r})  = \langle \mathbf{r} | \lambda \rangle .
\]</div>
<p>In deriving the Hartree-Fock equations, we  will expand the single-particle functions in a known basis  and vary the coefficients,
that is, the new single-particle wave function is written as a linear expansion
in terms of a fixed chosen orthogonal basis (for example the well-known harmonic oscillator functions or the hydrogen-like functions etc).</p>
<p>We stated that a unitary transformation keeps the orthogonality. To see this consider first a basis of vectors <span class="math notranslate nohighlight">\(\mathbf{v}_i\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{v}_i = \begin{bmatrix} v_{i1} \\ \dots \\ \dots \\v_{in} \end{bmatrix}
\end{split}\]</div>
<p>We assume that the basis is orthogonal, that is</p>
<div class="math notranslate nohighlight">
\[
\mathbf{v}_j^T\mathbf{v}_i = \delta_{ij}.
\]</div>
<p>An orthogonal or unitary transformation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{w}_i=\mathbf{U}\mathbf{v}_i,
\]</div>
<p>preserves the dot product and orthogonality since</p>
<div class="math notranslate nohighlight">
\[
\mathbf{w}_j^T\mathbf{w}_i=(\mathbf{U}\mathbf{v}_j)^T\mathbf{U}\mathbf{v}_i=\mathbf{v}_j^T\mathbf{U}^T\mathbf{U}\mathbf{v}_i= \mathbf{v}_j^T\mathbf{v}_i = \delta_{ij}.
\]</div>
<p>This means that if the coefficients <span class="math notranslate nohighlight">\(C_{p\lambda}\)</span> belong to a unitary or orthogonal trasformation (using the Dirac bra-ket notation)</p>
<div class="math notranslate nohighlight">
\[
\vert p\rangle  = \sum_{\lambda} C_{p\lambda}\vert\lambda\rangle,
\]</div>
<p>orthogonality is preserved, that is <span class="math notranslate nohighlight">\(\langle \alpha \vert \beta\rangle = \delta_{\alpha\beta}\)</span>
and <span class="math notranslate nohighlight">\(\langle p \vert q\rangle = \delta_{pq}\)</span>.</p>
<p>This propertry is extremely useful when we build up a basis of many-body Stater determinant based states.</p>
<p><strong>Note also that although a basis <span class="math notranslate nohighlight">\(\vert \alpha\rangle\)</span> contains an infinity of states, for practical calculations we have always to make some truncations.</strong></p>
<p>Before we develop the Hartree-Fock equations, there is another very useful property of determinants that we will use both in connection with Hartree-Fock calculations and later shell-model calculations.</p>
<p>Consider the following determinant</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left| \begin{array}{cc} \alpha_1b_{11}+\alpha_2sb_{12}&amp; a_{12}\\
                         \alpha_1b_{21}+\alpha_2b_{22}&amp;a_{22}\end{array} \right|=\alpha_1\left|\begin{array}{cc} b_{11}&amp; a_{12}\\
                         b_{21}&amp;a_{22}\end{array} \right|+\alpha_2\left| \begin{array}{cc} b_{12}&amp; a_{12}\\b_{22}&amp;a_{22}\end{array} \right|
\end{split}\]</div>
<p>We can generalize this to  an <span class="math notranslate nohighlight">\(n\times n\)</span> matrix and have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left| \begin{array}{cccccc} a_{11}&amp; a_{12} &amp; \dots &amp; \sum_{k=1}^n c_k b_{1k} &amp;\dots &amp; a_{1n}\\
a_{21}&amp; a_{22} &amp; \dots &amp; \sum_{k=1}^n c_k b_{2k} &amp;\dots &amp; a_{2n}\\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
a_{n1}&amp; a_{n2} &amp; \dots &amp; \sum_{k=1}^n c_k b_{nk} &amp;\dots &amp; a_{nn}\end{array} \right|=
\sum_{k=1}^n c_k\left| \begin{array}{cccccc} a_{11}&amp; a_{12} &amp; \dots &amp;  b_{1k} &amp;\dots &amp; a_{1n}\\
a_{21}&amp; a_{22} &amp; \dots &amp;  b_{2k} &amp;\dots &amp; a_{2n}\\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots\\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots\\
a_{n1}&amp; a_{n2} &amp; \dots &amp;  b_{nk} &amp;\dots &amp; a_{nn}\end{array} \right| .
\end{split}\]</div>
<p>This is a property we will use in our Hartree-Fock discussions.</p>
<p>We can generalize the previous results, now
with all elements <span class="math notranslate nohighlight">\(a_{ij}\)</span>  being given as functions of
linear combinations  of various coefficients <span class="math notranslate nohighlight">\(c\)</span> and elements <span class="math notranslate nohighlight">\(b_{ij}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left| \begin{array}{cccccc} \sum_{k=1}^n b_{1k}c_{k1}&amp; \sum_{k=1}^n b_{1k}c_{k2} &amp; \dots &amp; \sum_{k=1}^n b_{1k}c_{kj}  &amp;\dots &amp; \sum_{k=1}^n b_{1k}c_{kn}\\
\sum_{k=1}^n b_{2k}c_{k1}&amp; \sum_{k=1}^n b_{2k}c_{k2} &amp; \dots &amp; \sum_{k=1}^n b_{2k}c_{kj} &amp;\dots &amp; \sum_{k=1}^n b_{2k}c_{kn}\\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp;\dots \\
\sum_{k=1}^n b_{nk}c_{k1}&amp; \sum_{k=1}^n b_{nk}c_{k2} &amp; \dots &amp; \sum_{k=1}^n b_{nk}c_{kj} &amp;\dots &amp; \sum_{k=1}^n b_{nk}c_{kn}\end{array} \right|=det(\mathbf{C})det(\mathbf{B}),
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(det(\mathbf{C})\)</span> and <span class="math notranslate nohighlight">\(det(\mathbf{B})\)</span> are the determinants of <span class="math notranslate nohighlight">\(n\times n\)</span> matrices
with elements <span class="math notranslate nohighlight">\(c_{ij}\)</span> and <span class="math notranslate nohighlight">\(b_{ij}\)</span> respectively.<br />
This is a property we will use in our Hartree-Fock discussions. Convince yourself about the correctness of the above expression by setting <span class="math notranslate nohighlight">\(n=2\)</span>.</p>
<p>With our definition of the new basis in terms of an orthogonal basis we have</p>
<div class="math notranslate nohighlight">
\[
\psi_p(x)  = \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x).
\]</div>
<p>If the coefficients <span class="math notranslate nohighlight">\(C_{p\lambda}\)</span> belong to an orthogonal or unitary matrix, the new basis
is also orthogonal.
Our Slater determinant in the new basis <span class="math notranslate nohighlight">\(\psi_p(x)\)</span> is written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\frac{1}{\sqrt{A!}}
\left| \begin{array}{ccccc} \psi_{p}(x_1)&amp; \psi_{p}(x_2)&amp; \dots &amp; \dots &amp; \psi_{p}(x_A)\\
                            \psi_{q}(x_1)&amp;\psi_{q}(x_2)&amp; \dots &amp; \dots &amp; \psi_{q}(x_A)\\  
                            \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
                            \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
                     \psi_{t}(x_1)&amp;\psi_{t}(x_2)&amp; \dots &amp; \dots &amp; \psi_{t}(x_A)\end{array} \right|=\frac{1}{\sqrt{A!}}
\left| \begin{array}{ccccc} \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_1)&amp; \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_2)&amp; \dots &amp; \dots &amp; \sum_{\lambda} C_{p\lambda}\phi_{\lambda}(x_A)\\
                            \sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_1)&amp;\sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_2)&amp; \dots &amp; \dots &amp; \sum_{\lambda} C_{q\lambda}\phi_{\lambda}(x_A)\\  
                            \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
                            \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\
                     \sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_1)&amp;\sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_2)&amp; \dots &amp; \dots &amp; \sum_{\lambda} C_{t\lambda}\phi_{\lambda}(x_A)\end{array} \right|,
\end{split}\]</div>
<p>which is nothing but <span class="math notranslate nohighlight">\(det(\mathbf{C})det(\Phi)\)</span>, with <span class="math notranslate nohighlight">\(det(\Phi)\)</span> being the determinant given by the basis functions <span class="math notranslate nohighlight">\(\phi_{\lambda}(x)\)</span>.</p>
<p>In our discussions hereafter we will use our definitions of single-particle states above and below the Fermi (<span class="math notranslate nohighlight">\(F\)</span>) level given by the labels
<span class="math notranslate nohighlight">\(ijkl\dots \le F\)</span> for so-called single-hole states and <span class="math notranslate nohighlight">\(abcd\dots &gt; F\)</span> for so-called particle states.
For general single-particle states we employ the labels <span class="math notranslate nohighlight">\(pqrs\dots\)</span>.</p>
<p>In Eq. (<a class="reference external" href="#FunctionalEPhi">2</a>), restated here</p>
<div class="math notranslate nohighlight">
\[
E[\Phi] 
  = \sum_{\mu=1}^A \langle \mu | h | \mu \rangle +
  \frac{1}{2}\sum_{{\mu}=1}^A\sum_{{\nu}=1}^A \langle \mu\nu|\hat{v}|\mu\nu\rangle_{AS},
\]</div>
<p>we found the expression for the energy functional in terms of the basis function <span class="math notranslate nohighlight">\(\phi_{\lambda}(\mathbf{r})\)</span>. We then  varied the above energy functional with respect to the basis functions <span class="math notranslate nohighlight">\(|\mu \rangle\)</span>.
Now we are interested in defining a new basis defined in terms of
a chosen basis as defined in Eq. (<a class="reference external" href="#eq:newbasis">4</a>). We can then rewrite the energy functional as</p>
<!-- Equation labels as ordinary links -->
<div id="FunctionalEPhi2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  E[\Phi^{HF}] 
  = \sum_{i=1}^A \langle i | h | i \rangle +
  \frac{1}{2}\sum_{ij=1}^A\langle ij|\hat{v}|ij\rangle_{AS}, \label{FunctionalEPhi2} \tag{5}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi^{HF}\)</span> is the new Slater determinant defined by the new basis of Eq. (<a class="reference external" href="#eq:newbasis">4</a>).</p>
<p>Using Eq. (<a class="reference external" href="#eq:newbasis">4</a>) we can rewrite Eq. (<a class="reference external" href="#FunctionalEPhi2">5</a>) as</p>
<!-- Equation labels as ordinary links -->
<div id="FunctionalEPhi3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  E[\Psi] 
  = \sum_{i=1}^A \sum_{\alpha\beta} C^*_{i\alpha}C_{i\beta}\langle \alpha | h | \beta \rangle +
  \frac{1}{2}\sum_{ij=1}^A\sum_{{\alpha\beta\gamma\delta}} C^*_{i\alpha}C^*_{j\beta}C_{i\gamma}C_{j\delta}\langle \alpha\beta|\hat{v}|\gamma\delta\rangle_{AS}. \label{FunctionalEPhi3} \tag{6}
\end{equation}
\]</div>
<p>We wish now to minimize the above functional. We introduce again a set of Lagrange multipliers, noting that
since <span class="math notranslate nohighlight">\(\langle i | j \rangle = \delta_{i,j}\)</span> and <span class="math notranslate nohighlight">\(\langle \alpha | \beta \rangle = \delta_{\alpha,\beta}\)</span>,
the coefficients <span class="math notranslate nohighlight">\(C_{i\gamma}\)</span> obey the relation</p>
<div class="math notranslate nohighlight">
\[
\langle i | j \rangle=\delta_{i,j}=\sum_{\alpha\beta} C^*_{i\alpha}C_{i\beta}\langle \alpha | \beta \rangle=
\sum_{\alpha} C^*_{i\alpha}C_{i\alpha},
\]</div>
<p>which allows us to define a functional to be minimized that reads</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  F[\Phi^{HF}]=E[\Phi^{HF}] - \sum_{i=1}^A\epsilon_i\sum_{\alpha} C^*_{i\alpha}C_{i\alpha}.
\label{_auto1} \tag{7}
\end{equation}
\]</div>
<p>Minimizing with respect to <span class="math notranslate nohighlight">\(C^*_{i\alpha}\)</span>, remembering that the equations for <span class="math notranslate nohighlight">\(C^*_{i\alpha}\)</span> and <span class="math notranslate nohighlight">\(C_{i\alpha}\)</span>
can be written as two  independent equations, we obtain</p>
<div class="math notranslate nohighlight">
\[
\frac{d}{dC^*_{i\alpha}}\left[  E[\Phi^{HF}] - \sum_{j}\epsilon_j\sum_{\alpha} C^*_{j\alpha}C_{j\alpha}\right]=0,
\]</div>
<p>which yields for every single-particle state <span class="math notranslate nohighlight">\(i\)</span> and index <span class="math notranslate nohighlight">\(\alpha\)</span> (recalling that the coefficients <span class="math notranslate nohighlight">\(C_{i\alpha}\)</span> are matrix elements of a unitary (or orthogonal for a real symmetric matrix) matrix)
the following Hartree-Fock equations</p>
<div class="math notranslate nohighlight">
\[
\sum_{\beta} C_{i\beta}\langle \alpha | h | \beta \rangle+
\sum_{j=1}^A\sum_{\beta\gamma\delta} C^*_{j\beta}C_{j\delta}C_{i\gamma}\langle \alpha\beta|\hat{v}|\gamma\delta\rangle_{AS}=\epsilon_i^{HF}C_{i\alpha}.
\]</div>
<p>We can rewrite this equation as (changing dummy variables)</p>
<div class="math notranslate nohighlight">
\[
\sum_{\beta} \left\{\langle \alpha | h | \beta \rangle+
\sum_{j}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}\right\}C_{i\beta}=\epsilon_i^{HF}C_{i\alpha}.
\]</div>
<p>Note that the sums over greek indices run over the number of basis set functions (in principle an infinite number).</p>
<p>Defining</p>
<div class="math notranslate nohighlight">
\[
h_{\alpha\beta}^{HF}=\langle \alpha | h | \beta \rangle+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS},
\]</div>
<p>we can rewrite the new equations as</p>
<!-- Equation labels as ordinary links -->
<div id="eq:newhf"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{\beta}h_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{HF}C_{i\alpha}. \label{eq:newhf} \tag{8}
\end{equation}
\]</div>
<p>The latter is nothing but a standard eigenvalue problem. Compared with Eq. (<a class="reference external" href="#eq:hartreefockcoordinatespace">3</a>),
we see that we do not need to compute any integrals in an iterative procedure for solving the equations.
It suffices to tabulate the matrix elements <span class="math notranslate nohighlight">\(\langle \alpha | h | \beta \rangle\)</span> and <span class="math notranslate nohighlight">\(\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}\)</span> once and for all. Successive iterations require thus only a look-up in tables over one-body and two-body matrix elements. These details will be discussed below when we solve the Hartree-Fock equations numerical.</p>
</div>
<div class="section" id="hartree-fock-algorithm">
<h2><span class="section-number">2.6. </span>Hartree-Fock algorithm<a class="headerlink" href="#hartree-fock-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Our Hartree-Fock matrix  is thus</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\langle \alpha | \hat{h}_0 | \beta \rangle+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
\]</div>
<p>The Hartree-Fock equations are solved in an iterative waym starting with a guess for the coefficients <span class="math notranslate nohighlight">\(C_{j\gamma}=\delta_{j,\gamma}\)</span> and solving the equations by diagonalization till the new single-particle energies
<span class="math notranslate nohighlight">\(\epsilon_i^{\mathrm{HF}}\)</span> do not change anymore by a prefixed quantity.</p>
<p>Normally we assume that the single-particle basis <span class="math notranslate nohighlight">\(|\beta\rangle\)</span> forms an eigenbasis for the operator
<span class="math notranslate nohighlight">\(\hat{h}_0\)</span>, meaning that the Hartree-Fock matrix becomes</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j=1}^A\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
\]</div>
<p>The Hartree-Fock eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[
\sum_{\beta}\hat{h}_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{\mathrm{HF}}C_{i\alpha},
\]</div>
<p>can be written out in a more compact form as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{HF}\hat{C}=\epsilon^{\mathrm{HF}}\hat{C}.
\]</div>
<p>The Hartree-Fock equations are, in their simplest form, solved in an iterative way, starting with a guess for the
coefficients <span class="math notranslate nohighlight">\(C_{i\alpha}\)</span>. We label the coefficients as <span class="math notranslate nohighlight">\(C_{i\alpha}^{(n)}\)</span>, where the subscript <span class="math notranslate nohighlight">\(n\)</span> stands for iteration <span class="math notranslate nohighlight">\(n\)</span>.
To set up the algorithm we can proceed as follows:</p>
<ul class="simple">
<li><p>We start with a guess <span class="math notranslate nohighlight">\(C_{i\alpha}^{(0)}=\delta_{i,\alpha}\)</span>. Alternatively, we could have used random starting values as long as the vectors are normalized. Another possibility is to give states below the Fermi level a larger weight.</p></li>
<li><p>The Hartree-Fock matrix simplifies then to (assuming that the coefficients <span class="math notranslate nohighlight">\(C_{i\alpha} \)</span>  are real)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j = 1}^A\sum_{\gamma\delta} C_{j\gamma}^{(0)}C_{j\delta}^{(0)}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
\]</div>
<p>Solving the Hartree-Fock eigenvalue problem yields then new eigenvectors <span class="math notranslate nohighlight">\(C_{i\alpha}^{(1)}\)</span> and eigenvalues
<span class="math notranslate nohighlight">\(\epsilon_i^{HF(1)}\)</span>.</p>
<ul class="simple">
<li><p>With the new eigenvalues we can set up a new Hartree-Fock potential</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\sum_{j = 1}^A\sum_{\gamma\delta} C_{j\gamma}^{(1)}C_{j\delta}^{(1)}\langle \alpha\gamma|\hat{v}|\beta\delta\rangle_{AS}.
\]</div>
<p>The diagonalization with the new Hartree-Fock potential yields new eigenvectors and eigenvalues.
This process is continued till for example</p>
<div class="math notranslate nohighlight">
\[
\frac{\sum_{p} |\epsilon_i^{(n)}-\epsilon_i^{(n-1)}|}{m} \le \lambda,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a user prefixed quantity (<span class="math notranslate nohighlight">\(\lambda \sim 10^{-8}\)</span> or smaller) and <span class="math notranslate nohighlight">\(p\)</span> runs over all calculated single-particle
energies and <span class="math notranslate nohighlight">\(m\)</span> is the number of single-particle states.</p>
</div>
<div class="section" id="analysis-of-hartree-fock-equations-and-koopman-s-theorem">
<h2><span class="section-number">2.7. </span>Analysis of Hartree-Fock equations and Koopman’s theorem<a class="headerlink" href="#analysis-of-hartree-fock-equations-and-koopman-s-theorem" title="Permalink to this headline">¶</a></h2>
<p>We can rewrite the ground state energy by adding and subtracting <span class="math notranslate nohighlight">\(\hat{u}^{HF}(x_i)\)</span></p>
<div class="math notranslate nohighlight">
\[
E_0^{HF} =\langle \Phi_0 | \hat{H} | \Phi_0\rangle = 
\sum_{i\le F}^A \langle i | \hat{h}_0 +\hat{u}^{HF}| j\rangle+ \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right]-\sum_{i\le F}^A \langle i |\hat{u}^{HF}| i\rangle,
\]</div>
<p>which results in</p>
<div class="math notranslate nohighlight">
\[
E_0^{HF}
  = \sum_{i\le F}^A \varepsilon_i^{HF} + \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right]-\sum_{i\le F}^A \langle i |\hat{u}^{HF}| i\rangle.
\]</div>
<p>Our single-particle states <span class="math notranslate nohighlight">\(ijk\dots\)</span> are now single-particle states obtained from the solution of the Hartree-Fock equations.</p>
<p>Using our definition of the Hartree-Fock single-particle energies we obtain then the following expression for the total ground-state energy</p>
<div class="math notranslate nohighlight">
\[
E_0^{HF}
  = \sum_{i\le F}^A \varepsilon_i - \frac{1}{2}\sum_{i\le F}^A\sum_{j \le F}^A\left[\langle ij |\hat{v}|ij \rangle-\langle ij|\hat{v}|ji\rangle\right].
\]</div>
<p>This form will be used in our discussion of Koopman’s theorem.</p>
<p>In the   atomic physics case we have</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N)] 
  = \sum_{i=1}^H \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1}^N\langle ij|\hat{v}|ij\rangle_{AS},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi^{\mathrm{HF}}(N)\)</span> is the new Slater determinant defined by the new basis of Eq. (<a class="reference external" href="#eq:newbasis">4</a>)
for <span class="math notranslate nohighlight">\(N\)</span> electrons (same <span class="math notranslate nohighlight">\(Z\)</span>).  If we assume that the single-particle wave functions in the new basis do not change
when we remove one electron or add one electron, we can then define the corresponding energy for the <span class="math notranslate nohighlight">\(N-1\)</span> systems as</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N-1)] 
  = \sum_{i=1; i\ne k}^N \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1;i,j\ne k}^N\langle ij|\hat{v}|ij\rangle_{AS},
\]</div>
<p>where we have removed a single-particle state <span class="math notranslate nohighlight">\(k\le F\)</span>, that is a state below the Fermi level.</p>
<p>Calculating the difference</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \langle k | \hat{h}_0 | k \rangle +
  \frac{1}{2}\sum_{i=1;i\ne k}^N\langle ik|\hat{v}|ik\rangle_{AS} + \frac{1}{2}\sum_{j=1;j\ne k}^N\langle kj|\hat{v}|kj\rangle_{AS},
\]</div>
<p>we obtain</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \langle k | \hat{h}_0 | k \rangle +\sum_{j=1}^N\langle kj|\hat{v}|kj\rangle_{AS}
\]</div>
<p>which is just our definition of the Hartree-Fock single-particle energy</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N)]-   E[\Phi^{\mathrm{HF}}(N-1)] = \epsilon_k^{\mathrm{HF}}
\]</div>
<p>Similarly, we can now compute the difference (we label the single-particle states above the Fermi level as <span class="math notranslate nohighlight">\(abcd &gt; F\)</span>)</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(N+1)]-   E[\Phi^{\mathrm{HF}}(N)]= \epsilon_a^{\mathrm{HF}}.
\]</div>
<p>These two equations can thus be used to the electron affinity or ionization energies, respectively.
Koopman’s theorem states that for example the ionization energy of a closed-shell system is given by the energy of the highest occupied single-particle state.  If we assume that changing the number of electrons from <span class="math notranslate nohighlight">\(N\)</span> to <span class="math notranslate nohighlight">\(N+1\)</span> does not change the Hartree-Fock single-particle energies and eigenfunctions, then Koopman’s theorem simply states that the ionization energy of an atom is given by the single-particle energy of the last bound state. In a similar way, we can also define the electron affinities.</p>
<p>As an example, consider a simple model for atomic sodium, Na. Neutral sodium has eleven electrons,
with the weakest bound one being confined the <span class="math notranslate nohighlight">\(3s\)</span> single-particle quantum numbers. The energy needed to remove an electron from neutral sodium is rather small, 5.1391 eV, a feature which pertains to all alkali metals.
Having performed a  Hartree-Fock calculation for neutral sodium would then allows us to compute the
ionization energy by using the single-particle energy for the <span class="math notranslate nohighlight">\(3s\)</span> states, namely <span class="math notranslate nohighlight">\(\epsilon_{3s}^{\mathrm{HF}}\)</span>.</p>
<p>From these considerations, we see that Hartree-Fock theory allows us to make a connection between experimental
observables (here ionization and affinity energies) and the underlying interactions between particles.<br />
In this sense, we are now linking the dynamics and structure of a many-body system with the laws of motion which govern the system. Our approach is a reductionistic one, meaning that we want to understand the laws of motion
in terms of the particles or degrees of freedom which we believe are the fundamental ones. Our Slater determinant, being constructed as the product of various single-particle functions, follows this philosophy.</p>
<p>With similar arguments as in atomic physics, we can now use Hartree-Fock theory to make a link
between nuclear forces and separation energies. Changing to nuclear system, we define</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A)] 
  = \sum_{i=1}^A \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1}^A\langle ij|\hat{v}|ij\rangle_{AS},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi^{\mathrm{HF}}(A)\)</span> is the new Slater determinant defined by the new basis of Eq. (<a class="reference external" href="#eq:newbasis">4</a>)
for <span class="math notranslate nohighlight">\(A\)</span> nucleons, where <span class="math notranslate nohighlight">\(A=N+Z\)</span>, with <span class="math notranslate nohighlight">\(N\)</span> now being the number of neutrons and <span class="math notranslate nohighlight">\(Z\)</span> th enumber of protons.  If we assume again that the single-particle wave functions in the new basis do not change from a nucleus with <span class="math notranslate nohighlight">\(A\)</span> nucleons to a nucleus with <span class="math notranslate nohighlight">\(A-1\)</span>  nucleons, we can then define the corresponding energy for the <span class="math notranslate nohighlight">\(A-1\)</span> systems as</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A-1)] 
  = \sum_{i=1; i\ne k}^A \langle i | \hat{h}_0 | i \rangle +
  \frac{1}{2}\sum_{ij=1;i,j\ne k}^A\langle ij|\hat{v}|ij\rangle_{AS},
\]</div>
<p>where we have removed a single-particle state <span class="math notranslate nohighlight">\(k\le F\)</span>, that is a state below the Fermi level.</p>
<p>Calculating the difference</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A)]-   E[\Phi^{\mathrm{HF}}(A-1)] 
  = \langle k | \hat{h}_0 | k \rangle +
  \frac{1}{2}\sum_{i=1;i\ne k}^A\langle ik|\hat{v}|ik\rangle_{AS} + \frac{1}{2}\sum_{j=1;j\ne k}^A\langle kj|\hat{v}|kj\rangle_{AS},
\]</div>
<p>which becomes</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A)]-   E[\Phi^{\mathrm{HF}}(A-1)] 
  = \langle k | \hat{h}_0 | k \rangle +\sum_{j=1}^A\langle kj|\hat{v}|kj\rangle_{AS}
\]</div>
<p>which is just our definition of the Hartree-Fock single-particle energy</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A)]-   E[\Phi^{\mathrm{HF}}(A-1)] 
  = \epsilon_k^{\mathrm{HF}}
\]</div>
<p>Similarly, we can now compute the difference (recall that the single-particle states <span class="math notranslate nohighlight">\(abcd &gt; F\)</span>)</p>
<div class="math notranslate nohighlight">
\[
E[\Phi^{\mathrm{HF}}(A+1)]-   E[\Phi^{\mathrm{HF}}(A)]= \epsilon_a^{\mathrm{HF}}.
\]</div>
<p>If we then recall that the binding energy differences</p>
<div class="math notranslate nohighlight">
\[
BE(A)-BE(A-1) \hspace{0.5cm} \mathrm{and} \hspace{0.5cm} BE(A+1)-BE(A),
\]</div>
<p>define the separation energies, we see that the Hartree-Fock single-particle energies can be used to
define separation energies. We have thus our first link between nuclear forces (included in the potential energy term) and an observable quantity defined by differences in binding energies.</p>
<p>We have thus the following interpretations (if the single-particle fields do not change)</p>
<div class="math notranslate nohighlight">
\[
BE(A)-BE(A-1)\approx  E[\Phi^{\mathrm{HF}}(A)]-   E[\Phi^{\mathrm{HF}}(A-1)] 
  = \epsilon_k^{\mathrm{HF}},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
BE(A+1)-BE(A)\approx  E[\Phi^{\mathrm{HF}}(A+1)]-   E[\Phi^{\mathrm{HF}}(A)] =  \epsilon_a^{\mathrm{HF}}.
\]</div>
<p>If  we use <span class="math notranslate nohighlight">\(^{16}\mbox{O}\)</span> as our closed-shell nucleus, we could then interpret the separation energy</p>
<div class="math notranslate nohighlight">
\[
BE(^{16}\mathrm{O})-BE(^{15}\mathrm{O})\approx \epsilon_{0p^{\nu}_{1/2}}^{\mathrm{HF}},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
BE(^{16}\mathrm{O})-BE(^{15}\mathrm{N})\approx \epsilon_{0p^{\pi}_{1/2}}^{\mathrm{HF}}.
\]</div>
<p>Similalry, we could interpret</p>
<div class="math notranslate nohighlight">
\[
BE(^{17}\mathrm{O})-BE(^{16}\mathrm{O})\approx \epsilon_{0d^{\nu}_{5/2}}^{\mathrm{HF}},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
BE(^{17}\mathrm{F})-BE(^{16}\mathrm{O})\approx\epsilon_{0d^{\pi}_{5/2}}^{\mathrm{HF}}.
\]</div>
<p>We can continue like this for all <span class="math notranslate nohighlight">\(A\pm 1\)</span> nuclei where <span class="math notranslate nohighlight">\(A\)</span> is a good closed-shell (or subshell closure)
nucleus. Examples are <span class="math notranslate nohighlight">\(^{22}\mbox{O}\)</span>, <span class="math notranslate nohighlight">\(^{24}\mbox{O}\)</span>, <span class="math notranslate nohighlight">\(^{40}\mbox{Ca}\)</span>, <span class="math notranslate nohighlight">\(^{48}\mbox{Ca}\)</span>, <span class="math notranslate nohighlight">\(^{52}\mbox{Ca}\)</span>, <span class="math notranslate nohighlight">\(^{54}\mbox{Ca}\)</span>, <span class="math notranslate nohighlight">\(^{56}\mbox{Ni}\)</span>,
<span class="math notranslate nohighlight">\(^{68}\mbox{Ni}\)</span>, <span class="math notranslate nohighlight">\(^{78}\mbox{Ni}\)</span>, <span class="math notranslate nohighlight">\(^{90}\mbox{Zr}\)</span>, <span class="math notranslate nohighlight">\(^{88}\mbox{Sr}\)</span>, <span class="math notranslate nohighlight">\(^{100}\mbox{Sn}\)</span>, <span class="math notranslate nohighlight">\(^{132}\mbox{Sn}\)</span> and <span class="math notranslate nohighlight">\(^{208}\mbox{Pb}\)</span>, to mention some possile cases.</p>
<p>We can thus make our first interpretation of the separation energies in terms of the simplest
possible many-body theory.
If we also recall that the so-called energy gap for neutrons (or protons) is defined as</p>
<div class="math notranslate nohighlight">
\[
\Delta S_n= 2BE(N,Z)-BE(N-1,Z)-BE(N+1,Z),
\]</div>
<p>for neutrons and the corresponding gap for protons</p>
<div class="math notranslate nohighlight">
\[
\Delta S_p= 2BE(N,Z)-BE(N,Z-1)-BE(N,Z+1),
\]</div>
<p>we can define the neutron and proton energy gaps for <span class="math notranslate nohighlight">\(^{16}\mbox{O}\)</span> as</p>
<div class="math notranslate nohighlight">
\[
\Delta S_{\nu}=\epsilon_{0d^{\nu}_{5/2}}^{\mathrm{HF}}-\epsilon_{0p^{\nu}_{1/2}}^{\mathrm{HF}},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\Delta S_{\pi}=\epsilon_{0d^{\pi}_{5/2}}^{\mathrm{HF}}-\epsilon_{0p^{\pi}_{1/2}}^{\mathrm{HF}}.
\]</div>
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-1-derivation-of-hartree-fock-equations">
<h2><span class="section-number">2.8. </span>Exercise 1: Derivation of Hartree-Fock equations<a class="headerlink" href="#exercise-1-derivation-of-hartree-fock-equations" title="Permalink to this headline">¶</a></h2>
<p>Consider a Slater determinant built up of single-particle orbitals <span class="math notranslate nohighlight">\(\psi_{\lambda}\)</span>,
with <span class="math notranslate nohighlight">\(\lambda = 1,2,\dots,N\)</span>.</p>
<p>The unitary transformation</p>
<div class="math notranslate nohighlight">
\[
\psi_a  = \sum_{\lambda} C_{a\lambda}\phi_{\lambda},
\]</div>
<p>brings us into the new basis.<br />
The new basis has quantum numbers <span class="math notranslate nohighlight">\(a=1,2,\dots,N\)</span>.</p>
<p><strong>a)</strong>
Show that the new basis is orthonormal.</p>
<p><strong>b)</strong>
Show that the new Slater determinant constructed from the new single-particle wave functions can be
written as the determinant based on the previous basis and the determinant of the matrix <span class="math notranslate nohighlight">\(C\)</span>.</p>
<p><strong>c)</strong>
Show that the old and the new Slater determinants are equal up to a complex constant with absolute value unity.</p>
<!-- --- begin hint in exercise --- -->
<p><strong>Hint.</strong>
Use the fact that <span class="math notranslate nohighlight">\(C\)</span> is a unitary matrix.</p>
<!-- --- end hint in exercise --- -->
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-2-derivation-of-hartree-fock-equations">
<h2><span class="section-number">2.9. </span>Exercise 2: Derivation of Hartree-Fock equations<a class="headerlink" href="#exercise-2-derivation-of-hartree-fock-equations" title="Permalink to this headline">¶</a></h2>
<p>Consider the  Slater  determinant</p>
<div class="math notranslate nohighlight">
\[
\Phi_{0}=\frac{1}{\sqrt{n!}}\sum_{p}(-)^{p}P
\prod_{i=1}^{n}\psi_{\alpha_{i}}(x_{i}).
\]</div>
<p>A small variation in this function is given by</p>
<div class="math notranslate nohighlight">
\[
\delta\Phi_{0}=\frac{1}{\sqrt{n!}}\sum_{p}(-)^{p}P
\psi_{\alpha_{1}}(x_{1})\psi_{\alpha_{2}}(x_{2})\dots
\psi_{\alpha_{i-1}}(x_{i-1})(\delta\psi_{\alpha_{i}}(x_{i}))
\psi_{\alpha_{i+1}}(x_{i+1})\dots\psi_{\alpha_{n}}(x_{n}).
\]</div>
<p><strong>a)</strong>
Show that</p>
<div class="math notranslate nohighlight">
\[
\langle \delta\Phi_{0}|\sum_{i=1}^{n}\left\{t(x_{i})+u(x_{i})
\right\}+\frac{1}{2}
\sum_{i\neq j=1}^{n}v(x_{i},x_{j})|\Phi_{0}\rangle=\sum_{i=1}^{n}\langle \delta\psi_{\alpha_{i}}|\hat{t}+\hat{u}
|\phi_{\alpha_{i}}\rangle
+\sum_{i\neq j=1}^{n}\left\{\langle\delta\psi_{\alpha_{i}}
\psi_{\alpha_{j}}|\hat{v}|\psi_{\alpha_{i}}\psi_{\alpha_{j}}\rangle-
\langle\delta\psi_{\alpha_{i}}\psi_{\alpha_{j}}|\hat{v}
|\psi_{\alpha_{j}}\psi_{\alpha_{i}}\rangle\right\}
\]</div>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-3-developing-a-hartree-fock-program">
<h2><span class="section-number">2.10. </span>Exercise 3: Developing a  Hartree-Fock program<a class="headerlink" href="#exercise-3-developing-a-hartree-fock-program" title="Permalink to this headline">¶</a></h2>
<p>Neutron drops are a powerful theoretical laboratory for testing,
validating and improving nuclear structure models. Indeed, all
approaches to nuclear structure, from ab initio theory to shell model
to density functional theory are applicable in such systems. We will,
therefore, use neutron drops as a test system for setting up a
Hartree-Fock code.  This program can later be extended to studies of
the binding energy of nuclei like <span class="math notranslate nohighlight">\(^{16}\)</span>O or <span class="math notranslate nohighlight">\(^{40}\)</span>Ca. The
single-particle energies obtained by solving the Hartree-Fock
equations can then be directly related to experimental separation
energies.
Since Hartree-Fock theory is the starting point for
several many-body techniques (density functional theory, random-phase
approximation, shell-model etc), the aim here is to develop a computer
program to solve the Hartree-Fock equations in a given single-particle basis,
here the harmonic oscillator.</p>
<p>The Hamiltonian for a system of <span class="math notranslate nohighlight">\(N\)</span> neutron drops confined in a
harmonic potential reads</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = \sum_{i=1}^{N} \frac{\hat{p}_{i}^{2}}{2m}+\sum_{i=1}^{N} \frac{1}{2} m\omega {r}_{i}^{2}+\sum_{i&lt;j} \hat{V}_{ij},
\]</div>
<p>with <span class="math notranslate nohighlight">\(\hbar^{2}/2m = 20.73\)</span> fm<span class="math notranslate nohighlight">\(^{2}\)</span>, <span class="math notranslate nohighlight">\(mc^{2} = 938.90590\)</span> MeV, and
<span class="math notranslate nohighlight">\(\hat{V}_{ij}\)</span> is the two-body interaction potential whose
matrix elements are precalculated
and to be read in by you.</p>
<p>The Hartree-Fock algorithm can be broken down as follows. We recall that  our Hartree-Fock matrix  is</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\langle \alpha \vert\hat{h}_0 \vert \beta \rangle+
\sum_{j=1}^N\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
\]</div>
<p>Normally we assume that the single-particle basis <span class="math notranslate nohighlight">\(\vert\beta\rangle\)</span>
forms an eigenbasis for the operator <span class="math notranslate nohighlight">\(\hat{h}_0\)</span> (this is our case), meaning that the
Hartree-Fock matrix becomes</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{j=1}^N\sum_{\gamma\delta} C^*_{j\gamma}C_{j\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
\]</div>
<p>The Hartree-Fock eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[
\sum_{\beta}\hat{h}_{\alpha\beta}^{HF}C_{i\beta}=\epsilon_i^{\mathrm{HF}}C_{i\alpha},
\]</div>
<p>can be written out in a more compact form as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}^{HF}\hat{C}=\epsilon^{\mathrm{HF}}\hat{C}.
\]</div>
<p>The equations are often rewritten in terms of a so-called density matrix,
which is defined as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\rho_{\gamma\delta}=\sum_{i=1}^{N}\langle\gamma|i\rangle\langle i|\delta\rangle = \sum_{i=1}^{N}C_{i\gamma}C^*_{i\delta}.
\label{_auto2} \tag{9}
\end{equation}
\]</div>
<p>It means that we can rewrite the Hartree-Fock Hamiltonian as</p>
<div class="math notranslate nohighlight">
\[
\hat{h}_{\alpha\beta}^{HF}=\epsilon_{\alpha}\delta_{\alpha,\beta}+
\sum_{\gamma\delta} \rho_{\gamma\delta}\langle \alpha\gamma|V|\beta\delta\rangle_{AS}.
\]</div>
<p>It is convenient to use the density matrix since we can precalculate in every iteration the product of two eigenvector components <span class="math notranslate nohighlight">\(C\)</span>.</p>
<p>Note that <span class="math notranslate nohighlight">\(\langle \alpha\vert\hat{h}_0\vert\beta \rangle\)</span> denotes the
matrix elements of the one-body part of the starting hamiltonian. For
self-bound nuclei <span class="math notranslate nohighlight">\(\langle \alpha\vert\hat{h}_0\vert\beta \rangle\)</span> is the
kinetic energy, whereas for neutron drops, <span class="math notranslate nohighlight">\(\langle \alpha \vert \hat{h}_0 \vert \beta \rangle\)</span> represents the harmonic oscillator hamiltonian since
the system is confined in a harmonic trap. If we are working in a
harmonic oscillator basis with the same <span class="math notranslate nohighlight">\(\omega\)</span> as the trapping
potential, then <span class="math notranslate nohighlight">\(\langle \alpha\vert\hat{h}_0 \vert \beta \rangle\)</span> is
diagonal.</p>
<p>The python
<a class="reference external" href="https://github.com/CompPhysics/ManyBodyMethods/tree/master/doc/src/hfock/Code">program</a>
shows how one can, in a brute force way read in matrix elements in
<span class="math notranslate nohighlight">\(m\)</span>-scheme and compute the Hartree-Fock single-particle energies for
four major shells. The interaction which has been used is the
so-called N3LO interaction of <a class="reference external" href="http://journals.aps.org/prc/abstract/10.1103/PhysRevC.68.041001">Machleidt and
Entem</a>
using the <a class="reference external" href="http://journals.aps.org/prc/abstract/10.1103/PhysRevC.75.061001">Similarity Renormalization
Group</a>
approach method to renormalize the interaction, using an oscillator
energy <span class="math notranslate nohighlight">\(\hbar\omega=10\)</span> MeV.</p>
<p>The nucleon-nucleon two-body matrix elements are in <span class="math notranslate nohighlight">\(m\)</span>-scheme and are fully anti-symmetrized. The Hartree-Fock programs uses the density matrix discussed above in order to compute the Hartree-Fock matrix.
Here we display the Hartree-Fock part only, assuming that single-particle data and two-body matrix elements have already been read in.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="c1"># expectation value for the one body part, Harmonic oscillator in three dimensions</span>
<span class="k">def</span> <span class="nf">onebody</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="n">homega</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="k">return</span> <span class="n">homega</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
        
    <span class="n">Nparticles</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="sd">&quot;&quot;&quot; Read quantum numbers from file &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mj</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spOrbitals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;nucleispnumbers.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">qnumfile</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">qnumfile</span><span class="p">:</span>
                        <span class="n">nums</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                                <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                                <span class="n">j</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
                                <span class="n">mj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
                                <span class="n">tz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
                                <span class="n">spOrbitals</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="sd">&quot;&quot;&quot; Read two-nucleon interaction elements (integrals) from file, brute force 4-dim array &quot;&quot;&quot;</span>
    <span class="n">nninteraction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">spOrbitals</span><span class="p">,</span> <span class="n">spOrbitals</span><span class="p">,</span> <span class="n">spOrbitals</span><span class="p">,</span> <span class="n">spOrbitals</span><span class="p">])</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;nucleitwobody.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
                <span class="n">number</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">nninteraction</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">][</span><span class="n">c</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="sd">&quot;&quot;&quot; Set up single-particle integral &quot;&quot;&quot;</span>
        <span class="n">singleparticleH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                <span class="n">singleparticleH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">onebody</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        
        <span class="sd">&quot;&quot;&quot; Star HF-iterations, preparing variables and density matrix &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot; Coefficients for setting up density matrix, assuming only one along the diagonals &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">)</span> <span class="c1"># HF coefficients</span>
        <span class="n">DensityMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">spOrbitals</span><span class="p">,</span><span class="n">spOrbitals</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nparticles</span><span class="p">):</span>
                    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">C</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">delta</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">DensityMatrix</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
        <span class="n">maxHFiter</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">epsilon</span> <span class="o">=</span>  <span class="mf">1.0e-5</span> 
        <span class="n">difference</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">hf_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">oldenergies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">)</span>
        <span class="n">newenergies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">hf_count</span> <span class="o">&lt;</span> <span class="n">maxHFiter</span> <span class="ow">and</span> <span class="n">difference</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;############### Iteration </span><span class="si">%i</span><span class="s2"> ###############&quot;</span> <span class="o">%</span> <span class="n">hf_count</span><span class="p">)</span>
                <span class="n">HFmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">spOrbitals</span><span class="p">,</span><span class="n">spOrbitals</span><span class="p">])</span>            
                <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                            <span class="sd">&quot;&quot;&quot;  If tests for three-dimensional systems, including isospin conservation &quot;&quot;&quot;</span>
                            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mj</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mj</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tz</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tz</span><span class="p">[</span><span class="n">beta</span><span class="p">]:</span> <span class="k">continue</span>
                            <span class="sd">&quot;&quot;&quot;  Setting up the Fock matrix using the density matrix and antisymmetrized NN interaction in m-scheme &quot;&quot;&quot;</span>
                            <span class="n">sumFockTerm</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="n">mj</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span><span class="o">+</span><span class="n">mj</span><span class="p">[</span><span class="n">gamma</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="n">mj</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span><span class="o">+</span><span class="n">mj</span><span class="p">[</span><span class="n">delta</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tz</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span><span class="o">+</span><span class="n">tz</span><span class="p">[</span><span class="n">gamma</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tz</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span><span class="o">+</span><span class="n">tz</span><span class="p">[</span><span class="n">delta</span><span class="p">]):</span> <span class="k">continue</span>
                                    <span class="n">sumFockTerm</span> <span class="o">+=</span> <span class="n">DensityMatrix</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">delta</span><span class="p">]</span><span class="o">*</span><span class="n">nninteraction</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">gamma</span><span class="p">][</span><span class="n">beta</span><span class="p">][</span><span class="n">delta</span><span class="p">]</span>
                            <span class="n">HFmatrix</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">sumFockTerm</span><span class="p">)</span>
                            <span class="sd">&quot;&quot;&quot;  Adding the one-body term, here plain harmonic oscillator &quot;&quot;&quot;</span>
                            <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>   <span class="n">HFmatrix</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">alpha</span><span class="p">]</span> <span class="o">+=</span> <span class="n">singleparticleH</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
                <span class="n">spenergies</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">HFmatrix</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot; Setting up new density matrix in m-scheme &quot;&quot;&quot;</span>
                <span class="n">DensityMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">spOrbitals</span><span class="p">,</span><span class="n">spOrbitals</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nparticles</span><span class="p">):</span>
                            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">C</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">delta</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">DensityMatrix</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
                <span class="n">newenergies</span> <span class="o">=</span> <span class="n">spenergies</span>
                <span class="sd">&quot;&quot;&quot; Brute force computation of difference between previous and new sp HF energies &quot;&quot;&quot;</span>
                <span class="nb">sum</span> <span class="o">=</span><span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                    <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">newenergies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">oldenergies</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">/</span><span class="n">spOrbitals</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="nb">sum</span>
                <span class="n">oldenergies</span> <span class="o">=</span> <span class="n">newenergies</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Single-particle energies, ordering may have changed &quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spOrbitals</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:4d}</span><span class="s1">  </span><span class="si">{1:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">oldenergies</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
                <span class="n">hf_count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">FileNotFoundError</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">e5c9e25d47eb</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">     </span><span class="mi">17</span>     <span class="n">tz</span> <span class="o">=</span> <span class="p">[]</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span>     <span class="n">spOrbitals</span> <span class="o">=</span> <span class="mi">0</span>
<span class="ne">---&gt; </span><span class="mi">19</span>     <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;nucleispnumbers.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">qnumfile</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">20</span>                 <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">qnumfile</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">21</span>                         <span class="n">nums</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="ne">FileNotFoundError</span>: [Errno 2] No such file or directory: &#39;nucleispnumbers.dat&#39;
</pre></div>
</div>
</div>
</div>
<p>Running the program, one finds that the lowest-lying states for a nucleus like <span class="math notranslate nohighlight">\(^{16}\mbox{O}\)</span>, we see that the nucleon-nucleon force brings a natural spin-orbit splitting for the <span class="math notranslate nohighlight">\(0p\)</span> states (or other states except the <span class="math notranslate nohighlight">\(s\)</span>-states).
Since we are using the <span class="math notranslate nohighlight">\(m\)</span>-scheme for our calculations, we observe that there are several states with the same
eigenvalues. The number of eigenvalues corresponds to the degeneracy <span class="math notranslate nohighlight">\(2j+1\)</span> and is well respected in our calculations, as see from the table here.</p>
<p>The values of the lowest-lying states are (<span class="math notranslate nohighlight">\(\pi\)</span> for protons and <span class="math notranslate nohighlight">\(\nu\)</span> for neutrons)</p>
<table border="1">
<thead>
<tr><th align="center">Quantum numbers </th> <th align="center">Energy [MeV]</th> </tr>
</thead>
<tbody>
<tr><td align="center">   $0s_{1/2}^{\pi}$    </td> <td align="center">   -40.4602        </td> </tr>
<tr><td align="center">   $0s_{1/2}^{\pi}$    </td> <td align="center">   -40.4602        </td> </tr>
<tr><td align="center">   $0s_{1/2}^{\nu}$    </td> <td align="center">   -40.6426        </td> </tr>
<tr><td align="center">   $0s_{1/2}^{\nu}$    </td> <td align="center">   -40.6426        </td> </tr>
<tr><td align="center">   $0p_{1/2}^{\pi}$    </td> <td align="center">   -6.7133         </td> </tr>
<tr><td align="center">   $0p_{1/2}^{\pi}$    </td> <td align="center">   -6.7133         </td> </tr>
<tr><td align="center">   $0p_{1/2}^{\nu}$    </td> <td align="center">   -6.8403         </td> </tr>
<tr><td align="center">   $0p_{1/2}^{\nu}$    </td> <td align="center">   -6.8403         </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\pi}$    </td> <td align="center">   -11.5886        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\pi}$    </td> <td align="center">   -11.5886        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\pi}$    </td> <td align="center">   -11.5886        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\pi}$    </td> <td align="center">   -11.5886        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\nu}$    </td> <td align="center">   -11.7201        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\nu}$    </td> <td align="center">   -11.7201        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\nu}$    </td> <td align="center">   -11.7201        </td> </tr>
<tr><td align="center">   $0p_{3/2}^{\nu}$    </td> <td align="center">   -11.7201        </td> </tr>
<tr><td align="center">   $0d_{5/2}^{\pi}$    </td> <td align="center">   18.7589         </td> </tr>
<tr><td align="center">   $0d_{5/2}^{\nu}$    </td> <td align="center">   18.8082         </td> </tr>
</tbody>
</table>
We can use these results to attempt our first link with experimental data, namely to compute the shell gap or the separation energies. The shell gap for neutrons is given by<div class="math notranslate nohighlight">
\[
\Delta S_n= 2BE(N,Z)-BE(N-1,Z)-BE(N+1,Z).
\]</div>
<p>For <span class="math notranslate nohighlight">\(^{16}\mbox{O}\)</span>  we have an experimental value for the  shell gap of <span class="math notranslate nohighlight">\(11.51\)</span> MeV for neutrons, while our Hartree-Fock calculations result in <span class="math notranslate nohighlight">\(25.65\)</span> MeV. This means that correlations beyond a simple Hartree-Fock calculation with a two-body force play an important role in nuclear physics.
The splitting between the <span class="math notranslate nohighlight">\(0p_{3/2}^{\nu}\)</span> and the <span class="math notranslate nohighlight">\(0p_{1/2}^{\nu}\)</span> state is 4.88 MeV, while the experimental value for the gap between the ground state <span class="math notranslate nohighlight">\(1/2^{-}\)</span> and the first excited <span class="math notranslate nohighlight">\(3/2^{-}\)</span> states is 6.08 MeV. The two-nucleon spin-orbit force plays a central role here. In our discussion of nuclear forces we will see how the spin-orbit force comes into play here.</p>
<!-- --- end exercise --- -->
</div>
<div class="section" id="hartree-fock-in-second-quantization-and-stability-of-hf-solution">
<h2><span class="section-number">2.11. </span>Hartree-Fock in second quantization and stability of HF solution<a class="headerlink" href="#hartree-fock-in-second-quantization-and-stability-of-hf-solution" title="Permalink to this headline">¶</a></h2>
<p>We wish now to derive the Hartree-Fock equations using our second-quantized formalism and study the stability of the equations.
Our ansatz for the ground state of the system is approximated as (this is our representation of a Slater determinant in second quantization)</p>
<div class="math notranslate nohighlight">
\[
|\Phi_0\rangle = |c\rangle = a^{\dagger}_i a^{\dagger}_j \dots a^{\dagger}_l|0\rangle.
\]</div>
<p>We wish to determine <span class="math notranslate nohighlight">\(\hat{u}^{HF}\)</span> so that
<span class="math notranslate nohighlight">\(E_0^{HF}= \langle c|\hat{H}| c\rangle\)</span> becomes a local minimum.</p>
<p>In our analysis here we will need Thouless’ theorem, which states that
an arbitrary Slater determinant <span class="math notranslate nohighlight">\(|c'\rangle\)</span> which is not orthogonal to a determinant
<span class="math notranslate nohighlight">\(| c\rangle ={\displaystyle\prod_{i=1}^{n}}
a_{\alpha_{i}}^{\dagger}|0\rangle\)</span>, can be written as</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle=exp\left\{\sum_{a&gt;F}\sum_{i\le F}C_{ai}a_{a}^{\dagger}a_{i}\right\}| c\rangle
\]</div>
<p>Let us give a simple proof of Thouless’ theorem. The theorem states that we can make a linear combination av particle-hole excitations  with respect to a given reference state <span class="math notranslate nohighlight">\(\vert c\rangle\)</span>. With this linear combination, we can make a new Slater determinant <span class="math notranslate nohighlight">\(\vert c'\rangle \)</span> which is not orthogonal to
<span class="math notranslate nohighlight">\(\vert c\rangle\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[
\langle c|c'\rangle \ne 0.
\]</div>
<p>To show this we need some intermediate steps. The exponential product of two operators  <span class="math notranslate nohighlight">\(\exp{\hat{A}}\times\exp{\hat{B}}\)</span> is equal to <span class="math notranslate nohighlight">\(\exp{(\hat{A}+\hat{B})}\)</span> only if the two operators commute, that is</p>
<div class="math notranslate nohighlight">
\[
[\hat{A},\hat{B}] = 0.
\]</div>
</div>
<div class="section" id="thouless-theorem">
<h2><span class="section-number">2.12. </span>Thouless’ theorem<a class="headerlink" href="#thouless-theorem" title="Permalink to this headline">¶</a></h2>
<p>If the operators do not commute, we need to resort to the <a class="reference external" href="http://www.encyclopediaofmath.org/index.php/Campbell%E2%80%93Hausdorff_formula">Baker-Campbell-Hauersdorf</a>. This relation states that</p>
<div class="math notranslate nohighlight">
\[
\exp{\hat{C}}=\exp{\hat{A}}\exp{\hat{B}},
\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[
\hat{C}=\hat{A}+\hat{B}+\frac{1}{2}[\hat{A},\hat{B}]+\frac{1}{12}[[\hat{A},\hat{B}],\hat{B}]-\frac{1}{12}[[\hat{A},\hat{B}],\hat{A}]+\dots
\]</div>
<p>From these relations, we note that
in our expression  for <span class="math notranslate nohighlight">\(|c'\rangle\)</span> we have commutators of the type</p>
<div class="math notranslate nohighlight">
\[
[a_{a}^{\dagger}a_{i},a_{b}^{\dagger}a_{j}],
\]</div>
<p>and it is easy to convince oneself that these commutators, or higher powers thereof, are all zero. This means that we can write out our new representation of a Slater determinant as</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle=exp\left\{\sum_{a&gt;F}\sum_{i\le F}C_{ai}a_{a}^{\dagger}a_{i}\right\}| c\rangle=\prod_{i}\left\{1+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}+\left(\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}\right)^2+\dots\right\}| c\rangle
\]</div>
<p>We note that</p>
<div class="math notranslate nohighlight">
\[
\prod_{i}\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}\sum_{b&gt;F}C_{bi}a_{b}^{\dagger}a_{i}| c\rangle =0,
\]</div>
<p>and all higher-order powers of these combinations of creation and annihilation operators disappear
due to the fact that <span class="math notranslate nohighlight">\((a_i)^n| c\rangle =0\)</span> when <span class="math notranslate nohighlight">\(n &gt; 1\)</span>. This allows us to rewrite the expression for <span class="math notranslate nohighlight">\(|c'\rangle \)</span> as</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle=\prod_{i}\left\{1+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}\right\}| c\rangle,
\]</div>
<p>which we can rewrite as</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle=\prod_{i}\left\{1+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}\right\}| a^{\dagger}_{i_1} a^{\dagger}_{i_2} \dots a^{\dagger}_{i_n}|0\rangle.
\]</div>
<p>The last equation can be written as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
|c'\rangle=\prod_{i}\left\{1+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}a_{i}\right\}| a^{\dagger}_{i_1} a^{\dagger}_{i_2} \dots a^{\dagger}_{i_n}|0\rangle=\left(1+\sum_{a&gt;F}C_{ai_1}a_{a}^{\dagger}a_{i_1}\right)a^{\dagger}_{i_1} 
\label{_auto3} \tag{10}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
 \times\left(1+\sum_{a&gt;F}C_{ai_2}a_{a}^{\dagger}a_{i_2}\right)a^{\dagger}_{i_2} \dots |0\rangle=\prod_{i}\left(a^{\dagger}_{i}+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}\right)|0\rangle.
\label{_auto4} \tag{11}
\end{equation}
\]</div>
</div>
<div class="section" id="new-operators">
<h2><span class="section-number">2.13. </span>New operators<a class="headerlink" href="#new-operators" title="Permalink to this headline">¶</a></h2>
<p>If we define a new creation operator</p>
<!-- Equation labels as ordinary links -->
<div id="eq:newb"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
b^{\dagger}_{i}=a^{\dagger}_{i}+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}, \label{eq:newb} \tag{12}
\end{equation}
\]</div>
<p>we have</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle=\prod_{i}b^{\dagger}_{i}|0\rangle=\prod_{i}\left(a^{\dagger}_{i}+\sum_{a&gt;F}C_{ai}a_{a}^{\dagger}\right)|0\rangle,
\]</div>
<p>meaning that the new representation of the Slater determinant in second quantization, <span class="math notranslate nohighlight">\(|c'\rangle\)</span>, looks like our previous ones. However, this representation is not general enough since we have a restriction on the sum over single-particle states in Eq. (<a class="reference external" href="#eq:newb">12</a>). The single-particle states have all to be above the Fermi level.
The question then is whether we can construct a general representation of a Slater determinant with a creation operator</p>
<div class="math notranslate nohighlight">
\[
\tilde{b}^{\dagger}_{i}=\sum_{p}f_{ip}a_{p}^{\dagger},
\]</div>
<p>where <span class="math notranslate nohighlight">\(f_{ip}\)</span> is a matrix element of a unitary matrix which transforms our creation and annihilation operators
<span class="math notranslate nohighlight">\(a^{\dagger}\)</span> and <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(\tilde{b}^{\dagger}\)</span> and <span class="math notranslate nohighlight">\(\tilde{b}\)</span>. These new operators define a new representation of a Slater determinant as</p>
<div class="math notranslate nohighlight">
\[
|\tilde{c}\rangle=\prod_{i}\tilde{b}^{\dagger}_{i}|0\rangle.
\]</div>
</div>
<div class="section" id="showing-that-tilde-c-rangle-c-rangle">
<h2><span class="section-number">2.14. </span>Showing that <span class="math notranslate nohighlight">\(|\tilde{c}\rangle= |c'\rangle\)</span><a class="headerlink" href="#showing-that-tilde-c-rangle-c-rangle" title="Permalink to this headline">¶</a></h2>
<p>We need to show that <span class="math notranslate nohighlight">\(|\tilde{c}\rangle= |c'\rangle\)</span>. We need also to assume that the new state
is not orthogonal to <span class="math notranslate nohighlight">\(|c\rangle\)</span>, that is <span class="math notranslate nohighlight">\(\langle c| \tilde{c}\rangle \ne 0\)</span>. From this it follows that</p>
<div class="math notranslate nohighlight">
\[
\langle c| \tilde{c}\rangle=\langle 0| a_{i_n}\dots a_{i_1}\left(\sum_{p=i_1}^{i_n}f_{i_1p}a_{p}^{\dagger} \right)\left(\sum_{q=i_1}^{i_n}f_{i_2q}a_{q}^{\dagger} \right)\dots \left(\sum_{t=i_1}^{i_n}f_{i_nt}a_{t}^{\dagger} \right)|0\rangle,
\]</div>
<p>which is nothing but the determinant <span class="math notranslate nohighlight">\(det(f_{ip})\)</span> which we can, using the intermediate normalization condition,
normalize to one, that is</p>
<div class="math notranslate nohighlight">
\[
det(f_{ip})=1,
\]</div>
<p>meaning that <span class="math notranslate nohighlight">\(f\)</span> has an inverse defined as (since we are dealing with orthogonal, and in our case unitary as well, transformations)</p>
<div class="math notranslate nohighlight">
\[
\sum_{k} f_{ik}f^{-1}_{kj} = \delta_{ij},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\sum_{j} f^{-1}_{ij}f_{jk} = \delta_{ik}.
\]</div>
<p>Using these relations we can then define the linear combination of creation (and annihilation as well)
operators as</p>
<div class="math notranslate nohighlight">
\[
\sum_{i}f^{-1}_{ki}\tilde{b}^{\dagger}_{i}=\sum_{i}f^{-1}_{ki}\sum_{p=i_1}^{\infty}f_{ip}a_{p}^{\dagger}=a_{k}^{\dagger}+\sum_{i}\sum_{p=i_{n+1}}^{\infty}f^{-1}_{ki}f_{ip}a_{p}^{\dagger}.
\]</div>
<p>Defining</p>
<div class="math notranslate nohighlight">
\[
c_{kp}=\sum_{i \le F}f^{-1}_{ki}f_{ip},
\]</div>
<p>we can redefine</p>
<div class="math notranslate nohighlight">
\[
a_{k}^{\dagger}+\sum_{i}\sum_{p=i_{n+1}}^{\infty}f^{-1}_{ki}f_{ip}a_{p}^{\dagger}=a_{k}^{\dagger}+\sum_{p=i_{n+1}}^{\infty}c_{kp}a_{p}^{\dagger}=b_k^{\dagger},
\]</div>
<p>our starting point. We have shown that our general representation of a Slater determinant</p>
<div class="math notranslate nohighlight">
\[
|\tilde{c}\rangle=\prod_{i}\tilde{b}^{\dagger}_{i}|0\rangle=|c'\rangle=\prod_{i}b^{\dagger}_{i}|0\rangle,
\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[
b_k^{\dagger}=a_{k}^{\dagger}+\sum_{p=i_{n+1}}^{\infty}c_{kp}a_{p}^{\dagger}.
\]</div>
<p>This means that we can actually write an ansatz for the ground state of the system as a linear combination of
terms which contain the ansatz itself <span class="math notranslate nohighlight">\(|c\rangle\)</span> with  an admixture from an infinity of one-particle-one-hole states. The latter has important consequences when we wish to interpret the Hartree-Fock equations and their stability. We can rewrite the new representation as</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle = |c\rangle+|\delta c\rangle,
\]</div>
<p>where <span class="math notranslate nohighlight">\(|\delta c\rangle\)</span> can now be interpreted as a small variation. If we approximate this term with
contributions from one-particle-one-hole (<em>1p-1h</em>) states only, we arrive at</p>
<div class="math notranslate nohighlight">
\[
|c'\rangle = \left(1+\sum_{ai}\delta C_{ai}a_{a}^{\dagger}a_i\right)|c\rangle.
\]</div>
<p>In our derivation of the Hartree-Fock equations we have shown that</p>
<div class="math notranslate nohighlight">
\[
\langle \delta c| \hat{H} | c\rangle =0,
\]</div>
<p>which means that we have to satisfy</p>
<div class="math notranslate nohighlight">
\[
\langle c|\sum_{ai}\delta C_{ai}\left\{a_{a}^{\dagger}a_i\right\} \hat{H} | c\rangle =0.
\]</div>
<p>With this as a background, we are now ready to study the stability of the Hartree-Fock equations.</p>
</div>
<div class="section" id="id1">
<h2><span class="section-number">2.15. </span>Hartree-Fock in second quantization and stability of HF solution<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The variational condition for deriving the Hartree-Fock equations guarantees only that the expectation value <span class="math notranslate nohighlight">\(\langle c | \hat{H} | c \rangle\)</span> has an extreme value, not necessarily a minimum. To figure out whether the extreme value we have found  is a minimum, we can use second quantization to analyze our results and find a criterion
for the above expectation value to a local minimum. We will use Thouless’ theorem and show that</p>
<div class="math notranslate nohighlight">
\[
\frac{\langle c' |\hat{H} | c'\rangle}{\langle c' |c'\rangle} \ge \langle c |\hat{H} | c\rangle= E_0,
\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[
{|c'\rangle} = {|c\rangle + |\delta c\rangle}.
\]</div>
<p>Using Thouless’ theorem we can write out <span class="math notranslate nohighlight">\(|c'\rangle\)</span> as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
 {|c'\rangle}=\exp\left\{\sum_{a &gt; F}\sum_{i \le F}\delta C_{ai}a_{a}^{\dagger}a_{i}\right\}| c\rangle
\label{_auto5} \tag{13}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
=\left\{1+\sum_{a &gt; F}\sum_{i \le F}\delta C_{ai}a_{a}^{\dagger}
a_{i}+\frac{1}{2!}\sum_{ab &gt; F}\sum_{ij \le F}\delta C_{ai}\delta C_{bj}a_{a}^{\dagger}a_{i}a_{b}^{\dagger}a_{j}+\dots\right\}
\label{_auto6} \tag{14}
\end{equation}
\]</div>
<p>where the amplitudes <span class="math notranslate nohighlight">\(\delta C\)</span> are small.</p>
<p>The norm of <span class="math notranslate nohighlight">\(|c'\rangle\)</span> is given by (using the intermediate normalization condition <span class="math notranslate nohighlight">\(\langle c' |c\rangle=1\)</span>)</p>
<div class="math notranslate nohighlight">
\[
\langle c' | c'\rangle = 1+\sum_{a&gt;F}
\sum_{i\le F}|\delta C_{ai}|^2+O(\delta C_{ai}^3).
\]</div>
<p>The expectation value for the energy is now given by (using the Hartree-Fock condition)</p>
<p>1
4
5</p>
<p>&lt;
&lt;
&lt;
!
!
M
A
T
H
_
B
L
O
C
K</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{2!}\sum_{ab&gt;F}
\sum_{ij\le F}\delta C_{ai}\delta C_{bj}\langle c |\hat{H}a_{a}^{\dagger}a_{i}a_{b}^{\dagger}a_{j}|c\rangle+\frac{1}{2!}\sum_{ab&gt;F}
\sum_{ij\le F}\delta C_{ai}^*\delta C_{bj}^*\langle c|a_{j}^{\dagger}a_{b}a_{i}^{\dagger}a_{a}\hat{H}|c\rangle
+\dots
\]</div>
<p>We have already calculated the second term on the right-hand side of the previous equation</p>
<!-- Equation labels as ordinary links -->
<div id="_auto7"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\langle c | \left(\{a^\dagger_i a_a\} \hat{H} \{a^\dagger_b a_j\} \right) | c\rangle=\sum_{pq} \sum_{ijab}\delta C_{ai}^*\delta C_{bj} \langle p|\hat{h}_0 |q\rangle 
            \langle c | \left(\{a^{\dagger}_i a_a\}\{a^{\dagger}_pa_q\} 
             \{a^{\dagger}_b a_j\} \right)| c\rangle
\label{_auto7} \tag{15}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
 +\frac{1}{4} \sum_{pqrs} \sum_{ijab}\delta C_{ai}^*\delta C_{bj} \langle pq| \hat{v}|rs\rangle 
            \langle c | \left(\{a^\dagger_i a_a\}\{a^{\dagger}_p a^{\dagger}_q a_s  a_r\} \{a^{\dagger}_b a_j\} \right)| c\rangle ,
\label{_auto8} \tag{16}
\end{equation}
\]</div>
<p>resulting in</p>
<div class="math notranslate nohighlight">
\[
E_0\sum_{ai}|\delta C_{ai}|^2+\sum_{ai}|\delta C_{ai}|^2(\varepsilon_a-\varepsilon_i)-\sum_{ijab} \langle aj|\hat{v}| bi\rangle \delta C_{ai}^*\delta C_{bj}.
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{1}{2!}\langle c |\left(\{a^\dagger_j a_b\} \{a^\dagger_i a_a\} \hat{V}_N  \right) | c\rangle  = 
\frac{1}{2!}\langle c |\left( \hat{V}_N \{a^\dagger_a a_i\} \{a^\dagger_b a_j\} \right)^{\dagger} | c\rangle
\]</div>
<p>which is nothing but</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{2!}\langle c |  \left( \hat{V}_N \{a^\dagger_a a_i\} \{a^\dagger_b a_j\} \right) | c\rangle^*
=\frac{1}{2} \sum_{ijab} (\langle ij|\hat{v}|ab\rangle)^*\delta C_{ai}^*\delta C_{bj}^*
\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{2} \sum_{ijab} (\langle ab|\hat{v}|ij\rangle)\delta C_{ai}^*\delta C_{bj}^*
\]</div>
<p>where we have used the relation</p>
<div class="math notranslate nohighlight">
\[
\langle a |\hat{A} | b\rangle =  (\langle b |\hat{A}^{\dagger} | a\rangle)^*
\]</div>
<p>due to the hermiticity of <span class="math notranslate nohighlight">\(\hat{H}\)</span> and <span class="math notranslate nohighlight">\(\hat{V}\)</span>.</p>
<p>We define two matrix elements</p>
<div class="math notranslate nohighlight">
\[
A_{ai,bj}=-\langle aj|\hat{v} bi\rangle
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
B_{ai,bj}=\langle ab|\hat{v}|ij\rangle
\]</div>
<p>both being anti-symmetrized.</p>
<p>With these definitions we write out the energy as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto9"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\langle c'|H|c'\rangle = \left(1+\sum_{ai}|\delta C_{ai}|^2\right)\langle c |H|c\rangle+\sum_{ai}|\delta C_{ai}|^2(\varepsilon_a^{HF}-\varepsilon_i^{HF})+\sum_{ijab}A_{ai,bj}\delta C_{ai}^*\delta C_{bj}+
\label{_auto9} \tag{17}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto10"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\frac{1}{2} \sum_{ijab} B_{ai,bj}^*\delta C_{ai}\delta C_{bj}+\frac{1}{2} \sum_{ijab} B_{ai,bj}\delta C_{ai}^*\delta C_{bj}^*
+O(\delta C_{ai}^3),
\label{_auto10} \tag{18}
\end{equation}
\]</div>
<p>which can be rewritten as</p>
<div class="math notranslate nohighlight">
\[
\langle c'|H|c'\rangle = \left(1+\sum_{ai}|\delta C_{ai}|^2\right)\langle c |H|c\rangle+\Delta E+O(\delta C_{ai}^3),
\]</div>
<p>and skipping higher-order terms we arrived</p>
<div class="math notranslate nohighlight">
\[
\frac{\langle c' |\hat{H} | c'\rangle}{\langle c' |c'\rangle} =E_0+\frac{\Delta E}{\left(1+\sum_{ai}|\delta C_{ai}|^2\right)}.
\]</div>
<p>We have defined</p>
<div class="math notranslate nohighlight">
\[
\Delta E = \frac{1}{2} \langle \chi | \hat{M}| \chi \rangle
\]</div>
<p>with the vectors</p>
<div class="math notranslate nohighlight">
\[
\chi = \left[ \delta C\hspace{0.2cm} \delta C^*\right]^T
\]</div>
<p>and the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{M}=\left(\begin{array}{cc} \Delta + A &amp; B \\ B^* &amp; \Delta + A^*\end{array}\right),
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\Delta_{ai,bj} = (\varepsilon_a-\varepsilon_i)\delta_{ab}\delta_{ij}\)</span>.</p>
<p>The condition</p>
<div class="math notranslate nohighlight">
\[
\Delta E = \frac{1}{2} \langle \chi | \hat{M}| \chi \rangle \ge 0
\]</div>
<p>for an arbitrary  vector</p>
<div class="math notranslate nohighlight">
\[
\chi = \left[ \delta C\hspace{0.2cm} \delta C^*\right]^T
\]</div>
<p>means that all eigenvalues of the matrix have to be larger than or equal zero.
A necessary (but no sufficient) condition is that the matrix elements (for all <span class="math notranslate nohighlight">\(ai\)</span> )</p>
<div class="math notranslate nohighlight">
\[
(\varepsilon_a-\varepsilon_i)\delta_{ab}\delta_{ij}+A_{ai,bj} \ge 0.
\]</div>
<p>This equation can be used as a first test of the stability of the Hartree-Fock equation.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="basicmanybody.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">1. </span>Many-body Hamiltonians, basic linear algebra and Second Quantization</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="fcitheory.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">3. </span>Full configuration interaction theory</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Morten Hjorth-Jensen<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>